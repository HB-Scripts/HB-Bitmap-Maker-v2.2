;<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>;
;<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>;
;HB Bitmap Maker v2
;A GDI+ Visual Studio.
;Screen Capture, Window Capture, Image Creation, Image Editing, Code Generation
;Written By: @Hellbent
;Date Started: Aug 29th, 2024
;Current version: v2.2.3
;Last Edit: Oct(<>) 2024
;Change log:                    *<<<---Note: I'm not very diligent with this, not every change gets logged*
;Added DrawRectangle element type (oct23rd,2024)
;Modified brushes so that they can be converted to pens (oct23rd,2024)
;Turned off +AlwaysOnTop (oct23rd,2024)
;
;
;
;Notes/Resources:
;Requires a copy of GDIP_ALL for ahk v2: https://raw.githubusercontent.com/buliasz/AHKv2-Gdip/master/Gdip_All.ahk
;Requires a copy of PopupWindow_V4 for ahk v2: https://www.autohotkey.com/boards/viewtopic.php?f=83&t=132744&p=583099#p583097
;Requires a copy of Vectors for ahk v2: https://www.autohotkey.com/boards/viewtopic.php?f=83&t=132770&p=583213#p583213
;
;
;
;*Has known warnings that need to be worked out. As far as I can tell, none of them cause the script to break. ( i.e. you get warned if you close the load file window without selecting a file.)
;<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>;
;<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>|<<<(**)>>>;
#Requires AutoHotkey v2.0
#SingleInstance Force
#Warn All, Off
; #Include <GDIP_ALL V2> ;https://raw.githubusercontent.com/buliasz/AHKv2-Gdip/master/Gdip_All.ahk
; #Include <PopUpWindow v4_1> ;https://www.autohotkey.com/boards/viewtopic.php?f=83&t=132744&p=583099#p583097
; #Include <HB Vectors v3> ;https://www.autohotkey.com/boards/viewtopic.php?f=83&t=132770&p=583213#p583213
pToken := Gdip_Startup()

Main.Setup()

return
; *ESC::ExitApp
;----------------
TimedTips( msg , time := 1500 ){
    ToolTip( msg )
    SetTimer( TipOff , Abs( time ) * -1 )
    return 0
}
TipOff(*){
    ToolTip()
}
;----------------
class Main extends MainEvents {
    
    static DataList{
        Get{
            return DataClass.GetSavedBitmapList( This.DataFolder )
        }
    }
    static GetBitmap(){
        if( !This.Bitmaps.Length )
            return 0
        return This.Bitmaps[ This.SelectedBitmap ]
    }
    static GetLayers(){
        if( !This.Bitmaps.Length )
            return 0
        return This.Bitmaps[ This.SelectedBitmap ].Layers
    }
    static GetLayer(){
        if( !This.Bitmaps.Length )
            return 0
        return This.GetLayers()[ This.SelectedLayer ]
    }
    static GetElements(){
        if( !This.Bitmaps.Length )
            return 0
        return This.GetLayer().Elements
    }
    static GetElement(){
        if( !This.Bitmaps.Length || !This.GetLayer() )
            return 0
        return This.GetElements()[ This.SelectedElement ]
    }
    static GuiClose(*){
        Main.MainWindow.Opt( "+OwnDialogs" )
        if( MsgBox( "Are you sure the you want to exit?`nAny unsaved progress will be lost" , "Exit Program" , 262148 ) = "yes" )
            ExitApp        
        return -1
    }
    static GuiSize(*){
        local x := "" , y := "" , w := "" , h := ""
        Main.MainWindow.GetClientPos( &x , &y , &w , &h )
        This.DisplayWindow.Show( "x" 185 " y" 5 " w" w - 185 - 5 " h" h - 10 )
    }
    static GuiContextMenu(*){
        This.MainWindow.Hide()
        Try BitmapPanel.ActiveWindow.Window.Destroy()
        Try LayerPanel.ActiveWindow.Window.Destroy()
        Try ElementPanel.ActiveWindow.Window.Destroy()
        This.TabWindow := PopupWindow_v4( { Options: "+AlwaysOnTop +ToolWindow" , Rect: { X: 0 , Y: A_ScreenHeight / 2 + 60 , W: 7 , H: 30 } } )
        This.TabWindow.Clear( 1 , "0x663399ff" )
        This.TabWindow.Window.OnEvent( "ContextMenu" , This.ToggleTab.Bind( This ) )
    }
    static ToggleTab(*){
        This.TabWindow.Delete()
        This.MainWindow.Show()
    }
    static X{
        Get{
            local x := "" 
            This.MainWindow.GetPos( &x )
            return x 
        }
    }
    static Y{
        Get{
            local y := "" 
            This.MainWindow.GetPos( , &y )
            return y
        }
    }
    static W{
        Get{
            local w := "" 
            This.MainWindow.GetPos( ,, &w )
            return w 
        }
    }
    static H{
        Get{
            local h := "" 
            This.MainWindow.GetPos( ,,, &h )
            return h
        }
    }
    static Setup(){
        This.SetDefaults()
        This.CreateMainWindow()
        This.AddMainWindowControls()
        This.MainWindow.Show( "x" A_ScreenWidth - 350 )
        This.DisplayWindow.Show( "x" This.W + 10 " y" 10 " w" 0 " h" This.H - 20 )
        OnMessage( 0x020A , This._WheelChange.Bind( This ) )
        DetachWindowClass.Setup()
    }
    static SetDefaults(){
        This.IconSize := 30
        This.Bitmaps := []
        This.SelectedBitmap := 0
        This.SelectedLayer := 0
        This.SelectedElement := 0
        This.Controls := {}
        This.ControlHandles := {}
        This.ControlIndex := 0
        This.Busy := 0
        This.WindowsList := {}
        This.WindowsList.LoadWindowHwnd := "9999999999999999999"
        This.WindowsList.SaveWindowHwnd := "9999999999999999999"
        This.WindowsList.NewBitmapWindowHwnd := "9999999999999999999"
        This.WindowsList.LayerPanelHwnd := "9999999999999999999"
        This.WindowsList.BitmapPanelHwnd := "9999999999999999999"
        This.WindowsList.ElementPanelHwnd := "9999999999999999999"
        This.SelectedNewElementType := "FillRectangle"
        This.MainFolder := A_ScriptDir "\HB Bitmap Maker v2_2\"
        This.ScreenShotsFolder := This.MainFolder "ScreenShots Folder\"
        This.DataFolder := This.MainFolder "Data Folder\"
        This.CodeFolder := This.MainFolder "Code Folder\"
        This.CreateDirectories()
    }
    static CreateDirectories(){
        if( !DirExist( This.MainFolder ) )
            DirCreate( This.MainFolder )
        if( !DirExist( This.ScreenShotsFolder )  )
            DirCreate( This.ScreenShotsFolder )
        if( !DirExist( This.DataFolder )  )
            DirCreate( This.DataFolder )
        if( !DirExist( This.CodeFolder )  )
            DirCreate( This.CodeFolder )
        TimedTips( "Folders Created" )
    }
    static CreateMainWindow(){
        This.MainWindow := Gui( "+Resize MinSize185x555" , "HB Bitmap Maker v2" )
        This.MainWindow.OnEvent( "Close" , This.GuiClose.Bind( This ) )
        This.MainWindow.OnEvent( "ContextMenu" , This.GuiContextMenu.Bind( This ) )
        This.MainWindow.OnEvent( "Size" , This.GuiSize.Bind( This ) )
        This.MainWindow.BackColor := "22262a"
        This.MainWindow.MarginX := 2
        This.MainWindow.MarginY := 2
        This.DisplayWindow := Gui( "+Parent" This.MainWindow.Hwnd " -Caption -DPIScale +ToolWindow" , "Display Area Window" )
        This.DisplayWindow.BackColor := "000000"
    }
    static AddMainWindowControls(){
        local lbW := 150
        This.MainWindow.SetFont( "s" 8 " bold" , "Arial" )
        This.AddControl( "Text" , "xm ym w" This.IconSize " h" This.IconSize " Center 0x200 Background33ff99 cBlack" , "New" ,, "Click" , This.NewBitmap.Bind( This ) )
        This.AddControl( "Text" , "x+m yp w" This.IconSize " h" This.IconSize " Center 0x200 BackgroundF6D572 cBlack" , "Load" ,, "Click" ,This.LoadBitmap.Bind( This ) )
        This.AddControl( "Text" , "x+m yp w" This.IconSize " h" This.IconSize " Center 0x200 Backgroundaa3333 cBlack" , "Save" ,, "Click" , This.SaveBitmap.Bind( This ) )
        This.MainWindow.SetFont( "s" 10 " bold")
        This.AddControl( "ListBox" , "xm y+m w" lbW " r7 Background336699" ,, "BitmapsListBox" , "Change" , This.OnChange_BitmapsListbox.Bind( This ) )
        This.MainWindow.SetFont( "s" 16 " norm" , "Webdings" )
        This.AddControl( "Text" , "x+m yp w" This.IconSize " h" This.IconSize " Center 0x200 Background16497c c00ffff" , "@" ,, "Click" , This.ToggleBitmapPanel.Bind( This ) )
        This.MainWindow.SetFont( "s" 16 " Bold" , "Wingdings" )
        This.AddControl( "Text" , "xp y+m w" This.IconSize " h" This.IconSize " Center 0x200 BackgroundF6D572 c000000" , "4" ,, "Click" , This.CopyBitmap.Bind( This ) )
        This.MainWindow.SetFont( "s" 16 " norm" , "Webdings" )
        This.AddControl( "Text" , "xp y+m w" This.IconSize " h" This.IconSize " Center 0x200 Background880000 cFFFF00" , "r" ,, "Click" , This.DeleteBitmap.Bind( This ) )       
        This.MainWindow.SetFont( "s" 10 " bold" , "Arial" )
        This.AddControl( "ListBox" , "xm w" lbW " r8 Background16497c" ,, "LayersListbox" , "Change" , This.OnChange_LayersListbox.Bind( This ) )
        This.MainWindow.SetFont( "s" 16 " norm" , "Webdings" )
        This.AddControl( "Text" , "x+m yp w" This.IconSize " h" This.IconSize " Center 0x200 Background16497c c00ffff" , "@" ,, "Click" , This.ToggleLayerPanel.Bind( This ) )
        This.MainWindow.SetFont( "s" 8 " bold" , "Arial" )
        This.AddControl( "Text" , "xp y+m w" This.IconSize " h" This.IconSize " Center 0x200 Background33ff99 cBlack" , "New" ,, "Click" , This.NewLayer.Bind( This ) )
        This.MainWindow.SetFont( "s" 16 " Bold" , "Wingdings" )
        This.AddControl( "Text" , "xp y+m w" This.IconSize " h" This.IconSize " Center 0x200 BackgroundF6D572 c000000" , "4" ,, "Click" , This.CopyLayer.Bind( This ) )
        This.MainWindow.SetFont( "s" 16 " norm" , "Webdings" )
        This.AddControl( "Text" , "xp y+m w" This.IconSize " h" This.IconSize " Center 0x200 Background880000 cFFFF00" , "r" ,, "Click" , This.DeleteLayer.Bind( This ) )
        This.MainWindow.SetFont( "s" 9 " bold" , "Arial" )
        This.AddControl( "DDL" , "xm w" lbW " r15 Background16497c choose1 cWhite AltSubmit" , [ "FillRectangle" , "DrawText" , "DrawImage" , "DrawRectangle" , "FillEllipse" ], "ElementTypesDDL" , "Change" , This.OnChange_ElementTypesDDL.Bind( This ) )
        This.MainWindow.SetFont( "s" 10 " bold" , "Arial" )
        This.AddControl( "ListBox" , "xm w" lbW " r15 Background16497c" ,, "ElementsListbox" , "Change" , This.OnChange_ElementsListbox.Bind( This ) )
        This.MainWindow.SetFont( "s" 16 " norm" , "Webdings" )
        This.AddControl( "Text" , "x+m yp w" This.IconSize " h" This.IconSize " Center 0x200 Background16497c c00ffff" , "@" ,, "Click" , This.ToggleElementPanel.Bind( This ) )
        This.MainWindow.SetFont( "s" 8 " bold" , "Arial" )
        This.AddControl( "Text" , "xp y+m w" This.IconSize " h" This.IconSize " Center 0x200 Background33ff99 cBlack" , "New" ,, "Click" , This.NewElement.Bind( This ) )
        This.MainWindow.SetFont( "s" 16 " Bold" , "Wingdings" )
        This.AddControl( "Text" , "xp y+m w" This.IconSize " h" This.IconSize " Center 0x200 BackgroundF6D572 c000000" , "4" ,, "Click" , This.CopyElement.Bind( This ) )
        This.MainWindow.SetFont( "s" 16 " norm" , "Webdings" )
        This.AddControl( "Text" , "xp y+m w" This.IconSize " h" This.IconSize " Center 0x200 Background880000 cFFFF00" , "r" ,, "Click" , This.DeleteElement.Bind( This ) )
        This.MainWindow.SetFont( "s" 8 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w" This.IconSize * 1.6 " h" This.IconSize " Center  Background00FFFF c000000" , "Screen`nClip" ,, "Click" , This.ScreenClip.Bind( This ) )
        This.AddControl( "Text" , "x+m yp w" This.IconSize * 1.7 " h" This.IconSize " Center  Backgroundffff00 c000000" , "Window`nClip" ,, "Click" , This.WindowClip.Bind( This ) )
        This.AddControl( "Text" , "x+m yp w" This.IconSize * 1.6 " h" This.IconSize " Center 0x200 Backgroundff0000 cffffff" , "X" ,, "Click" , This.NotAssigned.Bind( This ) )
        This.AddControl( "Text" , "xm wp h" This.IconSize " Center 0x200 Background336699 cffffff" , "X" ,, "Click" , This.NotAssigned.Bind( This ) )
        This.AddControl( "Text" , "x+m yp w" This.IconSize * 1.7 " h" This.IconSize " Center 0x200 Background6699cc c000000" , "X" ,, "Click" , This.NotAssigned.Bind( This ) )
        This.AddControl( "Text" , "x+m yp w" This.IconSize * 1.6 " h" This.IconSize " Center 0x200 Background99ccff c000000" , "X" ,, "Click" , This.NotAssigned.Bind( This ) )
    }
    static AddControl( type := "Text" , options := "" , value := "" , name := "" , eventType := "" , eventBind := "" ){
        local cc := "" , hwnd 
        This.ControlIndex++
        if( value != "" ) 
            cc := This.MainWindow.Add( type , options , value )
        else 
            cc := This.MainWindow.Add( type , options )
        if( name = "" )
            name := type "_" This.ControlIndex
        cc.Name := name 
        cc.Index := This.ControlIndex
        hwnd := cc.Hwnd 
        This.ControlHandles.%hwnd% := cc 
        This.Controls.%Name% := cc
        if( eventType != "" && eventBind != "" )
            cc.OnEvent( eventType , eventBind )
    }
}

class MainEvents {

    static _WheelChange( wParam , lParam , uMsg , hWnd ){
        if( Main.Busy )
            return
        Main.Busy := 1
        Try{
            Direction := ( ( wParam >> 16 ) > 0x7FFF ) || ( ( wParam < 0 ) ? ( 1 ) : ( 0 ) ) ;up = 0 , down = 1 
            for k , v in Main.WindowsList.OwnProps()    {
                MouseGetPos( ,, &win )
                if( win = Main.WindowsList.%k% ){
                    function := StrReplace( k , "hwnd" , "WheelFunction" )                    
                    value := WheelEvents.%function%( hwnd , Direction )
                    Main.Busy := 0
                    return value
                }
            }        
        }catch{
            Main.Busy := 0
            return
        }
        Main.Busy := 0
    }
    static NewBitmap( button , * ){
        static init := 0
        local bitmap := ""
        local x := "" , y := "" , w := "" , h := "" , wX := "" , wY := ""
        if( !init && init := 1 ){
            button.GetPos( &x , &y , &w , &h )
            Main.MainWindow.GetPos( &wX , &wY )
            NewBitmapPanel.WinVector := Vector( x + w , y + h )
            NewBitmapPanel.WinVector.Add( wX , wY )
        }
        bitmap := NewBitmapPanel( Main ).Bitmap
        if( bitmap = 0 ){
            TimedTips( "Action Canceled" )
            return 
        }
        Main.Bitmaps.Push( BitmapsClass( bitmap ) )
        This.UpdateListBox( "Bitmap" )
        This.SetSelected( "Bitmap" , Main.Bitmaps.Length )
        This.UpdateListBox( "Layer" )
        This.SetSelected( "Layer" , 1 )
        ; if( IsObject( ElementPanel.ActiveWindow ) && IsObject( ElementPanel.ActiveWindow.Window ) )
        ;     Main.ToggleElementPanel( 444 )
    }
    static LoadBitmap( button , * ){
        static init := 0
        local bitmap := ""
        local x := "" , y := "" , w := "" , h := "" , wX := "" , wY := ""
        if( !init && init := 1 ){
            button.GetPos( &x , &y , &w , &h )
            Main.MainWindow.GetPos( &wX , &wY )
            LoadBitmapPanel.WinVector := Vector( x + w , y + h )
            LoadBitmapPanel.WinVector.Add( wX , wY )
        }
        bitmap := LoadBitmapPanel( Main ).Bitmap
        if( bitmap = 0 ){
            TimedTips( "Action Canceled" )
            Main.MainWindow.Show()
            return 
        }
        nBitmap := {}
        for k , v in StrSplit( DataClass.BitmapKeyList , "|" ){
            if( v = "Rect" )
                nBitmap.%v% := bitmap.%v%.Clone()
            else if( v = "NumberOfLayers" )
                continue
            else
                nBitmap.%v% := bitmap.%v%            
        }
        Main.Bitmaps.Push( BitmapsClass( nBitmap ) )
        Main.SelectedBitmap := Main.Bitmaps.Length
        nBitmap := Main.GetBitmap()
        Main.SelectedLayer := nBitmap.Layers.Length
        layer := Main.GetLayer()
        for k , v in StrSplit( DataClass.LayerKeyList , "|" ){
            if( v = "Rect" )
                layer.%v% := bitmap.Layers[ 1 ].%v%.Clone()
            else if( v = "NumberOfElements" )
                continue
            else
                layer.%v% := bitmap.Layers[ 1 ].%v%    
               
        }
        if( bitmap.Layers[ 1 ].Elements.Length ){
            loop( bitmap.Layers[ 1 ].Elements.Length )
                layer.AddElement( bitmap.Layers[ 1 ].Elements[ A_Index ] )            
        } 
        if( bitmap.Layers.Length > 1 ){
            Loop( bitmap.Layers.Length - 1 ){
                nLayer := LayersClass( nBitmap )
                index := A_Index
                for k , v in StrSplit( DataClass.LayerKeyList , "|" ){
                    if( v = "Rect" ){
                        nLayer.%v% := Bitmap.Layers[ index + 1 ].%v%.Clone()
                        nLayer.Window.Resize( 1 , nLayer.%v% )
                    }
                    else if( v = "NumberOfElements" )
                        continue
                    else
                        nLayer.%v% := bitmap.Layers[ index + 1 ].%v%      
                }
                nBitmap.Layers.Push( nLayer )
                if( bitmap.Layers[ index + 1 ].Elements.Length ){
                    loop( bitmap.Layers[ index + 1 ].Elements.Length )
                        nLayer.AddElement( bitmap.Layers[ index + 1 ].Elements[ A_Index ] )                    
                } 
            }            
        }        
        nBitmap.CycleLayerOrder()
        This.UpdateListBox( "Bitmap" )
        This.SetSelected( "Bitmap" , Main.Bitmaps.Length )
        This.UpdateListBox( "Layer" )
        This.SetSelected( "Layer" , 1 )
        if( Main.GetLayer().Elements.Length ){
            This.UpdateListBox( "Element" )
            This.SetSelected( "Element" , 1 )
        }
        Main.MainWindow.Show()
    }
    static SaveBitmap( button , * ){
        static init := 0
        local bitmap := ""
        local x := "" , y := "" , w := "" , h := "" , wX := "" , wY := ""
        if( Main.Bitmaps.Length = 0 ){
            TimedTips( "No bitmaps detected." )
            SoundBeep( 555 , 50 )
            SoundBeep( 555 , 50 )
            return
        }
        if( !init && init := 1 ){
            button.GetPos( &x , &y , &w , &h )
            Main.MainWindow.GetPos( &wX , &wY )
            SaveBitmapPanel.WinVector := Vector( x + w , y + h )
            SaveBitmapPanel.WinVector.Add( wX , wY )
        }
        bitmap := Main.GetBitmap()
        SaveBitmapPanel( Main , bitmap )
    }
    static ToggleBitmapPanel( inputTog , * ){
        static tog := 0
        static init := 0
        if( inputTog = 444 ){
            BitmapPanel.ActiveWindow.Window.GetPos( &x , &y )
            BitmapPanel.WinVector := Vector( x , y )
            BitmapPanel( Main , Main.GetBitmap() )
            return
        }else if( inputTog = 333 ){
            tog := 0
            return        
        }
        if( !init && init := 1 ){
            inputTog.GetPos( &x , &y , &w , &h )
            Main.MainWindow.GetPos( &wX , &wY )
            BitmapPanel.WinVector := Vector( x + w , 0 )
            BitmapPanel.WinVector.Add( wX , wY )
        }
        if( Main.Bitmaps.Length = 0 ){
            TimedTips( "Create A Bitmap" )
            return
        }
        if( inputTog = 333 ){
            tog := 0
            return
        }else{
            if( tog := !tog ){
                BitmapPanel( Main , Main.GetBitmap() )
            }else{
                try{
                    BitmapPanel.ActiveWindow.Destroy()
                }                
            }
        }
        TimedTips( "Toggle Bitmap Panel" )
    }
    static CopyBitmap(*){
        local LayerKeyList := "Name|Rect|Smoothing|InterpolationMode|IsHidden|Note"
        local bitmap := Main.GetBitmap()        
        if( bitmap = 0 )
            return
        cBitmap := {}
        for k , v in StrSplit( LayerKeyList , "|" )   {
            
            if( v = "rect" ){
                cBitmap.Rect := {}
                cBitmap.Rect := bitmap.Rect.Clone()
            }else{
                cBitmap.%v% := bitmap.%v%
            }
        }
        Main.Bitmaps.Push( BitmapsClass( cBitmap ) )
        cBitmap := Main.Bitmaps[ Main.Bitmaps.Length ]
        Main.SelectedBitmap := Main.Bitmaps.Length
        Loop( bitmap.Layers.Length ){
            index := A_Index
            if( index != 1 ){
                cBitmap.AddLayer()
            }
            cLayer := cBitmap.Layers[ A_Index ]
            layer := bitmap.Layers[ A_Index ]
            for k , v in StrSplit( LayerKeyList , "|" ) {
                if( v = "Rect" ){
                    cLayer.Rect := {}
                    cLayer.Rect := layer.Rect.Clone()
                }else{
                    cLayer.%v% := layer.%v%
                }
            }
        }
        Loop( bitmap.Layers.Length ){
            Index := A_Index
            layer := bitmap.Layers[ A_Index ]
            cLayer := cBitmap.Layers[ A_Index ]
            if( layer.Elements.Length ){
                Loop( layer.Elements.Length ){
                    element := layer.Elements[ A_Index ]
                    cElement := {}
                    for k , v in element.OwnProps(){
                        if( IsObject( element.%k% ) ){
                            cElement.%k% := {}
                            for i , j in element.%k%.OwnProps() {
                                if( IsObject( element.%k%.%i% ) ){
                                    cElement.%k%.%i% := {}
                                    cElement.%k%.%i% := element.%k%.%i%.Clone()
                                }else{
                                    cElement.%k%.%i% := element.%k%.%i%
                                }
                            }
                        }else{
                            cElement.%k% := element.%k%
                        }
                    }
                    cLayer.AddElement( cElement )
                }
                cLayer.Window.Resize( 1 , cLayer.Rect.X , cLayer.Rect.Y , cLayer.Rect.W , cLayer.Rect.H )
                cLayer.DrawLayer()
            }
        }
        cBitmap.CycleLayerOrder()
        This.UpdateListBox( "Bitmap" )
        This.SetSelected( "Bitmap" , Main.Bitmaps.Length )
        This.UpdateListBox( "Layer" )
        This.SetSelected( "Layer" , 1 )
        TimedTips( "Copy Bitmap" )
    }
    static DeleteBitmap(*){
        local bitmap := Main.GetBitmap()
        if( Main.Bitmaps.Length = 0 )
            return
        bitmap.DeleteBitmap()
        Main.Bitmaps.RemoveAt( Main.SelectedBitmap )
        if( Main.Bitmaps.Length >= Main.SelectedBitmap )
            This.UpdateListBox( "Bitmap" )
        else 
            This.UpdateListBox( "Bitmap" , Main.Bitmaps.Length )
        This.UpdateListBox( "Layer" , 1 )
    }
    static ToggleLayerPanel( inputTog , * ){
        static tog := 0
        static init := 0
        if( !init && init := 1 ){
            inputTog.GetPos( &x , &y , &w , &h )
            Main.MainWindow.GetPos( &wX , &wY )
            LayerPanel.WinVector := Vector( x + w , 0 )
            LayerPanel.WinVector.Add( wX , wY )
        }
        if( Main.Bitmaps.Length = 0 ){
            TimedTips( "Create A Bitmap" )
            return
        }
        if( inputTog = 333 ){
            tog := 0
            return
        }else{
            if( tog := !tog ){
                LayerPanel( Main , Main.GetLayer() )
            }else{
                try{
                    LayerPanel.ActiveWindow.Destroy()
                }                
            }
        }
        TimedTips( "Toggle Layer Panel" )
    }
    static NewLayer(*){
        if( Main.Bitmaps.Length = 0 )
            return
        bitmap := Main.GetBitmap()
        Bitmap.AddLayer()
        Bitmap.CycleLayerOrder()
        This.UpdateListBox( "Layer" )
        This.SetSelected( "Layer" , bitmap.Layers.Length )
        This.UpdateListBox( "Element" )
        This.SetSelected( "Element" , Main.SelectedElement := 0 )
        if( IsObject( ElementPanel.ActiveWindow ) && IsObject( ElementPanel.ActiveWindow.Window ) )
            Main.ToggleElementPanel( 444 )
    }
    static CopyLayer(*){
        local keys := "Name|X|Y|W|H|Smoothing|InterpolationMode|IsHidden|Note"
        local bitmap := Main.GetBitmap()
        local layers := Main.GetLayers()
        local layer := Main.GetLayer()
        bitmap.AddLayer()
        nLayer := bitmap.Layers[ bitmap.Layers.Length ]        
        for k , v in StrSplit( keys , "|" ) {
            if( InStr( "XYWH" , v ) )
                nLayer.Rect.%v% := Layer.Rect.%v%
            else
                nLayer.%v% := Layer.%v%
        }
        Main.SelectedLayer := bitmap.Layers.Length
        Loop( layer.Elements.Length ){
            element := layer.Elements[ A_Index ]
            nLayer.Elements.Push( element.Clone() )
        }
        nLayer.DrawLayer()
        This.UpdateListBox( "Layer" )
        This.SetSelected( "Layer" , Main.SelectedLayer )
        This.UpdateListBox( "Element" )
        This.SetSelected( "ELement" , Main.SelectedElement := 1 )
        if( IsObject( ElementPanel.ActiveWindow ) && IsObject( ElementPanel.ActiveWindow.Window ) )
            Main.ToggleElementPanel( 444 )
    }
    static DeleteLayer(*){
        local layer := Main.GetLayer()
        local bitmap := Main.GetBitmap()
        if( Main.Bitmaps.Length = 0 )
            return
        if( bitmap.Layers.Length = 1 ){
            layer.Elements := []
            layer.DrawLayer()
        }else{
            layer.RemoveLayer()
            bitmap.Layers.RemoveAt( Main.SelectedLayer )
        }
        if( bitmap.Layers.Length >= Main.SelectedLayer )
            This.UpdateListBox( "Layer" )
        else 
            This.UpdateListBox( "Layer" , bitmap.Layers.Length )
    }
    static ToggleElementPanel( inputTog , * ){
        static tog := 0
        static init := 0
        if( inputTog = 444 ){
            ElementPanel.ActiveWindow.Window.GetPos( &x , &y )
            ElementPanel.WinVector := Vector( x , y )
            ElementPanel( Main , Main.GetElement() )
            return
        }else if( inputTog = 333 ){
            tog := 0
            return        
        }
        if( !init && init := 1 ){
            inputTog.GetPos( &x , &y , &w , &h )
            Main.MainWindow.GetPos( &wX , &wY )
            ElementPanel.WinVector := Vector( x + w , 0 )
            ElementPanel.WinVector.Add( wX , wY )
        }
        if( Main.Bitmaps.Length = 0 ){
            TimedTips( "Create A Bitmap" )
            return
        }
        if( !Main.GetLayer().Elements.Length && inputTog != 0 ){
            TimedTips( "Create A Element" )
            return
        }
        if( tog := !tog ){
            ElementPanel( Main , Main.GetElement() )
        }else{
            try{
                ElementPanel.ActiveWindow.Destroy()
            }                
        }
    }
    static NewElement(*){
        local layer := Main.GetLayer()
        if( !Main.Bitmaps.Length )
            return 0
        layer.AddElement()
        element := Main.GetElement()
        if( element.ElementType = "DrawImage" ){
            Main.MainWindow.Opt( "+OwnDialogs" )
            path := FileSelect( , A_Desktop )            
            if( path ){
                element.Path := path
                element.ImageBitmap := Gdip_CreateBitmapFromFile( path )
                element.Rect.W := element.SourceRect.W := Gdip_GetImageWidth( element.ImageBitmap )
                element.Rect.H := element.SourceRect.H := Gdip_GetImageHeight( element.ImageBitmap )
            }
        }
        This.UpdateListBox( type := "Element" , Main.SelectedElement )
        if( IsObject( ElementPanel.ActiveWindow ) && IsObject( ElementPanel.ActiveWindow.Window ) )
            Main.ToggleElementPanel( 444 )
    }
    static CopyElement(*){
        if( Main.Bitmaps.Length ){
            if( Main.GetLayer().Elements.Length ){
                Main.GetLayer().CopyElement()
                Main.SelectedElement := Main.GetElements().Length
                Main.UpdateListBox( "Element" )
                if( IsObject( ElementPanel.ActiveWindow ) && IsObject( ElementPanel.ActiveWindow.Window ) )
                    Main.ToggleElementPanel( 444 )
            }
        }
    }
    static DeleteElement(*){
        Main.GetLayer().RemoveElement()
    }
    static ScreenClip(*){
        if( GetKeyState( "Shift" ) ){
            While( GetKeyState( "Shift" ) ){
                ToolTip( "Release the `"Shift`" key" )
                Sleep( 30 )
            }
            ToolTip()
            if( bitmapObj := ScreenCapClass.TakeScreenCap( type := "Normal" ) ){
                Gdip_DisposeImage( bitmapObj.pBitmap )
                A_Clipboard := Main.ScreenShotsFolder "Temp ScreenShot Folder\" bitmapObj.Name ".png"
                TimedTips( "ScreenClip File Path`nAdded To The Clipboard." )
                return
            }
        }
        if( bitmapObj := ScreenCapClass.TakeScreenCap( type := "Normal" ) ){
            Bitmap := {}
            for k , v in NewBitmapPanel.Defaults.OwnProps(){
                if( IsObject( NewBitmapPanel.Defaults.%k% ) )
                    Bitmap.%k% := NewBitmapPanel.Defaults.%k%.Clone()
                else
                    Bitmap.%k% := NewBitmapPanel.Defaults.%k%
            }
            Bitmap.Rect := bitmapObj.Rect.Clone()
            Bitmap.Rect.X := Bitmap.Rect.Y := 0
            Bitmap.Name := bitmapObj.Name
            Main.Bitmaps.Push( BitmapsClass( Bitmap ) )
            Main.SelectedBitmap := Main.Bitmaps.Length
            bitmap := Main.GetBitmap()
            bitmap.pBitmap := 1
            layer := bitmap.Layers[ 1 ]
            layer.Name := "ScreenClip"
            element := ElementsClass.NewElement( "DrawImage" )
            element.Rect := bitmap.Rect.Clone()
            element.SourceRect := bitmap.Rect.Clone()
            element.Path := Main.ScreenShotsFolder "Temp ScreenShot Folder\" bitmap.Name ".png"
            element.ImageBitmap := bitmapObj.pBitmap
            lsne := Main.SelectedNewElementType
            Main.SelectedNewElementType := "DrawImage"
            layer.AddElement( element )
            Main.SelectedNewElementType := lsne
            bitmap.AddLayer()
            This.UpdateListBox( "Bitmap" )
            This.SetSelected( "Bitmap" , Main.SelectedBitmap )
            This.UpdateListBox( "Layer" )
            This.SetSelected( "Layer" , 2 )
            This.UpdateListBox( "element" )
            This.SetSelected( "element" , 1 )
        }
    }
    static WindowClip(*){
        if( GetKeyState( "Shift" ) ){
            While( GetKeyState( "Shift" ) ){
                ToolTip( "Release the shift key" )
                Sleep( 30 )
            }
            ToolTip()
            if( bitmapObj := ScreenCapClass.WindowCapture() ){
                Gdip_DisposeImage( bitmapObj.pBitmap )
                A_Clipboard := Main.ScreenShotsFolder "Temp ScreenShot Folder\" bitmapObj.Name ".png"
                TimedTips( "WindowClip File Path`nAdded To The Clipboard." )
                return
            }
        }
        if( bitmapObj := ScreenCapClass.WindowCapture() ){
            Bitmap := {}
            for k , v in NewBitmapPanel.Defaults.OwnProps(){
                if( IsObject( NewBitmapPanel.Defaults.%k% ) )
                    Bitmap.%k% := NewBitmapPanel.Defaults.%k%.Clone()
                else
                    Bitmap.%k% := NewBitmapPanel.Defaults.%k%
            }
            Bitmap.Rect := bitmapObj.Rect.Clone()
            Bitmap.Rect.X := Bitmap.Rect.Y := 0
            Bitmap.Name := bitmapObj.Name
            Main.Bitmaps.Push( BitmapsClass( Bitmap ) )
            Main.SelectedBitmap := Main.Bitmaps.Length
            bitmap := Main.GetBitmap()
            bitmap.pBitmap := 1
            layer := bitmap.Layers[ 1 ]
            element := ElementsClass.NewElement( "DrawImage" )
            element.Rect := bitmap.Rect.Clone()
            element.SourceRect := bitmap.Rect.Clone()
            element.Path := Main.ScreenShotsFolder "Temp ScreenShot Folder\" bitmap.Name ".png"
            element.ImageBitmap := bitmapObj.pBitmap
            lsne := Main.SelectedNewElementType
            Main.SelectedNewElementType := "DrawImage"
            layer.AddElement( element )
            Main.SelectedNewElementType := lsne
            This.UpdateListBox( "Bitmap" )
            This.SetSelected( "Bitmap" , Main.SelectedBitmap )
            This.UpdateListBox( "Layer" )
            This.SetSelected( "Layer" , 1 )
            This.UpdateListBox( "element" )
            This.SetSelected( "element" , 1 )
        }
    }
    static OnChange_BitmapsListbox( listbox , * ){
        local keysList := "X|Y|W|H|Smoothing|InterpolationMode|Position|Scale|Name"
        Main.SelectedBitmap := listbox.Value
        Main.SelectedLayer := 1
        This.UpdateListBox( "Layer" )
        This.UpdateListBox( "Element" )
        if( WinExist( "ahk_Id " Main.WindowsList.BitmapPanelHwnd ) ){
            BitmapPanel.ActiveWindow.Bitmap := Main.GetBitmap()
            for k , v in StrSplit( keysList , "|" ){
                if( InStr( "XYWH" , v ) ){
                    BitmapPanel.ActiveWindow.Controls.%v%.Value := BitmapPanel.ActiveWindow.Bitmap.Rect.%v%
                }else if( v = "Position" ){
                    BitmapPanel.ActiveWindow.Controls.%v%.Value := Main.Controls.BitmapsListBox.Value
                }else{
                    BitmapPanel.ActiveWindow.Controls.%v%.Value := BitmapPanel.ActiveWindow.Bitmap.%v%
                }
            }
        }
    }
    static OnChange_LayersListbox( listbox , * ){
        local x := "" , y := ""
        Main.SelectedLayer := listbox.Value
        if( ( len := Main.GetLayer().Elements.Length ) && len < Main.SelectedElement )
            This.UpdateListBox( "Element" , Main.SelectedElement := len )
        else
            This.UpdateListBox( "Element" )
        Try{            
            If( WinExist( "ahk_id " LayerPanel.ActiveWindow.Window.Hwnd ) ){
                LayerPanel.ActiveWindow.Window.GetPos( &x , &y )
                LayerPanel.WinVector := Vector( x , y )
                This.ToggleLayerPanel( 333 )
                This.ToggleLayerPanel( 0 )
            }
        }
        Try{
            If( WinExist( "ahk_id " ElementPanel.ActiveWindow.Window.Hwnd ) ){
                if( Main.GetLayer().Elements.Length ){
                    ElementPanel.ActiveWindow.Window.GetPos( &x , &y )
                    ElementPanel.WinVector := Vector( x , y )
                    This.ToggleElementPanel( 333 )
                    This.ToggleElementPanel( 0 )                    
                }else{
                    ElementPanel.ActiveWindow.Window.GetPos( &x , &y )
                    ElementPanel.WinVector := Vector( x , y )
                    This.ToggleElementPanel( 0 )
                    ElementPanel.ActiveWindow.Window.Destroy()
                }   
            }
        }
        
    }
    static OnChange_ElementsListbox( listbox , * ){
        local x := "" , y := ""
        Main.SelectedElement := listbox.Value
        Try{            
            If( WinExist( "ahk_id " ElementPanel.ActiveWindow.Window.Hwnd ) ){
                ElementPanel.ActiveWindow.Window.GetPos( &x , &y )
                ElementPanel.WinVector := Vector( x , y )
                This.ToggleElementPanel( 333 )
                This.ToggleElementPanel( 0 )
            }
        }        
    }
    static OnChange_ElementTypesDDL( DDL , * ){
        Main.SelectedNewElementType := DDL.Text
    }
    static NotAssigned(*){
        TimedTips( "This button is not assigned to do anything yet" )
    }
    static SetSelected( type := "Bitmap" , value := 1 ){
        if( value )
            Try
                Main.Controls.%type%sListBox.Choose( value )
        Main.Selected%type% := value
    }
    static UpdateListBox( type := "Bitmap" , selected := 0 ){
        local outputList := []
        Main.Controls.%type%sListbox.Delete()
        if( type = "Bitmap" ){
            if( Main.Bitmaps.Length ){
                Loop Main.Bitmaps.Length   
                    outputList.Push( ( ( Main.Bitmaps[ A_Index ].IsHidden ) ? ( "[H] " ) : ( "" ) ) Main.Bitmaps[ A_Index ].Name )                
                Main.Controls.%type%sListBox.Add( outputList )
                if( selected )
                    This.SetSelected( "Bitmap" , Main.SelectedBitmap := selected )
                else
                    This.SetSelected( "Bitmap" , Main.SelectedBitmap )                
            }else{
                This.SetSelected( "Bitmap" , 0 )
            }
        }else if( type = "Layer" ){
            layers := Main.GetLayers()
            try{
                Loop layers.Length  {
                    outputList.Push( ( ( layers[ A_Index ].IsHidden ) ? ( "[H] " ) : ( "" ) ) layers[ A_Index ].Name )
                }
                Main.Controls.%type%sListBox.Add( outputList )            
                if( selected )
                    This.SetSelected( "Layer" , Main.SelectedLayer := selected )
                else
                    This.SetSelected( "Layer" , Main.SelectedLayer )
            }
        }else if( type = "Element" ){
            elements := Main.GetElements()
            try{
                Loop elements.Length  {
                    outputList.Push( ( ( elements[ A_Index ].IsHidden ) ? ( "[H] " ) : ( "" ) ) elements[ A_Index ].ElementType )
                }
                Main.Controls.%type%sListBox.Add( outputList )            
                if( selected )
                    This.SetSelected( "Element" , Main.SelectedElement := selected )
                else
                    This.SetSelected( "Element" , Main.SelectedElement )
            }
        }        
    }
}

class WheelEvents {

    static NewBitmapWindowWheelFunction( hwnd , wheelDirection ){
        local keysList := "X|Y|W|H|Smoothing|InterpolationMode"
        local value := 1
        if( GetKeyState( "Ctrl" ) )
            value := 100
        else if( GetKeyState( "Shift" ) )
            value := 10
        for k , v in StrSplit( keysList , "|" ) {
            if( NewBitmapPanel.ActiveWindow.Controls.%v%.Hwnd = hwnd ){
                if( InStr( "XYWH" , v ) ){
                    if( v = "W" || v = "H" ){
                        if( wheelDirection = 0 ){
                            ( ( NewBitmapPanel.ActiveWindow.Bitmap.Rect.%v% -= value ) >= 0 )  || NewBitmapPanel.ActiveWindow.Bitmap.Rect.%v% := 0
                            NewBitmapPanel.ActiveWindow.Controls.%v%.Value := NewBitmapPanel.ActiveWindow.Bitmap.Rect.%v%
                        }else{
                            NewBitmapPanel.ActiveWindow.Controls.%v%.Value := NewBitmapPanel.ActiveWindow.Bitmap.Rect.%v% += value
                        }
                    }else{
                        if( wheelDirection = 0 ){
                            NewBitmapPanel.ActiveWindow.Controls.%v%.Value := NewBitmapPanel.ActiveWindow.Bitmap.Rect.%v% -= value
                        }else{
                            NewBitmapPanel.ActiveWindow.Controls.%v%.Value := NewBitmapPanel.ActiveWindow.Bitmap.Rect.%v% += value
                        }
                    }
                }else if( v = "Smoothing" ){
                    if( wheelDirection = 0 ){
                        ( ( NewBitmapPanel.ActiveWindow.Bitmap.%v% -= 1 ) >= 0 )  || NewBitmapPanel.ActiveWindow.Bitmap.%v% := 0
                        NewBitmapPanel.ActiveWindow.Controls.%v%.Value := NewBitmapPanel.ActiveWindow.Bitmap.%v%
                    }else{
                        ( ( NewBitmapPanel.ActiveWindow.Bitmap.%v% += 1 ) <= 4 )  || NewBitmapPanel.ActiveWindow.Bitmap.%v% := 4
                        NewBitmapPanel.ActiveWindow.Controls.%v%.Value := NewBitmapPanel.ActiveWindow.Bitmap.%v%
                    }
                }else if( v = "InterpolationMode" ){
                    if( wheelDirection = 0 ){
                        ( ( NewBitmapPanel.ActiveWindow.Bitmap.%v% -= 1 ) >= 0 )  || NewBitmapPanel.ActiveWindow.Bitmap.%v% := 0
                        NewBitmapPanel.ActiveWindow.Controls.%v%.Value := NewBitmapPanel.ActiveWindow.Bitmap.%v%
                    }else{
                        ( ( NewBitmapPanel.ActiveWindow.Bitmap.%v% += 1 ) <= 7 )  || NewBitmapPanel.ActiveWindow.Bitmap.%v% := 7
                        NewBitmapPanel.ActiveWindow.Controls.%v%.Value := NewBitmapPanel.ActiveWindow.Bitmap.%v%
                    }
                }
            }
        }
    }
    static LoadWindowWheelFunction( hwnd , wheelDirection ){
        return 0
    }
    static SaveWindowWheelFunction( hwnd , wheelDirection ){
        return 0
    }
    static BitmapPanelWheelFunction( hwnd , wheelDirection ){
        local keysList := "X|Y|W|H|Smoothing|InterpolationMode|Position|Scale"
        local value := 1
        local update := 0
        if( GetKeyState( "Ctrl" ) )
            value := 100
        else if( GetKeyState( "Shift" ) )
            value := 10
        for k , v in StrSplit( keysList , "|" ) {
            if( BitmapPanel.ActiveWindow.Controls.%v%.Hwnd = hwnd ){
                if( InStr( "XYWH" , v ) ){
                    if( v = "W" || v = "H" ){
                        if( wheelDirection = 0 ){
                            ( ( BitmapPanel.ActiveWindow.Bitmap.Rect.%v% -= value ) >= 0 )  || BitmapPanel.ActiveWindow.Bitmap.Rect.%v% := 0
                            BitmapPanel.ActiveWindow.Controls.%v%.Value := BitmapPanel.ActiveWindow.Bitmap.Rect.%v%
                        }else{
                            BitmapPanel.ActiveWindow.Controls.%v%.Value := BitmapPanel.ActiveWindow.Bitmap.Rect.%v% += value
                        }
                    }else{
                        if( wheelDirection = 0 ){
                            BitmapPanel.ActiveWindow.Controls.%v%.Value := BitmapPanel.ActiveWindow.Bitmap.Rect.%v% -= value
                        }else{
                            BitmapPanel.ActiveWindow.Controls.%v%.Value := BitmapPanel.ActiveWindow.Bitmap.Rect.%v% += value
                        }
                    }
                    update := 1
                }else if( v = "Smoothing" ){
                    if( wheelDirection = 0 ){
                        ( ( BitmapPanel.ActiveWindow.Bitmap.%v% -= 1 ) >= 0 )  || BitmapPanel.ActiveWindow.Bitmap.%v% := 0
                        BitmapPanel.ActiveWindow.Controls.%v%.Value := BitmapPanel.ActiveWindow.Bitmap.%v%
                    }else{
                        ( ( BitmapPanel.ActiveWindow.Bitmap.%v% += 1 ) <= 4 )  || BitmapPanel.ActiveWindow.Bitmap.%v% := 4
                        BitmapPanel.ActiveWindow.Controls.%v%.Value := BitmapPanel.ActiveWindow.Bitmap.%v%
                    }
                }else if( v = "InterpolationMode" ){
                    if( wheelDirection = 0 ){
                        ( ( BitmapPanel.ActiveWindow.Bitmap.%v% -= 1 ) >= 0 )  || BitmapPanel.ActiveWindow.Bitmap.%v% := 0
                        BitmapPanel.ActiveWindow.Controls.%v%.Value := BitmapPanel.ActiveWindow.Bitmap.%v%
                    }else{
                        ( ( BitmapPanel.ActiveWindow.Bitmap.%v% += 1 ) <= 7 )  || BitmapPanel.ActiveWindow.Bitmap.%v% := 7
                        BitmapPanel.ActiveWindow.Controls.%v%.Value := BitmapPanel.ActiveWindow.Bitmap.%v%
                    }
                }else if( v = "position" ){
                    if( Main.Bitmaps.Length > 1 ){
                        if( wheelDirection = 0 ){
                            if( Main.SelectedBitmap != 1 ){
                                bitmap := Main.GetBitmap()
                                Main.TempBitmapWindow := PopupWindow_v4( { Options: "+AlwaysOnTop" , Rect: bitmap.Rect } )

                                temp := Main.Bitmaps[ Main.SelectedBitmap ].Clone()
                                Main.Bitmaps[ Main.SelectedBitmap ] := Main.Bitmaps[ Main.SelectedBitmap - 1 ].Clone()
                                Main.Bitmaps[ Main.SelectedBitmap - 1 ] := temp.Clone()
                                Main.SelectedBitmap -= 1
                                TempWindow := PopupWindow_v4({AutoShow: 0})
                                Loop( Main.Bitmaps.Length ){
                                    Main.Bitmaps[ A_Index ].Window.Hide()
                                    Main.Bitmaps[ A_Index ].Window.Window.Opt( "+parent" TempWindow.Hwnd )
                                    Main.Bitmaps[ A_Index ].Window.Window.Opt( "+parent" Main.DisplayWindow.Hwnd )
                                    Main.Bitmaps[ A_Index ].Window.Show()
                                }
                                TempWindow.Destroy()                                 
                            }
                        }else{
                            if( Main.SelectedBitmap != Main.Bitmaps.Length ){
                                bitmap := Main.GetBitmap()
                                Main.TempBitmapWindow := PopupWindow_v4( { Options: "+AlwaysOnTop" , Rect: bitmap.Rect } )

                                temp := Main.Bitmaps[ Main.SelectedBitmap ].Clone()
                                Main.Bitmaps[ Main.SelectedBitmap ] := Main.Bitmaps[ Main.SelectedBitmap + 1 ].Clone()
                                Main.Bitmaps[ Main.SelectedBitmap + 1 ] := temp.Clone()
                                Main.SelectedBitmap += 1
                                TempWindow := PopupWindow_v4({AutoShow: 0})
                                Loop( Main.Bitmaps.Length ){
                                    Main.Bitmaps[ A_Index ].Window.Hide()
                                    Main.Bitmaps[ A_Index ].Window.Window.Opt( "+parent" TempWindow.Hwnd )
                                    Main.Bitmaps[ A_Index ].Window.Window.Opt( "+parent" Main.DisplayWindow.Hwnd )
                                    Main.Bitmaps[ A_Index ].Window.Show()
                                }
                                TempWindow.Destroy() 
                            }                            
                        }
                        TimedTips( "pos" )
                        Main.UpdateListBox( "Bitmap" , Main.SelectedBitmap )
                        Main.TempBitmapWindow.Destroy()
                        Main.TempBitmapWindow := ""
                        BitmapPanel.ActiveWindow.Controls.Position.Value := Main.SelectedBitmap
                    }
                }else if( v = "Scale" ){
                    if( wheelDirection = 0 ){
                        if( BitmapPanel.ActiveWindow.Bitmap.Scale > 0.2 ){
                            BitmapPanel.ActiveWindow.Bitmap.Scale -= 0.1
                            update := 1
                        }
                    }else{
                        BitmapPanel.ActiveWindow.Bitmap.Scale += 0.1
                        update := 1
                    }
                    BitmapPanel.ActiveWindow.Controls.Scale.Value := BitmapPanel.ActiveWindow.Bitmap.Scale
                }
            }
        }
        if( update = 1 ){
            bitmap := Main.GetBitmap()
            cc := BitmapPanel.ActiveWindow.Bitmap.Rect
            Loop( bitmap.Layers.Length ){
                bitmap.Layers[ A_Index ].Scale := bitmap.Scale 
                bitmap.Layers[ A_Index ].DrawLayer()
            }
            bitmap.UpdateSize( cc.x , cc.y , Floor( cc.w ) , Floor( cc.h ) )
        }
    }
    static LayerPanelWheelFunction( hwnd , wheelDirection ){
        local layerKeyList := "Position|Name|X|Y|W|H|Smoothing|InterpolationMode|IsHidden|Note"
        local layer := Main.GetLayer()
        local value := 1
        local update := 0
        if( GetKeyState( "Ctrl" ) )
            value := 100
        else if( GetKeyState( "Shift" ) )
            value := 10
        for k , v in StrSplit( layerKeyList , "|" ) {     
            if( LayerPanel.ActiveWindow.Controls.%v%.Hwnd = hwnd ){  
                if( InStr( "XYWH" , v ) ){
                    if( v = "W" || v = "H" ){                        
                        if( wheelDirection = 0 ){
                            ( ( LayerPanel.ActiveWindow.Layer.Rect.%v% -= value ) >= 0 )  || LayerPanel.ActiveWindow.Layer.Rect.%v% := 0
                            LayerPanel.ActiveWindow.Controls.%v%.Value := LayerPanel.ActiveWindow.Layer.Rect.%v%
                        }else{
                            LayerPanel.ActiveWindow.Controls.%v%.Value := LayerPanel.ActiveWindow.Layer.Rect.%v% += value
                        }
                    }else{
                        if( wheelDirection = 0 ){
                            LayerPanel.ActiveWindow.Controls.%v%.Value := LayerPanel.ActiveWindow.Layer.Rect.%v% -= value
                        }else{
                            LayerPanel.ActiveWindow.Controls.%v%.Value := LayerPanel.ActiveWindow.Layer.Rect.%v% += value
                        }
                    }
                    update := 1
                    break
                }else if( v = "Smoothing" ){
                    if( wheelDirection = 0 ){
                        ( ( LayerPanel.ActiveWindow.Layer.%v% -= 1 ) >= 0 )  || LayerPanel.ActiveWindow.Layer.%v% := 0
                        LayerPanel.ActiveWindow.Controls.%v%.Value := LayerPanel.ActiveWindow.Layer.%v%
                    }else{
                        ( ( LayerPanel.ActiveWindow.Layer.%v% += 1 ) <= 4 )  || LayerPanel.ActiveWindow.Layer.%v% := 4
                        LayerPanel.ActiveWindow.Controls.%v%.Value := LayerPanel.ActiveWindow.Layer.%v%
                    }
                    Main.GetLayer().DrawLayer()
                    break
                }else if( v = "InterpolationMode" ){
                    if( wheelDirection = 0 ){
                        ( ( LayerPanel.ActiveWindow.Layer.%v% -= 1 ) >= 0 )  || LayerPanel.ActiveWindow.Layer.%v% := 0
                        LayerPanel.ActiveWindow.Controls.%v%.Value := LayerPanel.ActiveWindow.Layer.%v%
                    }else{
                        ( ( LayerPanel.ActiveWindow.Layer.%v% += 1 ) <= 7 )  || LayerPanel.ActiveWindow.Layer.%v% := 7
                        LayerPanel.ActiveWindow.Controls.%v%.Value := LayerPanel.ActiveWindow.Layer.%v%
                    }
                    Main.GetLayer().DrawLayer()
                    break
                }else if( v = "position" ){                    
                    layers := Main.GetLayers()
                    if( layers.Length > 1 ){
                        if( wheelDirection = 0 ){
                            if( Main.SelectedLayer != 1 ){
                                layer := Main.GetLayer()
                                Main.TempLayerWindow := PopupWindow_v4( { Options: "+AlwaysOnTop" , Rect: layer.Rect } )
                                temp := layers[ Main.Selectedlayer ].Clone()
                                layers[ Main.SelectedLayer ] := layers[ Main.SelectedLayer - 1 ].Clone()
                                layers[ Main.SelectedLayer - 1 ] := temp.Clone()
                                Main.SelectedLayer -= 1  
                                TempWindow := PopupWindow_v4({AutoShow: 0})
                                Loop( Layers.Length ){
                                    layers[ A_Index ].Window.Hide()
                                    layers[ A_Index ].Window.Window.Opt( "+parent" TempWindow.Hwnd )
                                    layers[ A_Index ].Window.Window.Opt( "+parent" Main.GetBitmap().Window.Hwnd )
                                    layers[ A_Index ].Window.Show()
                                }
                                TempWindow.Destroy()                              
                            }
                        }else{
                            if( Main.SelectedLayer != layers.Length ){
                                layer := Main.GetLayer()
                                Main.TempLayerWindow := PopupWindow_v4( { Options: "+AlwaysOnTop" , Rect: layer.Rect } )
                                temp := Layers[ Main.SelectedLayer ].Clone()
                                Layers[ Main.SelectedLayer ] := Layers[ Main.SelectedLayer + 1 ].Clone()
                                Layers[ Main.SelectedLayer + 1 ] := temp.Clone()
                                Main.SelectedLayer += 1    
                                TempWindow := PopupWindow_v4({AutoShow: 0})
                                Loop( Layers.Length ){
                                    layers[ A_Index ].Window.Hide()
                                    layers[ A_Index ].Window.Window.Opt( "+parent" TempWindow.Hwnd )
                                    layers[ A_Index ].Window.Window.Opt( "+parent" Main.GetBitmap().Window.Hwnd )
                                    layers[ A_Index ].Window.Show()
                                }
                                TempWindow.Destroy()                            
                            }                            
                        }
                        TimedTips( "pos" )
                        Main.UpdateListBox( "Layer" , Main.SelectedLayer )
                        Main.TempLayerWindow.Destroy()
                        Main.TempLayerWindow := ""
                        LayerPanel.ActiveWindow.Controls.Position.Value := Main.SelectedLayer
                    }
                    break
                }else if( v = "Scale" ){
                    if( wheelDirection = 0 ){
                        if( LayerPanel.ActiveWindow.Layer.Scale > 0.2 ){
                            LayerPanel.ActiveWindow.Layer.Scale -= 0.1
                            update := 1
                        }
                    }else{
                        LayerPanel.ActiveWindow.Layer.Scale += 0.1
                        update := 1
                    }
                    LayerPanel.ActiveWindow.Controls.Scale.Value := LayerPanel.ActiveWindow.Layer.Scale
                    break
                }
            }
        }
        if( update = 1 ){
            layer := Main.GetLayer()
            cc := LayerPanel.ActiveWindow.Layer.Rect
            layer.UpdateSize( cc.x , cc.y , cc.w , cc.h )
        }
    }    
    static ElementPanelWheelFunction( hwnd , wheelDirection ){
        local ElementKeyList := "BrushX|FontSize|Thickness|Offset|HatchValue|BrushY|BrushW|BrushH|X|Y|W|H|GradientBrushLinearMode|GradientBrushWrapMode|Position|Roundness|ColorSwatch1|ColorSwatch2"
        local element := Main.GetElement()
        local value := 1
        local update := 0
        local controls := ElementPanel.ActiveWindow.Controls
        if( GetKeyState( "Ctrl" ) )
            value := 100
        else if( GetKeyState( "Shift" ) )
            value := 10        
        for k , v in StrSplit( ElementKeyList , "|" ) { 
            Try{
                if( controls.%v%.Hwnd = hwnd  ){
                    if( InStr( "XYWH" , v ) ){
                        if( v = "W" || v = "H" ){                        
                            if( wheelDirection = 0 ){
                                ( ( ElementPanel.ActiveWindow.element.Rect.%v% -= value ) >= 0 )  || ElementPanel.ActiveWindow.element.Rect.%v% := 0
                                ElementPanel.ActiveWindow.Controls.%v%.Value := ElementPanel.ActiveWindow.element.Rect.%v%
                            }else{
                                ElementPanel.ActiveWindow.Controls.%v%.Value := ElementPanel.ActiveWindow.element.Rect.%v% += value
                            }
                        }else{
                            if( wheelDirection = 0 ){
                                ElementPanel.ActiveWindow.Controls.%v%.Value := ElementPanel.ActiveWindow.element.Rect.%v% -= value
                            }else{
                                ElementPanel.ActiveWindow.Controls.%v%.Value := ElementPanel.ActiveWindow.element.Rect.%v% += value
                            }
                        }
                        update := 1
                        break

                    }else if( v = "ColorSwatch1" ){
                        if( wheelDirection = 1 )
                            ( ( ++ElementPanel.ActiveWindow.Color1Index ) < 17 ) || ElementPanel.ActiveWindow.Color1Index := 1
                        else 
                            ( ( --ElementPanel.ActiveWindow.Color1Index ) > 0 ) || ElementPanel.ActiveWindow.Color1Index := 16
                        color1 := SubStr( PopupWindow_v4.Colors[ ElementPanel.ActiveWindow.Color1Index ] , 5 )
                        alpha1 := ElementPanel.ActiveWindow.Controls.Alpha1.Value                    
                        ElementPanel.ActiveWindow.element.BrushObject.Color1 := "0x" alpha1 . color1                        
                        ElementPanel.ActiveWindow.Controls.ColorSwatch1.Opt( "c" color1 )
                        ElementPanel.ActiveWindow.Controls.Color1.value := color1
                        update := 1
                        break
                    }else if( v = "ColorSwatch2" ){
                        if( wheelDirection = 1 )
                            ( ( ++ElementPanel.ActiveWindow.Color2Index ) < 17 ) || ElementPanel.ActiveWindow.Color2Index := 1
                        else 
                            ( ( --ElementPanel.ActiveWindow.Color2Index ) > 0 ) || ElementPanel.ActiveWindow.Color2Index := 16
                        color2 := SubStr( PopupWindow_v4.Colors[ ElementPanel.ActiveWindow.Color2Index ] , 5 )
                        alpha2 := ElementPanel.ActiveWindow.Controls.Alpha2.Value                    
                        ElementPanel.ActiveWindow.element.BrushObject.Color2 := "0x" alpha2 . color2                        
                        ElementPanel.ActiveWindow.Controls.ColorSwatch2.Opt( "c" color2 )
                        ElementPanel.ActiveWindow.Controls.Color2.value := color2
                        update := 1
                        break
                    }else if( v = "Roundness" ){
                        if( wheelDirection = 1 ){
                            ElementPanel.ActiveWindow.element.Roundness += value
                            ElementPanel.ActiveWindow.Controls.Roundness.value := ElementPanel.ActiveWindow.element.Roundness
                        }else{
                            ( ( ElementPanel.ActiveWindow.element.Roundness -= value ) >= 0 ) || ElementPanel.ActiveWindow.element.Roundness := 0
                            ElementPanel.ActiveWindow.Controls.Roundness.value := ElementPanel.ActiveWindow.element.Roundness
                        }
                        update := 1
                        break
                    }else if( v = "Position" ){
                        elements := Main.GetElements()
                        if( elements.Length > 1 ){
                            if( wheelDirection = 0 ){
                                if( Main.SelectedElement != 1 ){
                                    element := Main.GetElement()
                                    temp := elements[ Main.SelectedElement ].Clone()
                                    elements[ Main.SelectedElement ] := elements[ Main.SelectedElement - 1 ].Clone()
                                    elements[ Main.SelectedElement - 1 ] := temp.Clone()
                                    Main.SelectedElement -= 1                           
                                }
                            }else{
                                if( Main.SelectedElement != elements.Length ){
                                    element := Main.GetElement()
                                    temp := elements[ Main.SelectedElement ].Clone()
                                    elements[ Main.SelectedElement ] := elements[ Main.SelectedElement + 1 ].Clone()
                                    elements[ Main.SelectedElement + 1 ] := temp.Clone()
                                    Main.SelectedElement += 1                                                              
                                }                            
                            }
                            Main.UpdateListBox( "Element" , Main.SelectedElement )
                            ElementPanel.ActiveWindow.Controls.Position.Value := Main.SelectedElement
                            update := 1
                        }
                        break
                    }else if( InStr( v , "Brush" ) ){
                        switch v , "Off" {
                            case "BrushX":
                                if( wheelDirection = 0 ){
                                    ElementPanel.ActiveWindow.element.BrushObject.Rect.X -= value
                                }else{
                                    ElementPanel.ActiveWindow.element.BrushObject.Rect.X += value
                                }
                                ElementPanel.ActiveWindow.Controls.BrushX.value := ElementPanel.ActiveWindow.element.BrushObject.Rect.X
                                update := 1                              
                            case "BrushY":
                                if( wheelDirection = 0 ){
                                    ElementPanel.ActiveWindow.element.BrushObject.Rect.Y -= value
                                }else{
                                    ElementPanel.ActiveWindow.element.BrushObject.Rect.Y += value
                                }
                                ElementPanel.ActiveWindow.Controls.BrushY.value := ElementPanel.ActiveWindow.element.BrushObject.Rect.Y
                                Main.GetLayer().DrawLayer()
                            case "BrushW":
                                if( wheelDirection = 0 ){
                                    ( ( ElementPanel.ActiveWindow.element.BrushObject.Rect.W -= value ) >= 0 ) || ElementPanel.ActiveWindow.element.BrushObject.Rect.W := 0
                                }else{
                                    ElementPanel.ActiveWindow.element.BrushObject.Rect.W += value
                                }
                                ElementPanel.ActiveWindow.Controls.BrushW.value := ElementPanel.ActiveWindow.element.BrushObject.Rect.W
                                update := 1
                            case "BrushH":
                                if( wheelDirection = 0 ){
                                    ( ( ElementPanel.ActiveWindow.element.BrushObject.Rect.H -= value ) >= 0 ) || ElementPanel.ActiveWindow.element.BrushObject.Rect.H := 0
                                }else{
                                    ElementPanel.ActiveWindow.element.BrushObject.Rect.H += value
                                }
                                ElementPanel.ActiveWindow.Controls.BrushH.value := ElementPanel.ActiveWindow.element.BrushObject.Rect.H
                                update := 1
                            case "GradientBrushLinearMode":
                                if( wheelDirection = 0 ){
                                    ( ( --element.BrushObject.LinearGradientMode ) >= 0 ) || element.BrushObject.LinearGradientMode := 0
                                }else{
                                    ( ( ++element.BrushObject.LinearGradientMode ) < 4 ) || element.BrushObject.LinearGradientMode := 3                                    
                                }                
                                ElementPanel.ActiveWindow.Controls.GradientBrushLinearMode.value := element.BrushObject.LinearGradientMode
                                update := 1
                            case "GradientBrushWrapMode":
                                if( wheelDirection = 0 ){
                                    ( ( --element.BrushObject.GradientBrushWrapMode ) >= 0 ) || element.BrushObject.GradientBrushWrapMode := 0                                    
                                }else{
                                    ( ( ++element.BrushObject.GradientBrushWrapMode ) < 4 ) || element.BrushObject.GradientBrushWrapMode := 3
                                }                                 
                                ElementPanel.ActiveWindow.Controls.GradientBrushWrapMode.value := element.BrushObject.GradientBrushWrapMode
                                update := 1
                        }                        
                    }else if( v = "FontSize" ){
                        if( wheelDirection = 1 ){
                            ElementPanel.ActiveWindow.element.FontSize += value
                            ElementPanel.ActiveWindow.Controls.FontSize.value := ElementPanel.ActiveWindow.element.FontSize
                        }else{
                            ( ( ElementPanel.ActiveWindow.element.FontSize -= value ) >= 1 ) || ElementPanel.ActiveWindow.element.FontSize := 1
                            ElementPanel.ActiveWindow.Controls.FontSize.value := ElementPanel.ActiveWindow.element.FontSize
                        }
                        update := 1
                        break
                    }else if( v = "Offset" ){
                        if( wheelDirection = 1 ){
                            ElementPanel.ActiveWindow.element.Offset += value
                            ElementPanel.ActiveWindow.Controls.Offset.value := ElementPanel.ActiveWindow.element.Offset
                        }else{
                            ElementPanel.ActiveWindow.element.Offset -= value
                            ElementPanel.ActiveWindow.Controls.Offset.value := ElementPanel.ActiveWindow.element.Offset
                        }
                        update := 1
                        break
                    }else if( v = "HatchValue" ){                        
                        if( wheelDirection = 1 ){
                            TimedTips( "Hatch value DOWN`n" ElementPanel.ActiveWindow.element.BrushObject.HatchValue )
                            ElementPanel.ActiveWindow.element.BrushObject.HatchValue += value
                            ( ElementPanel.ActiveWindow.element.BrushObject.HatchValue <= 52 ) || ElementPanel.ActiveWindow.element.BrushObject.HatchValue := 52
                            ElementPanel.ActiveWindow.Controls.HatchValue.value := ElementPanel.ActiveWindow.element.BrushObject.HatchValue
                        }else{
                            ElementPanel.ActiveWindow.element.BrushObject.HatchValue -= value
                            ( ElementPanel.ActiveWindow.element.BrushObject.HatchValue >= 0 ) || ElementPanel.ActiveWindow.element.BrushObject.HatchValue := 0
                            ElementPanel.ActiveWindow.Controls.HatchValue.value := ElementPanel.ActiveWindow.element.BrushObject.HatchValue
                        }
                        update := 1
                        break
                    }else if( v = "Thickness" ){
                        if( wheelDirection = 1 ){
                            ElementPanel.ActiveWindow.element.Thickness += value
                            ElementPanel.ActiveWindow.Controls.Thickness.value := ElementPanel.ActiveWindow.element.Thickness
                        }else{
                            ( ( ElementPanel.ActiveWindow.element.Thickness -= value ) > 0 ) || ElementPanel.ActiveWindow.element.Thickness := 1
                            ElementPanel.ActiveWindow.Controls.Thickness.value := ElementPanel.ActiveWindow.element.Thickness
                        }
                        update := 1
                        break
                    }
                }
            }
        }        
        if( update = 1 )
            Main.GetLayer().DrawLayer()
        return
    }
}

class DetachWindowClass {

    static Setup(){        
        OnMessage( 0x201 , This._OnClick.Bind( This ) )
    }
    static _OnClick( wParam , lParam , uMsg , hWnd ){        
        Loop( Main.Bitmaps.Length ){
            cc := Main.Bitmaps[ A_Index ]
            if( hwnd = cc.Layers[ cc.Layers.Length ].Window.Hwnd ){
                if( GetKeyState( "Shift" ) ){
                    cc.Window.Window.Opt( "-Parent" )
                    cc.IsAttached := 0
                }
                PostMessage( 0xA1 , 2 ,,, "ahk_id " cc.Window.Hwnd )
                if( !cc.IsAttached ){
                    mv := Vector.MouseVector()
                    cc.Window.Resize( 1 , mv )
                }
                While( GetKeyState( "LButton" ) )
                    Sleep( 30 )
                DetectHiddenWindows( "On" )
                WinGetPos( &mwX , &mwY , &mwW , &mwH , "ahk_id " Main.MainWindow.Hwnd )
                mv := Vector.MouseVector()
                if( !cc.IsAttached && mv.InRect( { X: mwX , Y: mwY , W: mwW , H: mwH } ) ){
                    cc.Window.Window.Opt( "+Parent" Main.DisplayWindow.Hwnd )
                    cc.IsAttached := 1
                    cc.UpdateSize( 0 , 0 , Floor( cc.Rect.w ) , Floor( cc.Rect.h ) )
                    loop( cc.Layers.Length )
                        cc.Layers[ A_Index ].DrawLayer()  
                    Try{
                        if( IsObject( ElementPanel.ActiveWindow ) && IsObject( ElementPanel.ActiveWindow.Window ) )
                            Main.ToggleElementPanel( 444 )     
                    }             
                    return
                }else{
                    WinGetPos( &x , &y ,,, "ahk_id " cc.Window.Hwnd )
                    cc.Window.Resize( 1 , x , y )
                    cc.Rect.X := x 
                    cc.Rect.Y := y
                    Try{
                        if( IsObject( BitmapPanel.ActiveWindow ) && IsObject( BitmapPanel.ActiveWindow.Window ) )
                            Main.ToggleBitmapPanel( 444 )
                    }
                    return
                }
            }
        }
        return 
    }
}

class BitmapsClass {

    __New( bitmapObject ){
        local bitmapPropList := "Name|Rect|Smoothing|InterpolationMode"
        local Settings := {}
        Settings.Options := "+AlwaysOnTop +Parent" Main.DisplayWindow.Hwnd
        Settings.Rect := bitmapObject.Rect.clone()
        This.Window := PopupWindow_v4( Settings )
        This.Window.Clear( 1 , "0x01000000" )
        for k , v in StrSplit( bitmapPropList , "|" ) {
            if( IsObject( bitmapObject.%v% ) )
                This.%v% := bitmapObject.%v%.Clone()
            else
                This.%v% := bitmapObject.%v%
        }
        This.IsHidden := 0
        This.Note := ""
        This.Scale := 1
        This.Layers := []
        This.IsAttached := 1
        This.AddLayer()
    }
    AddLayer(){
        local TempWindow := PopupWindow_v4({AutoShow: 0})
        This.Layers.Push( LayersClass( This ) )
        Loop( This.Layers.Length ){
            This.layers[ A_Index ].Window.Hide()
            This.layers[ A_Index ].Window.Window.Opt( "+parent" TempWindow.Hwnd )
            This.layers[ A_Index ].Window.Window.Opt( "+parent" This.Window.Hwnd )
            This.layers[ A_Index ].Window.Show()
        }
        TempWindow.Destroy()
    }
    UpdateSize( x , y , w , h ){
        This.Window.Resize( 1 , x , y , Round( w * This.Scale ) , Round( h * This.Scale ) )
        This.Window.Clear( 1 , "0x01000000" )
        loop This.Layers.Length {
            This.Layers[ A_Index ].UpdateSize( This.Layers[ A_Index ].Rect.X * This.Scale , This.Layers[ A_Index ].Rect.Y * This.Scale , Round( w * This.Scale ) , Round( h * This.Scale ) )
        }
    }
    DeleteBitmap(){
        Loop( This.Layers.Length ){
            This.Layers[ A_Index ].RemoveLayer()
            This.Layers[ A_Index ] := ""
        }
        This.Window.Destroy()
        This := ""
    }
    CycleLayerOrder(){
        TempWindow := PopupWindow_v4({AutoShow: 0})
        Loop( This.Layers.Length ){
            This.layers[ A_Index ].Window.Hide()
            This.layers[ A_Index ].Window.Window.Opt( "+parent" TempWindow.Hwnd )
            This.layers[ A_Index ].Window.Window.Opt( "+parent" Main.GetBitmap().Window.Hwnd )
            This.layers[ A_Index ].Window.Show()
        }
        TempWindow.Destroy() 
    }
}

class LayersClass {
    static SelectedLayer := 0
    static SetDefaults(){
        local cc := This.Defaults := {}
        cc.Parent := ""
    }
    __New( parentObj ){
        local Settings := {}
        Settings.Options := "+AlwaysOnTop +Parent" parentObj.Window.Hwnd
        Settings.Rect := parentObj.Rect.Clone()
        Settings.Rect.X := Settings.Rect.Y := 0
        This.Window := PopupWindow_v4( Settings )
        This.Name := "Layer " parentObj.Layers.Length + 1 
        This.Rect := parentObj.Rect.Clone()
        This.Rect.X := This.Rect.Y := 0
        This.Smoothing := parentObj.Smoothing
        This.InterpolationMode := parentObj.InterpolationMode
        This.IsHidden := 0
        This.Note := ""
        This.Scale := parentObj.Scale
        This.ParentObject := parentObj
        This.TempColor := Random( 1 , 16 )
        This.Elements := []        
        This.DrawLayer()
    }
    RemoveLayer(){
        This.Window.Destroy()
    }
    CopyLayer(){

    }
    MergeLayer(){

    }
    DrawLayer(){
        local G := This.Window.G
        This.Window.Clear()
        tBrush := Gdip_BrushCreateSolid( "0x01000000" )
        Gdip_FillRectangle( This.Window.G , tBrush , 0 , 0 , This.ParentObject.Window.W * This.ParentObject.Scale , This.ParentObject.Window.H * This.ParentObject.Scale )
        Gdip_DeleteBrush( tBrush )
        Gdip_SetSmoothingMode( G , This.Smoothing )
        if( !This.IsHidden ){
            if( This.Elements.Length ){
                Loop( This.Elements.Length ){
                    DrawClass.DrawElement( G , This.Elements[ A_Index ] , This.Scale )
                }
            }
        }
        This.Window.Update()
    }
    UpdateSize( x := 0 , y := 0 , w := 10 , h := 10 ){
        This.Window.Resize( 1 , x , y , w , h )
        This.DrawLayer()
    }
    AddElement( obj := "" ){
        local elementType := Main.SelectedNewElementType
        local element := ""
        if( IsObject( obj ) ){
            elementType := obj.ElementType
            This.Elements.Push( ElementsClass.NewElement( elementType ) )
            This.Elements[ This.Elements.Length ] := obj.Clone()
        }else{
            This.Elements.Push( ElementsClass.NewElement( elementType ) )
        }
        Main.SelectedElement := This.Elements.Length
        element := This.Elements[ This.Elements.Length ]
        if( element.HasProp( "BrushObject" ) && !IsObject( obj ) ){
            element.BrushObject := BrushesAndPensClass.NewBrush( "SolidBrush" )
        }
        This.DrawLayer()
    }
    RemoveElement(){
        if( This.Elements.Length ){
            This.Elements.RemoveAt( Main.SelectedElement )
            if( This.Elements.Length ){
                if( This.Elements.Length < Main.SelectedElement )
                    Main.SelectedElement := This.Elements.Length
            }else{
                Main.SelectedElement := 0
            }
            This.DrawLayer()
            Main.UpdateListBox( "Element" )
            if( Main.SelectedElement )
                Main.SetSelected( "Element" , Main.SelectedElement )
            if( ElementPanel.ActiveWindow.HasProp( "Window" ) && WinExist( "ahk_id " ElementPanel.ActiveWindow.Window.Hwnd ) ){
                if( Main.SelectedElement )
                    Main.ToggleElementPanel( 444 )
                else{
                    Try{
                        Main.ToggleElementPanel( 333 )
                        ElementPanel.ActiveWindow.Window.Destroy()
                        ElementPanel.ActiveWindow := ""
                    }
                }
            }
        }
    }
    CopyElement(){
        element := Main.GetElement()
        tempElementObject := {}
        for k , v in element.OwnProps() {
            if( IsObject( element.%k% ) ){
                tempElementObject.%k% := {}
                for i , j in element.%k%.OwnProps() {
                    
                    if( IsObject( element.%k%.%i% ) ){
                        tempElementObject.%k%.%i% := element.%k%.%i%.Clone()
                    }else{
                        tempElementObject.%k%.%i% := element.%k%.%i%
                    }                        
                }
            }else{
                tempElementObject.%k% := element.%k%
            }
        }
        This.Elements.Push( tempElementObject )
    }
}

class ElementsClass {
    static SelectedElement := 0
    static FillRectangleKeys := "Rect|Roundness|Note|BrushObject|IsHidden"
    static DrawTextKeys := "Rect|Text|FontSize|Italic|FontType|Right|NoWrap|Strike|Bold|Underline|DebugMode|Center|vCenter|Offset|Note|BrushObject|IsHidden"
    static DrawImageKeys := "Rect|SourceRect|Path|ImageBitmap|Note|IsHidden"
    static DrawRectangleKeys := "Rect|Roundness|Thickness|BrushObject|Note|IsHidden"
    static FillEllipseKeys := "Rect|BrushObject|Note|IsHidden"
    static init := This.SetDefaults()
    static SetDefaults(){
        local cc := This.Defaults := {}
        cc.ElementType := "FillRectangle"
        cc.Rect := Vector.Rect( 0 , 0 , 100 , 100 )
        cc.SourceRect := Vector.Rect( 0 , 0 , 100 , 100 )
        cc.Roundness := 0
        cc.Note := ""
        cc.IsHidden := 0
        cc.BrushObject := {}
        cc.Center := 1
        cc.vCenter := 1
        cc.NoWrap := 0
        cc.Right := 0
        cc.Bold := 1
        cc.Underline := 0
        cc.Strike := 0
        cc.Italic := 0
        cc.Text := "Sample"
        cc.FontType := "Segoe UI"
        cc.FontSize := 10
        cc.DebugMode := 0
        cc.Offset := 0
        cc.Path := ""
        cc.ImageBitmap := ""
        cc.Thickness := 3
    }
    static FillRectanglePrototype( obj := "" ){
        local outputObject := {}
        outputObject.ElementType := "FillRectangle"
        for k , v in StrSplit( This.FillRectangleKeys , "|" ){
            if( IsObject( This.Defaults.%v% ) )
                outputObject.%v% := This.Defaults.%v%.Clone()
            else
                outputObject.%v% := This.Defaults.%v%
        }
        return outputObject
    }
    static DrawTextPrototype( obj := "" ){
        local outputObject := {}
        outputObject.ElementType := "DrawText"
        for k , v in StrSplit( This.DrawTextKeys , "|" ){
            if( IsObject( This.Defaults.%v% ) )
                outputObject.%v% := This.Defaults.%v%.Clone()
            else
                outputObject.%v% := This.Defaults.%v%
        }
        return outputObject
    }
    static DrawImagePrototype( obj := "" ){
        local outputObject := {}
        outputObject.ElementType := "DrawImage"
        for k , v in StrSplit( This.DrawImageKeys , "|" ){
            if( IsObject( This.Defaults.%v% ) )
                outputObject.%v% := This.Defaults.%v%.Clone()
            else
                outputObject.%v% := This.Defaults.%v%
        }
        return outputObject
    }
    static DrawRectanglePrototype( obj := "" ){
        local outputObject := {}
        outputObject.ElementType := "DrawRectangle"
        for k , v in StrSplit( This.DrawRectangleKeys , "|" ){
            if( IsObject( This.Defaults.%v% ) )
                outputObject.%v% := This.Defaults.%v%.Clone()
            else
                outputObject.%v% := This.Defaults.%v%
        }
        return outputObject
    }
    static FillEllipsePrototype( obj := "" ){
        local outputObject := {}
        outputObject.ElementType := "FillEllipse"
        for k , v in StrSplit( This.FillEllipseKeys , "|" ){
            if( IsObject( This.Defaults.%v% ) )
                outputObject.%v% := This.Defaults.%v%.Clone()
            else
                outputObject.%v% := This.Defaults.%v%
        }
        return outputObject
    }
    static NewElement( elementType := "FillRectangle" , BrushType := "SolidBrush" , obj := "" ){
        return ElementsClass.%elementType%Prototype( obj )
    }
    
}

class BrushesAndPensClass {
    static init := This.Setup()
    static SolidBrushKeys := "Color1"
    static HatchBrushKeys := "Color1|Color2|HatchValue"
    static TextureBrushKeys := ""
    static GradientBrushKeys := "Color1|Color2|Rect|LinearGradientMode|GradientBrushWrapMode"
    static LineBrushKeys := "Color1|Color2|Rect|LineBrushWrapMode"

    static Setup(){
        local cc := This.Defaults := {}
        cc.BrushType := "SolidBrush"
        cc.Color1 := "0xFF336699"
        cc.Color2 := "0xFF000000"
        cc.Rect := Vector.Rect( 0 , 0 , 100 , 100 )
        cc.LinearGradientMode := 1
        cc.GradientBrushWrapMode := 1
        cc.LineBrushWrapMode := 1
        cc.HatchValue := 1
    }
    static SolidBrushPrototype( obj := "" ){
        local outputObject := {}
        outputObject.BrushType := "SolidBrush"
        if( IsObject( obj ) && obj.HasProp( "Color1" ) )
            outputObject.Color1 := obj.Color1
        else
            outputObject.Color1 := This.Defaults.Color1
        return outputObject
    }
    static HatchBrushPrototype( obj := "" ){
        local outputObject := {}
        outputObject.BrushType := "HatchBrush"
        if( IsObject( obj ) ){
            if( obj.HasProp( "Color1" ) )
                outputObject.Color1 := obj.Color1
            else 
                outputObject.Color1 := This.Defaults.Color1
            if( obj.HasProp( "Color2" ) )
                outputObject.Color2 := obj.Color2
            else 
                outputObject.Color2 := This.Defaults.Color2
            if( obj.HasProp( "HatchValue" ) )
                outputObject.HatchValue := obj.HatchValue
            else 
                outputObject.HatchValue := This.Defaults.HatchValue
        }else{
            outputObject.Color1 := This.Defaults.Color1
            outputObject.Color2 := This.Defaults.Color2
            outputObject.HatchValue := This.Defaults.HatchValue
        }
        return outputObject
    }
    static GradientBrushPrototype( obj := "" ){
        local outputObject := {}
        outputObject.BrushType := "GradientBrush"
        if( IsObject( obj ) ){
            if( obj.HasProp( "Color1" ) )
                outputObject.Color1 := obj.Color1
            else 
                outputObject.Color1 := This.Defaults.Color1
            if( obj.HasProp( "Color2" ) )
                outputObject.Color2 := obj.Color2
            else 
                outputObject.Color2 := This.Defaults.Color2
            if( obj.HasProp( "LinearGradientMode" ) )
                outputObject.LinearGradientMode := obj.LinearGradientMode
            else 
                outputObject.LinearGradientMode := This.Defaults.LinearGradientMode
            if( obj.HasProp( "GradientBrushWrapMode" ) )
                outputObject.GradientBrushWrapMode := obj.GradientBrushWrapMode
            else 
                outputObject.GradientBrushWrapMode := This.Defaults.GradientBrushWrapMode
            if( obj.HasProp( "Rect" ) )
                outputObject.Rect := obj.Rect.Clone()
            else 
                outputObject.Rect := This.Defaults.Rect.Clone()
        }else{
            outputObject.Color1 := This.Defaults.Color1
            outputObject.Color2 := This.Defaults.Color2
            outputObject.LinearGradientMode := This.Defaults.LinearGradientMode
            outputObject.GradientBrushWrapMode := This.Defaults.GradientBrushWrapMode
            outputObject.Rect := This.Defaults.Rect.Clone()
        }
        return outputObject
    }
    static LineBrushPrototype( obj := "" ){
        local outputObject := {}
        outputObject.BrushType := "LineBrush"
        if( IsObject( obj ) ){
            if( obj.HasProp( "Color1" ) )
                outputObject.Color1 := obj.Color1
            else 
                outputObject.Color1 := This.Defaults.Color1
            if( obj.HasProp( "Color2" ) )
                outputObject.Color2 := obj.Color2
            else 
                outputObject.Color2 := This.Defaults.Color2
            if( obj.HasProp( "LineBrushWrapMode" ) )
                outputObject.LineBrushWrapMode := obj.LineBrushWrapMode
            else 
                outputObject.LineBrushWrapMode := This.Defaults.LineBrushWrapMode
            if( obj.HasProp( "Rect" ) )
                outputObject.Rect := obj.Rect.Clone()
            else 
                outputObject.Rect := This.Defaults.Rect.Clone()
        }else{
            outputObject.Color1 := This.Defaults.Color1
            outputObject.Color2 := This.Defaults.Color2
            outputObject.LineBrushWrapMode := This.Defaults.LineBrushWrapMode
            outputObject.Rect := This.Defaults.Rect.Clone()
        }
        return outputObject
    }
    static TextureBrushPrototype( obj := "" ){
        local outputObject := 0
        return outputObject
    }
    static NewBrush( brushType := "SolidBrush" , obj := "" ){
        return This.%brushType%Prototype( obj )
    }
}

class ElementPanel {
    static FillRectangle_Keys := "ElementType|Rect|Roundness|Smoothing|IsHidden|Notes|Brush"
    static winVector := Vector( 300 , 300 )
    static ActiveWindow := ""
    static init := This.GetFontTypesList()
    static GetFontTypesList(){
        local fontTypes := "8514oem|Malgun Gothic|Malgun Gothic Semilight|Microsoft JhengHei|Microsoft JhengHei Light|Microsoft JhengHei UI|Microsoft JhengHei UI Light|Microsoft YaHei|Microsoft YaHei Light|Microsoft YaHei UI|Microsoft YaHei UI Light|MingLiU-ExtB|MingLiU_HKSCS-ExtB|MS Gothic|MS PGothic|MS UI Gothic|NSimSun|PMingLiU-ExtB|SimSun|SimSun-ExtB|Yu Gothic|Yu Gothic Light|Yu Gothic Medium|Yu Gothic UI|Yu Gothic UI Light|Yu Gothic UI Semibold|Yu Gothic UI Semilight|Arial|Arial Black|Bahnschrift|Bahnschrift Condensed|Bahnschrift Light|Bahnschrift Light Condensed|Bahnschrift Light SemiCondensed|Bahnschrift SemiBold|Bahnschrift SemiBold Condensed|Bahnschrift SemiBold SemiConden|Bahnschrift SemiCondensed|Bahnschrift SemiLight|Bahnschrift SemiLight Condensed|Bahnschrift SemiLight SemiConde|Calibri|Calibri Light|Cambria|Cambria Math|Candara|Candara Light|Comic Sans MS|Consolas|Constantia|Corbel|Corbel Light|Courier|Courier New|Ebrima|Fixedsys|Franklin Gothic Medium|Gabriola|Gadugi|Georgia|HoloLens MDL2 Assets|Impact|Ink Free|Javanese Text|Leelawadee UI|Leelawadee UI Semilight|Lucida Console|Lucida Sans Unicode|Malgun Gothic|Malgun Gothic Semilight|Marlett|Microsoft Himalaya|Microsoft JhengHei|Microsoft JhengHei Light|Microsoft JhengHei UI|Microsoft JhengHei UI Light|Microsoft New Tai Lue|Microsoft PhagsPa|Microsoft Sans Serif|Microsoft Tai Le|Microsoft YaHei|Microsoft YaHei Light|Microsoft YaHei UI|Microsoft YaHei UI Light|Microsoft Yi Baiti|MingLiU-ExtB|MingLiU_HKSCS-ExtB|Modern|Mongolian Baiti|MS Gothic|MS PGothic|MS Sans Serif|MS Serif|MS UI Gothic|MV Boli|Myanmar Text|Nirmala UI|Nirmala UI Semilight|NSimSun|Palatino Linotype|PMingLiU-ExtB|Roman|Script|Segoe MDL2 Assets|Segoe Print|Segoe Script|Segoe UI|Segoe UI Black|Segoe UI Emoji|Segoe UI Historic|Segoe UI Light|Segoe UI Semibold|Segoe UI Semilight|Segoe UI Symbol|SimSun|SimSun-ExtB|Sitka Banner|Sitka Display|Sitka Heading|Sitka Small|Sitka Subheading|Sitka Text|Small Fonts|Sylfaen|Symbol|System|Tahoma|Terminal|Times New Roman|Trebuchet MS|Verdana|Webdings|Wingdings|Yu Gothic|Yu Gothic Light|Yu Gothic Medium|Yu Gothic UI|Yu Gothic UI Light|Yu Gothic UI Semibold|Yu Gothic UI Semilight|"
        This.FontTypesList := StrSplit( fontTypes , "|" )
    }
    GuiClose(*){
        local x := "" , y := ""
        This.Window.GetPos( &x , &y )
        ElementPanel.winVector := Vector( x , y )
        Main.ToggleElementPanel( 333 )
    }
    SetRect_X( edit , * ){
        This.Element.Rect.X := edit.Value
        Main.GetLayer().DrawLayer()
    }
    SetRect_Y( edit , * ){
        This.Element.Rect.Y := edit.Value
        Main.GetLayer().DrawLayer()
    }
    SetRect_W( edit , * ){
        This.Element.Rect.W := edit.Value
        Main.GetLayer().DrawLayer()
    }
    SetRect_H( edit , * ){
        This.Element.Rect.H := edit.Value
        Main.GetLayer().DrawLayer()
    }
    SetBrushRect_X( edit , * ){
        This.Element.BrushObject.Rect.X := edit.Value
        Main.GetLayer().DrawLayer()
    }
    SetBrushRect_Y( edit , * ){
        This.Element.BrushObject.Rect.Y := edit.Value
        Main.GetLayer().DrawLayer()
    }
    SetBrushRect_W( edit , * ){
        This.Element.BrushObject.Rect.W := edit.Value
        Main.GetLayer().DrawLayer()
    }
    SetBrushRect_H( edit , * ){
        This.Element.BrushObject.Rect.H := edit.Value
        Main.GetLayer().DrawLayer()
    }
    SetColor1( edit , * ){
        if( StrLen( edit.Value ) = 6 ){
            alpha := This.Controls.Alpha1.Value
            This.Element.BrushObject.Color1 := "0x" alpha . edit.Value
            This.Controls.ColorSwatch1.Opt( "c" edit.Value )
            Main.GetLayer().DrawLayer()
        }
    }
    SetColor2( edit , * ){
        if( StrLen( edit.Value ) = 6 ){
            alpha := This.Controls.Alpha2.Value
            This.Element.BrushObject.Color2 := "0x" alpha . edit.Value
            This.Controls.ColorSwatch2.Opt( "c" edit.Value )
            Main.GetLayer().DrawLayer()
        }
    }
    SetAlpha1( edit , * ){
        if( StrLen( edit.Value ) = 2 ){
            color := This.Controls.Color1.Value
            This.Element.BrushObject.Color1 := "0x" edit.Value . color
            Main.GetLayer().DrawLayer()
        }
    }
    SetAlpha2( edit , * ){
        if( StrLen( edit.Value ) = 2 ){
            color := This.Controls.Color2.Value
            This.Element.BrushObject.Color2 := "0x" edit.Value . color
            Main.GetLayer().DrawLayer()
        }
    }
    ChangeBrushType( tabs , * ){
        local brushTypes := [ "SolidBrush" , "HatchBrush" , "TextureBrush" , "GradientBrush" , "LineBrush" ]
        TimedTips( Tabs.Value "`nHere" )
        This.Element.BrushObject := BrushesAndPensClass.NewBrush( brushTypes[ Tabs.Value ] , This.Element.BrushObject ) 
        This.Window.Destroy()
        ElementPanel.ActiveWindow := ""
        ElementPanel( Main , This.Element )
        Main.GetLayer().DrawLayer()
    }
    SetText( edit , * ){
        This.Element.Text := edit.Value
        Main.GetLayer().DrawLayer()
    }
    SetFontSize( edit , * ){
        if( edit.Value != "" && IsDigit( edit.Value ) ){
            This.Element.FontSize := edit.Value
            Main.GetLayer().DrawLayer()
        }
    }
    SetOffset( edit , * ){     
        if( StrLen( StrReplace( edit.Value , "-" ) ) ){   
            This.Element.Offset := edit.Value
            Main.GetLayer().DrawLayer()     
        }   
    }
    SetCenter( edit , * ){
        This.Element.Center := edit.Value
        Main.GetLayer().DrawLayer() 
    }
    SetVCenter( edit , * ){
        This.Element.vCenter := edit.Value
        Main.GetLayer().DrawLayer() 
    }
    SetBold( edit , * ){
        This.Element.Bold := edit.Value
        Main.GetLayer().DrawLayer() 
    }
    SetUnderline( edit , * ){
        This.Element.Underline := edit.Value
        Main.GetLayer().DrawLayer() 
    }
    SetStrike( edit , * ){
        This.Element.Strike := edit.Value
        Main.GetLayer().DrawLayer() 
    }
    SetRight( edit , * ){
        This.Element.Right := edit.Value
        Main.GetLayer().DrawLayer() 
    }
    SetNoWrap( edit , * ){
        This.Element.NoWrap := edit.Value
        Main.GetLayer().DrawLayer() 
    }
    SetDebugMode( Checkbox , * ){
        This.Element.DebugMode := Checkbox.Value
        Main.GetLayer().DrawLayer() 
    }
    SetItalic( Checkbox , * ){
        This.Element.Italic := Checkbox.Value
        Main.GetLayer().DrawLayer() 
    }
    SetIsHidden( Checkbox , * ){
        This.Element.IsHidden := Checkbox.Value
        Main.GetLayer().DrawLayer() 
        Main.UpdateListBox( "Element" , Main.SelectedElement )
    }
    SetFontType( DDL , * ){
        This.Element.FontType := DDL.Text
        Main.GetLayer().DrawLayer() 
    }
    SetNote( edit , * ){
        This.Element.Note := edit.Value 
        TimedTips( "note `n" This.Element.Note )
    }
    CopyRect( type , * ){
        if( !GetKeyState( "Shift" ) ){
            TimedTips( "Hold shift when you press this button" )
            return -1
        }
        if( type = "rect" ){
            A_Clipboard := Vector.RectToString( This.Element.Rect )
        }else if( type = "Brush" ){
            A_Clipboard := Vector.RectToString( This.Element.BrushObject.Rect )
        }
        TimedTips( "Rect copied to clipboard" )
        return 1
    }
    PasteRect( Type , * ){        
        if( !GetKeyState( "Shift" ) ){
            TimedTips( "Hold shift when you press this button" )
            return -1
        }
        if( StrSplit( A_Clipboard , "," ).Length != 4 || !InStr( A_Clipboard , "|" ) ){
            TimedTips( "Error pasting clipboard rect")
            return 1
        }
        if( Type = "Rect" ){
            This.Element.rect := Vector.StringToRect( A_Clipboard ) 
            This.Controls.X.Value := This.Element.rect.X
            This.Controls.Y.Value := This.Element.rect.Y
            This.Controls.W.Value := This.Element.rect.W
            This.Controls.H.Value := This.Element.rect.H
        }else if( Type = "Brush" ){
            This.Element.BrushObject.rect := Vector.StringToRect( A_Clipboard ) 
            This.Controls.BrushX.Value := This.Element.BrushObject.rect.X
            This.Controls.BrushY.Value := This.Element.BrushObject.rect.Y
            This.Controls.BrushW.Value := This.Element.BrushObject.rect.W
            This.Controls.BrushH.Value := This.Element.BrushObject.rect.H
        }
        Main.GetLayer().DrawLayer() 
        return 1
    }
    GetColor( ColorIndex , * ){
        CoordMode( "Mouse" , "Screen" )
        CoordMode( "Pixel" , "Screen" )
        While( !GetKeyState( "Ctrl" ) ){
            ToolTip( "Hover your cursor over a color and then press CTRL" )
            MouseGetPos( &x , &y )
            This.Controls.Color%ColorIndex%.Value := SubStr( PixelGetColor( x , y ) , 3 )
            This.Controls.ColorSwatch%ColorIndex%.Opt( "c" This.Controls.Color%ColorIndex%.Value )
            This.Element.BrushObject.Color%ColorIndex% := "0x" This.Controls.Alpha%ColorIndex%.Value This.Controls.Color%ColorIndex%.Value            
            Main.GetLayer().DrawLayer()
            Sleep( 30 )
        }
        ToolTip()
        return 1
    }
    CopyColor(*){
        if( !GetKeyState( "Shift" ) ){
            TimedTips( "Hold shift when you press this button" )
            return 1
        }
        if( This.Element.BrushObject.HasProp( "Color2" ) ){
            A_Clipboard := This.Element.BrushObject.Color1 "|" This.Element.BrushObject.Color2
        }else{
            A_Clipboard := This.Element.BrushObject.Color1
        }
        TimedTips( "Color added to clipboard" )
        return 1
    }
    SetSoureceRect( axis , * ){
        TimedTips( axis )
    }
    SetPath( edit , * ){
        TimedTips( "Path: " edit.Value )
    }
    SetHatchValue( edit , * ){
        if( IsNumber( edit.Value ) ){
            ( edit.Value <= 52 ) || edit.Value := 52
            This.Element.BrushObject.HatchValue := edit.Value
            Main.GetLayer().DrawLayer()
        }
    }
    SetThickness( edit , * ){
        if( edit.value = "" ){
            TimedTips( "This is not a valid value" )
            return
        }
        ( edit.Value > 0 ) || edit.Value := 3
        This.Element.Thickness := edit.Value 
        Main.GetLayer().DrawLayer()
    }
    __New( Main , element ){
        if( ElementPanel.ActiveWindow != "" ){
            try{
                ElementPanel.ActiveWindow.Window.Destroy()
            }
        }        
        This.Main           := Main
        This.Element        := element        
        This.Window         := Gui( "+AlwaysOnTop +Owner" This.Main.MainWindow.Hwnd , "Element Panel")
        Main.WindowsList.ElementPanelHwnd := This.Window.Hwnd
        This.Window.MarginX := 2
        This.Window.MarginY := 2
        This.Window.BackColor := "22262a"
        This.ControlIndex   := 0
        This.Controls       := {}
        This.ControlHandles := {}
        This.Window.OnEvent( "Close" , This.GuiClose.Bind( This ) )
        This.AddControls()
        This.Window.Show( "x" ElementPanel.WinVector.X " y" ElementPanel.WinVector.Y )
        This.Color1Index := 1
        This.Color2Index := 1
        ElementPanel.ActiveWindow := This
    }
    AddControls(){
        This.AddHeader()        
        if( InStr( "FillRectangle|" , This.Element.ElementType ) ){
            This.AddRectControls()
            This.AddFillRectangleControls()
            This.AddBrushTabs()
            This.Controls.BrushTabs.UseTab()
        }else if( This.Element.ElementType = "DrawText" ){
            This.AddRectControls()
            This.AddDrawTextControls()
            This.AddBrushTabs()
            This.Controls.BrushTabs.UseTab()
        }else if( This.Element.ElementType = "DrawImage" ){
            This.AddRectControls()
            This.AddSourceRectControls()            
        }else if( This.Element.ElementType = "DrawRectangle" ){
            This.AddRectControls()
            This.AddFillRectangleControls( pen := 1 )
            This.AddBrushTabs()
            This.Controls.BrushTabs.UseTab()         
        }else if( This.Element.ElementType = "FillEllipse" ){
            This.AddRectControls()
            ; This.AddFillRectangleControls( pen := 1 )
            This.AddBrushTabs()
            This.Controls.BrushTabs.UseTab()         
        }
        This.AddElementControls()
    }
    AddHeader(){
        This.Window.SetFont( "s" 12 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm ym w300 r1 Center 0x200 Background33ff99 c000000" , This.Element.ElementType )
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Checkbox" , "xm  w50 r1  Background33ff99 c000000 right"  ( ( This.Element.IsHidden ) ? ( " Checked" ) : ( "" ) ) , "Hide" ,, "Click" , This.SetIsHidden.Bind( This ) )
        This.AddControl( "Text" , "x+m  w50 hp  Background33ff99 c000000 " , "   Note:" )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0  w197 hp -E0x200 Background008822 cFFFFFF " , This.Element.Note , "Note" , "Change" , This.SetNote.Bind( This ) )
    }
    AddRectControls(){
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w60 r1 0x200 Background33ff99 c000000" , "  Rect:" )
        This.AddControl( "Edit" , "x+0 yp w35 hp Center -E0x200 Background008822 cffffff" , This.Element.Rect.X , "X" , "Change" , This.SetRect_X.Bind( This ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background008822 cffffff" , This.Element.Rect.Y , "Y" , "Change" , This.SetRect_Y.Bind( This ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background008822 cffffff" , This.Element.Rect.W , "W" , "Change" , This.SetRect_W.Bind( This ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background008822 cffffff" , This.Element.Rect.H , "H" , "Change" , This.SetRect_H.Bind( This ) )
        This.AddControl( "Text" , "x+m yp w48 hp  Center BackgroundF6D572 c000000" , "Copy" ,, "Click" , This.CopyRect.Bind( This , "rect" ) )
        This.AddControl( "Text" , "x+m yp wp hp  Center BackgroundF6D572 c000000" , "Paste" ,, "Click" , This.PasteRect.Bind( This , "rect" ) )
    }
    AddSourceRectControls(){
        This.Window.SetFont( "s" 12 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "cWhite xm y+m w300 h22 0x200 Background52565a " , "  Image Source" )
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w60 h18 0x200 Background33ff99 c000000" , "  Path:" )
        This.AddControl( "Edit" , "x+0 yp w240 hp Center -E0x200 Background008822 cffffff" , This.Element.Path , "path" , "Change" , This.SetPath.Bind( This ) )        
        This.AddControl( "Text" , "xm y+m w60 h18 0x200 Background33ff99 c000000" , "  Rect:" )
        This.AddControl( "Edit" , "x+0 yp w35 hp Center -E0x200 Background008822 cffffff" , This.Element.SourceRect.X , "SX" , "Change" , This.SetSoureceRect.Bind( This , "SourceX" ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background008822 cffffff" , This.Element.SourceRect.Y , "SY" , "Change" , This.SetSoureceRect.Bind( This , "SourceY" ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background008822 cffffff" , This.Element.SourceRect.W , "SW" , "Change" , This.SetSoureceRect.Bind( This , "SourceW" ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background008822 cffffff" , This.Element.SourceRect.H , "SH" , "Change" , This.SetSoureceRect.Bind( This , "SourceH" ) )
        This.AddControl( "Text" , "x+m yp w48 hp  Center BackgroundF6D572 c000000" , "Copy" ,, "Click" , This.CopyRect.Bind( This , "Source" ) )
        This.AddControl( "Text" , "x+m yp wp hp  Center BackgroundF6D572 c000000" , "Paste" ,, "Click" , This.PasteRect.Bind( This , "Source" ) )
    }
    AddFillRectangleControls( pen := 0 ){
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w100 r1 0x200 Background33ff99 c000000" , "  Roundness:" )
        This.AddControl( "Edit" , "x+0 yp w47 hp Center -E0x200 Background008822 cffffff" , This.Element.Roundness , "Roundness" )
        if( pen ){
            This.AddControl( "Text" , "x+m yp w100 r1 0x200 Background33ff99 c000000" , "  Thickness:" )
            This.AddControl( "Edit" , "x+0 yp w48 hp Center -E0x200 Background008822 cffffff" , This.Element.Thickness , "Thickness" , "Change" , This.SetThickness.Bind( This ) )
        }
    }   
    AddDrawTextControls(){
        local DrawTextKeys := "Rect|Text|FontSize|FontType|Right|NoWrap|Strike|Bold|Underline|DebugMode|Center|vCenter|Offset|Note|BrushObject|IsHidden"
        This.Window.SetFont( "s" 12 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w300 r1 0x200 Center Background33ff99 c000000" , "Text" )
        This.Window.SetFont( "s" 9 " Bold" , "Segoe UI" )
        This.AddControl( "Edit" , "xm y+m w300 r3 -VScroll -E0x200 Background008822 cffffff" , This.Element.Text , "Text" , "Change" , This.SetText.Bind( This ) )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w80 h23 0x200  Background33ff99 c000000" , "  Font Type" )
        This.Window.SetFont( "s" 9 " Bold" , "Segoe UI" )
        This.AddControl( "DDL" , "x+m yp w218 r22 -E0x200 Background008822 cFFFFFF Choose107" , ElementPanel.FontTypesList ,, "Change" , This.SetFontType.Bind( This ) )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w80 r1 0x200  Background33ff99 c000000" , "  Font Size" )
        This.Window.SetFont( "s" 9 " Bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+m yp w30 hp -E0x200  Background008822 cFFFFFF" , This.Element.FontSize , "FontSize" , "Change" , This.SetFontSize.Bind( This ) )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "x+m yp w80 r1 0x200  Background33ff99 c000000" , "  Offset" )
        This.Window.SetFont( "s" 9 " Bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+m yp w30 hp -E0x200  Background008822 cFFFFFF" , This.Element.Offset , "Offset" , "Change" , This.SetOffset.Bind( This ) )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Checkbox" , "xm y+m w98 Right Background33ff99 c000000 " ( ( This.Element.Center = 1 ) ? ( " Checked" ) : ( " " ) ) , "Center" , "Center" , "Click" , This.SetCenter.Bind( This ) )
        This.AddControl( "Checkbox" , "x+m yp wp Right Background33ff99 c000000 " ( ( This.Element.vCenter = 1 ) ? ( " Checked" ) : ( " " ) ) , "vCenter" , "vCenter" , "Click" , This.SetVCenter.Bind( This ) )
        This.AddControl( "Checkbox" , "x+m yp wp Right Background33ff99 c000000 " ( ( This.Element.Bold = 1 ) ? ( " Checked" ) : ( " " ) ) , "Bold" , "Bold" , "Click" , This.SetBold.Bind( This ) )
        This.AddControl( "Checkbox" , "xm y+m wp Right Background33ff99 c000000 " ( ( This.Element.Underline = 1 ) ? ( " Checked" ) : ( " " ) ) , "Underline" , "Underline" , "Click" , This.SetUnderline.Bind( This ) )
        This.AddControl( "Checkbox" , "x+m yp wp Right Background33ff99 c000000 " ( ( This.Element.Strike = 1 ) ? ( " Checked" ) : ( " " ) ) , "Strike" , "Strike" , "Click" , This.SetStrike.Bind( This ) )
        This.AddControl( "Checkbox" , "x+m yp wp Right Background33ff99 c000000 " ( ( This.Element.Right = 1 ) ? ( " Checked" ) : ( " " ) ) , "Right" , "Right" , "Click" , This.SetRight.Bind( This ) )
        This.AddControl( "Checkbox" , "xm y+m wp Right Background33ff99 c000000 " ( ( This.Element.NoWrap = 1 ) ? ( " Checked" ) : ( " " ) ) , "NoWrap" , "NoWrap" , "Click" , This.SetNoWrap.Bind( This ) )
        This.AddControl( "Checkbox" , "x+m yp wp Right Background33ff99 c000000 " ( ( This.Element.Italic = 1 ) ? ( " Checked" ) : ( " " ) ) , "Italic" , "Italic" , "Click" , This.SetItalic.Bind( This ) )
        This.AddControl( "Checkbox" , "x+m yp wp Right Background33ff99 c000000 " ( ( This.Element.DebugMode = 1 ) ? ( " Checked" ) : ( " " ) ) , "DebugMode" , "DebugMode" , "Click" , This.SetDebugMode.Bind( This ) )
    }
    AddBrushTabs(){
        local tabs := [ "SolidBrush" , "HatchBrush" , "TextureBrush" , "GradientBrush" , "LineBrush" ]
        This.Window.SetFont( "s" 8 " norm" , "Segoe UI" )
        This.AddControl( "Tab3" , "xm w300 c33ff99 buttons Bottom" , tabs , "BrushTabs" , "Change" , This.ChangeBrushType.Bind( This ) )
        if( This.Element.BrushObject = 0 )
            return
        switch  This.Element.BrushObject.BrushType , "Off" {
            case "SolidBrush":
                This.Controls.BrushTabs.UseTab( 1 )
                This.Window.SetFont( "s" 12 " bold" , "Segoe UI" )
                This.AddControl( "Text" , "w300 r1 Center 0x200 Background054425 cFFFFFF section" , This.Element.BrushObject.BrushType )
                This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
                This.AddControl( "Text" , "xp y+m w55 r1 0x200 Background33ff99 c000000" , "  Color1:" )
                This.AddControl( "Progress" , "x+1 yp w20 hp Background008822 c" SubStr( This.Element.BrushObject.Color1 , 5 ) , 100 , "ColorSwatch1" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color1 , 3 , 2 ) , "Alpha1" , "Change" , This.SetAlpha1.Bind( This ) )
                This.AddControl( "Edit" , "x+0 yp w55 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color1 , 5 ) , "Color1" , "Change" , This.SetColor1.Bind( This ) )
                This.AddControl( "Text" , "x+m yp w38 hp 0x200 Center BackgroundF6D572 c000000" , "Get" ,, "Click" , This.GetColor.Bind( This , "1" ) )
                This.AddControl( "Text" , "x+m yp w48 hp  Center BackgroundF6D572 c000000" , "Copy" )
                This.AddControl( "Text" , "x+m yp wp hp  Center BackgroundF6D572 c000000" , "Paste" )
                This.AddControl( "Text" , " xs w148 hp  Center Backgroundbd9d3d cffffff" , "Copy Brush" )
                This.AddControl( "Text" , "x+m yp wp hp  Center Backgroundbd9d3d cffffff" , "Paste Brush" )
                This.Controls.BrushTabs.Choose( 1 )
            case "HatchBrush":
                This.Controls.BrushTabs.UseTab( 2 )
                This.Window.SetFont( "s" 12 " bold" , "Segoe UI" )
                This.AddControl( "Text" , "w300 r1 Center 0x200 Background054425 cFFFFFF section" , This.Element.BrushObject.BrushType )
                This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
                This.AddControl( "Text" , "xp y+m w55 r1 0x200 Background33ff99 c000000" , "  Color1:" )
                This.AddControl( "Progress" , "x+1 yp w20 hp Background008822 c" SubStr( This.Element.BrushObject.Color1 , 5 ) , 100 , "ColorSwatch1" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color1 , 3 , 2 ) , "Alpha1" , "Change" , This.SetAlpha1.Bind( This ) )
                This.AddControl( "Edit" , "x+0 yp w55 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color1 , 5 ) , "Color1" , "Change" , This.SetColor1.Bind( This ) )
                This.AddControl( "Text" , "x+m yp w38 hp 0x200 Center BackgroundF6D572 c000000" , "Get" ,, "Click" , This.GetColor.Bind( This , "1" ) )
                This.AddControl( "Text" , "x+m yp w48 hp  Center BackgroundF6D572 c000000 " , "Copy" )
                This.AddControl( "Text" , "x+m yp wp hp  Center BackgroundF6D572 c000000" , "Paste" )
                This.AddControl( "Text" , "xs w55 r1 0x200 Background33ff99 c000000" , "  Color2:" )
                This.AddControl( "Progress" , "x+1 yp w20 hp Background008822 c" SubStr( This.Element.BrushObject.Color2 , 5 ) , 100 , "ColorSwatch2" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color2 , 3 , 2 ) , "Alpha2" , "Change" , This.SetAlpha2.Bind( This ) )
                This.AddControl( "Edit" , "x+0 yp w55 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color2 , 5 ) , "Color2" , "Change" , This.SetColor2.Bind( This ) )
                This.AddControl( "Text" , "x+m yp w38 hp 0x200 Center BackgroundF6D572 c000000" , "Get" ,, "Click" , This.GetColor.Bind( This , "2" ) )
                This.AddControl( "Text" , "xs w100 r1 0x200 Background33ff99 c000000" , "  Hatch Value:" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , This.Element.BrushObject.HatchValue , "HatchValue" , "Change" , This.SetHatchValue.Bind( This ) )
                This.AddControl( "Text" , " xs w148 hp  Center Backgroundbd9d3d cffffff" , "Copy Brush" )
                This.AddControl( "Text" , "x+m yp wp hp  Center Backgroundbd9d3d cffffff" , "Paste Brush" )
                This.Controls.BrushTabs.Choose( 2 )
            case "GradientBrush":
                This.Controls.BrushTabs.UseTab( 4 )
                This.Window.SetFont( "s" 12 " bold" , "Segoe UI" )
                This.AddControl( "Text" , "w300 r1 Center 0x200 Background054425 cFFFFFF section" , This.Element.BrushObject.BrushType )
                This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
                This.AddControl( "Text" , "xp y+m w55 r1 0x200 Background33ff99 c000000" , "  Color1:" )
                This.AddControl( "Progress" , "x+1 yp w20 hp Background008822 c" SubStr( This.Element.BrushObject.Color1 , 5 ) , 100 , "ColorSwatch1" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color1 , 3 , 2 ) , "Alpha1" , "Change" , This.SetAlpha1.Bind( This ) )
                This.AddControl( "Edit" , "x+0 yp w55 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color1 , 5 ) , "Color1" , "Change" , This.SetColor1.Bind( This ) )
                This.AddControl( "Text" , "x+m yp w38 hp 0x200 Center BackgroundF6D572 c000000" , "Get" ,, "Click" , This.GetColor.Bind( This , "1" ) )
                This.AddControl( "Text" , "x+m yp w48 hp  Center BackgroundF6D572 c000000 " , "Copy" )
                This.AddControl( "Text" , "x+m yp wp hp  Center BackgroundF6D572 c000000" , "Paste" )
                This.AddControl( "Text" , "xs w55 r1 0x200 Background33ff99 c000000" , "  Color2:" )
                This.AddControl( "Progress" , "x+1 yp w20 hp Background008822 c" SubStr( This.Element.BrushObject.Color2 , 5 ) , 100 , "ColorSwatch2" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color2 , 3 , 2 ) , "Alpha2" , "Change" , This.SetAlpha2.Bind( This ) )
                This.AddControl( "Edit" , "x+0 yp w55 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color2 , 5 ) , "Color2" , "Change" , This.SetColor2.Bind( This ) )
                This.AddControl( "Text" , "x+m yp w38 hp 0x200 Center BackgroundF6D572 c000000" , "Get" ,, "Click" , This.GetColor.Bind( This , "2" ) )
                This.AddBrushRectControls()
                This.Window.SetFont( "s" 8 " bold" , "Segoe UI" )
                This.AddControl( "Text" , "xs y+m w120 hp 0x200 Background33ff99 c000000" , "  LinearGradientMode:" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , This.Element.BrushObject.LinearGradientMode , "GradientBrushLinearMode" )
                This.AddControl( "Text" , "x+m yp w120 hp 0x200 Background33ff99 c000000" , "  WrapMode:" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , This.Element.BrushObject.GradientBrushWrapMode , "GradientBrushWrapMode" )
                This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
                This.AddControl( "Text" , " xs w148 hp  Center Backgroundbd9d3d cffffff" , "Copy Brush" )
                This.AddControl( "Text" , "x+m yp wp hp  Center Backgroundbd9d3d cffffff" , "Paste Brush" )
                This.Controls.BrushTabs.Choose( 4 )
            case "LineBrush":
                This.Controls.BrushTabs.UseTab( 5 )
                This.Window.SetFont( "s" 12 " bold" , "Segoe UI" )
                This.AddControl( "Text" , "w300 r1 Center 0x200 Background054425 cFFFFFF section" , This.Element.BrushObject.BrushType )
                This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
                This.AddControl( "Text" , "xp y+m w55 r1 0x200 Background33ff99 c000000" , "  Color1:" )
                This.AddControl( "Progress" , "x+1 yp w20 hp Background008822 c" SubStr( This.Element.BrushObject.Color1 , 5 ) , 100 , "ColorSwatch1" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color1 , 3 , 2 ) , "Alpha1" , "Change" , This.SetAlpha1.Bind( This ) )
                This.AddControl( "Edit" , "x+0 yp w55 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color1 , 5 ) , "Color1" , "Change" , This.SetColor1.Bind( This ) )
                This.AddControl( "Text" , "x+m yp w38 hp 0x200 Center BackgroundF6D572 c000000" , "Get" ,, "Click" , This.GetColor.Bind( This , "1" ) )
                This.AddControl( "Text" , "x+m yp w48 hp  Center BackgroundF6D572 c000000 " , "Copy" )
                This.AddControl( "Text" , "x+m yp wp hp  Center BackgroundF6D572 c000000" , "Paste" )
                This.AddControl( "Text" , "xs w55 r1 0x200 Background33ff99 c000000" , "  Color2:" )
                This.AddControl( "Progress" , "x+1 yp w20 hp Background008822 c" SubStr( This.Element.BrushObject.Color2 , 5 ) , 100 , "ColorSwatch2" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color2 , 3 , 2 ) , "Alpha2" , "Change" , This.SetAlpha2.Bind( This ) )
                This.AddControl( "Edit" , "x+0 yp w55 hp Center -E0x200 Background008822 cffffff" , SubStr( This.Element.BrushObject.Color2 , 5 ) , "Color2" , "Change" , This.SetColor2.Bind( This ) )
                This.AddControl( "Text" , "x+m yp w38 hp 0x200 Center BackgroundF6D572 c000000" , "Get" ,, "Click" , This.GetColor.Bind( This , "2" ) )
                This.AddBrushRectControls()
                This.Window.SetFont( "s" 8 " bold" , "Segoe UI" )
                This.AddControl( "Text" , "xs y+m w80 hp 0x200 Background33ff99 c000000" , "  WrapMode:" )
                This.AddControl( "Edit" , "x+1 yp w25 hp Center -E0x200 Background008822 cffffff" , This.Element.BrushObject.LineBrushWrapMode )
                This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
                This.AddControl( "Text" , " xs w148 hp  Center Backgroundbd9d3d cffffff" , "Copy Brush" )
                This.AddControl( "Text" , "x+m yp wp hp  Center Backgroundbd9d3d cffffff" , "Paste Brush" )
                This.Controls.BrushTabs.Choose( 5 )   
            case "TextureBrush":
                This.Controls.BrushTabs.UseTab( 3 )
                return 
        }
    }
    AddElementControls(){
        This.Window.SetFont( "s" 12 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm  w300 r1  Center Background33ff99 c000000" , "Element Options" )
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w130 r1  Background33ff99 c000000" , "   Element Position:" )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w65 hp Center -E0x200 Background008822 cffffff" , Main.SelectedElement , "Position" )
        This.AddControl( "Text" , "x+m w100 hp 0x200 Center BackgroundF6D572 c000000" , "Copy Element" ,, "Click" , Main.CopyElement.Bind( Main ) ) 
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w60 r1  Background33ff99 c000000" , "   Layer:" )
        This.Window.SetFont( "s" 7 " norm" , "Segoe UI" )
        This.AddControl( "DDL" , "x+m yp w135 r10 Center -E0x200 Background008822 c000000 " , ["Layer 1" , "Layer 2"] )
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "x+m w100 hp 0x200 Center BackgroundF6D572 c000000" , "Change Layer" )
    }
    AddBrushRectControls(){
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xs y+m w60 r1 0x200 Background33ff99 c000000" , "  Rect:" )
        This.AddControl( "Edit" , "x+0 yp w35 hp Center -E0x200 Background008822 cffffff" , This.Element.BrushObject.Rect.X , "BrushX" , "Change" , This.SetBrushRect_X.Bind( This ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background008822 cffffff" , This.Element.BrushObject.Rect.Y , "BrushY" , "Change" , This.SetBrushRect_Y.Bind( This ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background008822 cffffff" , This.Element.BrushObject.Rect.W , "BrushW" , "Change" , This.SetBrushRect_W.Bind( This ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background008822 cffffff" , This.Element.BrushObject.Rect.H , "BrushH" , "Change" , This.SetBrushRect_H.Bind( This ) )
        This.AddControl( "Text" , "x+m yp w48 hp  Center BackgroundF6D572 c000000" , "Copy" ,, "Click" , This.CopyRect.Bind( This , "Brush" ) )
        This.AddControl( "Text" , "x+m yp wp hp  Center BackgroundF6D572 c000000" , "Paste" ,, "Click" , This.PasteRect.Bind( This , "Brush" ) )
    }
    AddControl( type := "Text" , options := "" , value := "" , name := "" , eventType := "" , eventBind := "" ){
        local cc := "" , hwnd 
        This.ControlIndex++
        if( value != "" ) 
            cc := This.Window.Add( type , options , value )
        else 
            cc := This.Window.Add( type , options )
        if( name = "" )
            name := type "_" This.ControlIndex
        cc.Name := name 
        cc.Index := This.ControlIndex
        hwnd := cc.Hwnd 
        This.ControlHandles.%hwnd% := cc 
        This.Controls.%Name% := cc
        if( eventType != "" && eventBind != "" ){
            cc.OnEvent( eventType , eventBind )
            if( eventType = "Click" ){
                cc.OnEvent( "DoubleClick" , eventBind )
            }
        }
    }
}

class BitmapPanel   {
    static WinVector := Vector( 300 , 300 )
    static ActiveWindow := ""
    
    GuiClose(*){
        local x := "" , y := ""
        This.Window.GetPos( &x , &y )
        BitmapPanel.winVector := Vector( x , y )
        BitmapPanel.ActiveWindow := ""
        Main.ToggleBitmapPanel( 333 )
        This.Window.Destroy()
    }
    SetName( edit , * ){
        local bitmap := Main.GetBitmap()
        if( edit.Value = "" ) 
            return
        bitmap.Name := edit.Value
        Main.UpdateListBox( "Bitmap" , Main.SelectedBitmap )
    }
    SetRect( edit , * ){
        local cc := This.Bitmap.Rect
        local name := edit.Name 
        cc.%name% := edit.Value
        This.Bitmap.UpdateSize( cc.x , cc.y , cc.w , cc.h )
        if( This.Bitmap.HasProp( "pBitmap" ) ){
            This.Bitmap.Window.Clear()
            Gdip_DrawImage( This.Bitmap.Window.G , This.Bitmap.pBitmap , 0 , 0 , cc.W * This.Bitmap.Scale , cc.H * This.Bitmap.Scale )
            This.Bitmap.Window.Update()
        }
        Loop( This.Bitmap.Layers.Length ){
            rect := This.Bitmap.Layers[ A_Index ].Rect
            layer := This.Bitmap.Layers[ A_Index ]
            rect.W := cc.W
            rect.H := cc.H
            layer.Window.Resize( 1 , rect.X * This.Bitmap.Scale , rect.Y * This.Bitmap.Scale , rect.W * This.Bitmap.Scale , rect.H * This.Bitmap.Scale )
            This.Bitmap.Layers[ A_Index ].Scale := This.Bitmap.Scale
            This.Bitmap.Layers[ A_Index ].DrawLayer()
        }
        try{
            If( WinExist( "ahk_id " LayerPanel.ActiveWindow.Window.Hwnd ) && name = "W" || name = "H" ){
                LayerPanel.ActiveWindow.Window.GetPos( &X , &Y )
                LayerPanel.WinVector := Vector( x , y )
                Main.ToggleLayerPanel( 333 )
                Main.ToggleLayerPanel( 1 )
            }
        }
    }
    SetSmoothing( edit , * ){
        ( edit.Value >= 0 ) || edit.Value := 0
        ( edit.Value <= 4 ) || edit.Value := 4
        This.Bitmap.Smoothing := edit.Value
    }
    SetInterpolationMode( edit , * ){
        ( edit.Value >= 0 ) || edit.Value := 0
        ( edit.Value <= 7 ) || edit.Value := 7
        This.Bitmap.InterpolationMode := edit.Value
    }
    SetOrder( edit , * ){

    }
    SetScale( edit , * ){
        TimedTips( "This is currently not available" )
    }
    __New( Main , bitmap ){
        if( BitmapPanel.ActiveWindow != "" ){
            try{
                BitmapPanel.ActiveWindow.Window.Destroy()
            }
        }
        This.Main           := Main
        This.Bitmap         := bitmap
        This.Window         := Gui( "+AlwaysOnTop +Owner" This.Main.MainWindow.Hwnd , "Bitmap Panel")
        Main.WindowsList.BitmapPanelHwnd := This.Window.Hwnd
        This.Window.MarginX := 2
        This.Window.MarginY := 2
        This.Window.BackColor := "22262a"
        This.ControlIndex   := 0
        This.Controls       := {}
        This.ControlHandles := {}
        This.Window.OnEvent( "Close" , This.GuiClose.Bind( This ) )
        This.AddControls()
        This.Window.Show( "x" BitmapPanel.WinVector.X " y" BitmapPanel.WinVector.Y )
        BitmapPanel.ActiveWindow := This
    }
    AddControls(){
        local rect := This.Bitmap.Rect
        This.Window.SetFont( "s" 12 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm ym w300 r1 Center 0x200 Background6699bb c000000" , "Bitmap Details" )        
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w85 r1 0x200 Background6699bb c000000" , "  Name:" )
        This.AddControl( "Edit" , "x+0 w215 hp -E0x200 Center Background003366 cFFFFFF" , This.Bitmap.Name , "Name" , "Change" , This.SetName.Bind( This ))        
        This.AddControl( "Text" , "xm y+m w85 r1 0x200 Background6699bb c000000" , "  Rect:" )
        This.AddControl( "Edit" , "x+0 yp w54 hp Center -E0x200 Background003366 cffffff" , rect.X , "X" , "Change" , This.SetRect.Bind( This ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background003366 cffffff" , rect.Y , "y" , "Change" , This.SetRect.Bind( This ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background003366 cffffff" , rect.W , "W" , "Change" , This.SetRect.Bind( This ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background003366 cffffff" , rect.H , "H" , "Change" , This.SetRect.Bind( This ) )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w85 r1 0x200 Background6699bb c000000" , "  Smoothing:" )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w54 hp Center -E0x200 Background003366 cffffff" , This.Bitmap.Smoothing , "Smoothing" , "Change" , This.SetSmoothing.Bind( This ) )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "x+m yp w120 r1 0x200 Background6699bb c000000" , "  Interpolation Mode:" )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w40 hp Center -E0x200 Background003366 cffffff" , This.Bitmap.InterpolationMode , "InterpolationMode" , "Change" , This.SetInterpolationMode.Bind( This ) )
        This.Window.SetFont( "s" 12 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w300 r1 Center 0x200 Background6699bb c000000" , "Bitmap Options" )
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w130 r1  Background6699bb c000000" , "   Bitmap Position:" )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w65 hp Center -E0x200 Background003366 cffffff" , Main.SelectedBitmap , "Position" , "Change" , This.SetOrder.Bind( This ) )
        This.AddControl( "Text" , "x+m w103 hp 0x200 Center BackgroundF6D572 c000000" , "Copy Bitmap" ,, "Click" , Main.CopyBitmap.Bind( Main ) ) 
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w60 r1  Background6699bb c000000" , "   Scale:" )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w65 hp Center -E0x200 Background003366 cffffff" , This.Bitmap.Scale , "Scale" , "Change" , This.SetScale.Bind( This ) )
    }
    AddControl( type := "Text" , options := "" , value := "" , name := "" , eventType := "" , eventBind := "" ){
        local cc := "" , hwnd 
        This.ControlIndex++
        if( value != "" ) 
            cc := This.Window.Add( type , options , value )
        else 
            cc := This.Window.Add( type , options )
        if( name = "" )
            name := type "_" This.ControlIndex
        cc.Name := name 
        cc.Index := This.ControlIndex
        hwnd := cc.Hwnd 
        This.ControlHandles.%hwnd% := cc 
        This.Controls.%Name% := cc
        if( eventType != "" && eventBind != "" )
            cc.OnEvent( eventType , eventBind )
    }
}

class LayerPanel {
    static WinVector := Vector( 300 , 300 )
    static ActiveWindow := ""
    GuiClose(*){
        local x := "" , y := ""
        This.Window.GetPos( &x , &y )
        LayerPanel.winVector := Vector( x , y )
    }
    ChangeName( edit , * ){
        if( edit.Value = "" )
            return
        This.Layer.Name := edit.Value 
        Main.UpdateListBox( "Layer" , Main.SelectedLayer )
    }
    SetIsHidden( checkbox , * ){
        This.Layer.IsHidden := checkbox.Value 
        Main.GetLayer().DrawLayer() 
        Main.UpdateListBox( "Layer" , Main.SelectedLayer )
    }
    SetNote( edit , * ){
        This.Layer.Note := edit.Value 
    }
    SetRect( key , edit , * ){
        This.Layer.Rect.%key% := edit.Value
        Main.GetLayer().UpdateSize( This.Layer.Rect.X , This.Layer.Rect.Y , This.Layer.Rect.W , This.Layer.Rect.H )
        Main.GetLayer().DrawLayer()        
    }
    SetSmoothing( edit , * ){
        if( edit.value = "" )
            return
        ( edit.Value <= 4 ) || edit.Value := 4
        ( edit.Value >= 0 ) || edit.Value := 0
        This.Layer.Smoothing := edit.Value 
        Main.GetLayer().DrawLayer() 
    }
    SetInterpolationMode( edit , * ){
        if( edit.value = "" )
            return
        ( edit.Value <= 7 ) || edit.Value := 7
        ( edit.Value >= 0 ) || edit.Value := 0
        This.Layer.InterpolationMode := edit.Value 
        Main.GetLayer().DrawLayer()
    }
    __New( Main , layer ){
        if( LayerPanel.ActiveWindow != "" ){
            try{
                LayerPanel.ActiveWindow.Window.Destroy()
            }
        }
        This.Main           := Main
        This.Layer          := layer
        This.Window         := Gui( "+AlwaysOnTop +Owner" This.Main.MainWindow.Hwnd , "Layer Panel")
        Main.WindowsList.LayerPanelHwnd := This.Window.Hwnd
        This.Window.MarginX := 2
        This.Window.MarginY := 2
        This.Window.BackColor := "22262a"
        This.ControlIndex   := 0
        This.Controls       := {}
        This.ControlHandles := {}
        This.Window.OnEvent( "Close" , This.GuiClose.Bind( This ) )
        This.AddControls()
        This.Window.Show( "x" LayerPanel.WinVector.X " y" LayerPanel.WinVector.Y " NA")
        LayerPanel.ActiveWindow := This
    }
    AddControls(){
        This.Window.SetFont( "s" 12 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm ym w300 r1 Center 0x200 Background999999 c000000" , "Layer Details" )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w85 r1 0x200 Background999999 c000000" , "  Name:" )
        This.AddControl( "Edit" , "x+0 w215 hp -E0x200 Center Background666666 cFFFFFF" , This.Layer.Name , "Name" , "Change" , This.ChangeName.Bind( This ) )
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Checkbox" , "xm  w85 r1  Background666666 cFFFFFF right " ( ( This.Layer.IsHidden ) ? ( "Checked" ) : ( "" ) ) , "Hide" ,, "Click" , This.SetIsHidden.Bind( This ) )
        This.AddControl( "Text" , "x+m  w50 hp  Background999999 c000000 " , "   Note:" )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0  w163 hp -E0x200 Background666666 cFFFFFF " , This.Layer.Note , "Note" , "Change" , This.SetNote.Bind( This ) )
        This.AddControl( "Text" , "xm y+m w85 r1 0x200 Background999999 c000000" , "  Rect:" )
        rect := This.Layer.Rect
        This.AddControl( "Edit" , "x+0 yp w54 hp Center -E0x200 Background666666 cffffff" , rect.X , "X" , "Change" , This.SetRect.Bind( This , "X" ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background666666 cffffff" , rect.Y , "Y" , "Change" , This.SetRect.Bind( This , "Y" ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background666666 cffffff" , rect.W , "W" , "Change" , This.SetRect.Bind( This , "W" ) )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background666666 cffffff" , rect.H , "H" , "Change" , This.SetRect.Bind( This , "H" ) )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w85 r1 0x200 Background999999 c000000" , "  Smoothing:" )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w54 hp Center -E0x200 Background666666 cffffff" , This.Layer.Smoothing , "Smoothing" , "Change" , This.SetSmoothing.Bind( This ) )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "x+m yp w120 r1 0x200 Background999999 c000000" , "  Interpolation Mode:" )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w40 hp Center -E0x200 Background666666 cffffff" , This.Layer.InterpolationMode , "InterpolationMode" , "Change" , This.SetInterpolationMode.Bind( This ) )
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w130 r1  Background999999 c000000" , "   Layer Position:" )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w55 hp Center -E0x200 Background666666 cffffff" , Main.SelectedLayer , "Position" )
        This.Window.SetFont( "s" 10 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "x+m w60 r1  Background999999 c000000" , "   Scale:" )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w55 hp Center -E0x200 Background666666 cffffff" , This.Layer.Scale , "Scale" )
        This.AddControl( "Text" , "xm+197 w103 hp 0x200 Center BackgroundF6D572 c000000" , "Copy Layer" ,, "Click" , Main.CopyLayer.Bind( Main ) ) 
    }
    AddControl( type := "Text" , options := "" , value := "" , name := "" , eventType := "" , eventBind := "" ){
        local cc := "" , hwnd 
        This.ControlIndex++
        if( value != "" ) 
            cc := This.Window.Add( type , options , value )
        else 
            cc := This.Window.Add( type , options )
        if( name = "" )
            name := type "_" This.ControlIndex
        cc.Name := name 
        cc.Index := This.ControlIndex
        hwnd := cc.Hwnd 
        This.ControlHandles.%hwnd% := cc 
        This.Controls.%Name% := cc
        if( eventType != "" && eventBind != "" )
            cc.OnEvent( eventType , eventBind )
    }
}

class NewBitmapPanel    {
    static WinVector := Vector( 300 , 300 )
    static ActiveWindow := ""
    static init := This.SetBitmapPrototype()
    
    static SetBitmapPrototype(){
        local cc := This.Defaults := {}
        cc.Name                := "New Bitmap"
        cc.Rect                := Vector.Rect( 0 , 0 , 300 , 200 )
        cc.Smoothing           := 2
        cc.InterpolationMode   := 7
        cc.Scale               := 1
    }
    GuiClose(*){
        local x := "" , y := ""
        This.Window.GetPos( &x , &y )
        NewBitmapPanel.winVector := Vector( x , y )
        NewBitmapPanel.ActiveWindow := ""
        This.Bitmap := 0
        Main.MainWindow.opt( "-Disabled" )
        This.Window.Destroy()
    }
    SubmitBitmap(*){
        local x := "" , y := ""
        This.Window.GetPos( &x , &y )
        NewBitmapPanel.winVector := Vector( x , y )
        NewBitmapPanel.ActiveWindow := ""
        Main.MainWindow.opt( "-Disabled" )
        This.Window.Destroy()
    }
    __New( Main ){
        Main.MainWindow.opt( "+Disabled" )
        This.Main                   := Main
        This.Window                 := Gui( "+AlwaysOnTop +Owner" This.Main.MainWindow.Hwnd , "New Bitmap Panel")
        NewBitmapPanel.ActiveWindow := This
        This.Window.MarginX         := 2
        This.Window.MarginY         := 2
        This.Window.BackColor       := "22262a"
        This.ControlIndex           := 0
        This.Controls               := {}
        This.ControlHandles         := {}
        Main.WindowsList.NewBitmapWindowHwnd := This.Window.Hwnd
        This.Window.OnEvent( "Close" , This.GuiClose.Bind( This ) )
        This.GetBitmapPrototype()
        This.AddControls()
        This.Window.Show( "x" NewBitmapPanel.WinVector.X " y" NewBitmapPanel.WinVector.Y )
        WinWaitClose( "ahk_id " This.Window.Hwnd )
    }
    GetBitmapPrototype(){
        This.Bitmap := {}
        for k , v in NewBitmapPanel.Defaults.OwnProps(){
            if( IsObject( NewBitmapPanel.Defaults.%k% ) )
                This.Bitmap.%k% := NewBitmapPanel.Defaults.%k%.Clone()
            else
                This.Bitmap.%k% := NewBitmapPanel.Defaults.%k%
        }
    }
    AddControls(){
        This.Window.SetFont( "s" 12 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm ym w300 r1 Center 0x200 Background6699bb c000000" , "New Bitmap Details" )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w85 r1 0x200 Background6699bb c000000" , "  Name:" )
        This.AddControl( "Edit" , "x+0 w215 hp -E0x200 Center Background003366 cFFFFFF" , This.Bitmap.Name ,, "Change" , This.SetName.Bind( This ) )
        This.AddControl( "Text" , "xm y+m w85 r1 0x200 Background6699bb c000000" , "  Rect:" )
        This.AddControl( "Edit" , "x+0 yp w54 hp Center -E0x200 Background003366 cffffff" , This.Bitmap.Rect.X , "X" )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background003366 cffffff" , This.Bitmap.Rect.Y , "Y" )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background003366 cffffff" , This.Bitmap.Rect.W , "W" )
        This.AddControl( "Edit" , "x+0 yp wp hp Center -E0x200 Background003366 cffffff" , This.Bitmap.Rect.H , "H" )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w85 r1 0x200 Background6699bb c000000" , "  Smoothing:" )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w54 hp Center -E0x200 Background003366 cffffff" , This.Bitmap.Smoothing , "Smoothing" )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "x+m yp w120 r1 0x200 Background6699bb c000000" , "  Interpolation Mode:" )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Edit" , "x+0 yp w40 hp Center -E0x200 Background003366 cffffff" , This.Bitmap.InterpolationMode , "InterpolationMode" )
        This.Window.SetFont( "s" 12 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm y+m w300 r3 Center 0x200 Background002255 c336699" , "Reserved Space" )
        This.Window.SetFont( "s" 9 " bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm+90 w103 r1 0x200 Center BackgroundF6D572 c000000" , "Cancel" ,, "Click" , This.GuiClose.Bind( This ) ) 
        This.AddControl( "Text" , "x+m w103 r1 0x200 Center BackgroundF6D572 c000000" , "Submit" ,, "Click" , This.SubmitBitmap.Bind( This ) ) 
    }
    AddControl( type := "Text" , options := "" , value := "" , name := "" , eventType := "" , eventBind := "" ){
        local cc := "" , hwnd 
        This.ControlIndex++
        if( value != "" ) 
            cc := This.Window.Add( type , options , value )
        else 
            cc := This.Window.Add( type , options )
        if( name = "" )
            name := type "_" This.ControlIndex
        cc.Name := name 
        cc.Index := This.ControlIndex
        hwnd := cc.Hwnd 
        This.ControlHandles.%hwnd% := cc 
        This.Controls.%Name% := cc
        if( eventType != "" && eventBind != "" )
            cc.OnEvent( eventType , eventBind )
    }
    SetName( edit , * ){
        if( edit.Value != "" )
            This.Bitmap.Name := edit.Value
    }
}

class LoadBitmapPanel extends DataClass  {
    static WinVector := Vector( 900 , 150 ) 
    
    GuiClose(*){
        local x := "" , y := ""
        This.Window.GetPos( &x , &y )
        LoadBitmapPanel.winVector := Vector( x , y )
        This.Bitmap := 0
        Main.MainWindow.opt( "-Disabled" )
        This.Window.Destroy()
    }
    LoadBitmap(*){
        local value := This.Controls.BitmapListbox.Value
        local path := Main.DataFolder . Main.DataList[ value ]
        if( !FileExist( path ) ){
            TimedTips( "That file doesn't exist???`nYou should never be able to see this message" )
            return
        }
        bitmap := This.ReadBitmapData( path )
        if( bitmap = 0 ){
            TimedTips( "Action Canceled" )
            return
        }
        This.Bitmap := Bitmap
        Main.MainWindow.opt( "-Disabled" )
        This.Window.Destroy()
    }
    DeleteBitmapFiles(*){
        local value := This.Controls.BitmapListbox.Value
        local path := Main.DataFolder . Main.DataList[ value ]
        local name := Main.DataList[ value ]
        if( MsgBox( "Delete the selected Bitmap?" , "Delete Bitmap Files" , 0x1 ) = "OK" ){
            try{
                FileDelete( path )
                path := Main.CodeFolder . SubStr( name , 1 , StrLen( name ) - 3 ) "ahk"
                FileDelete( path )
            }catch{
                MsgBox( "Error when trying to delete the window" )
            }
            This.Controls.BitmapListbox.Delete()
            This.Controls.BitmapListbox.Add( Main.DataList )            
        }
    }
    ClipboardBitmapCode(*){
        local value := This.Controls.BitmapListbox.Value
        local name := Main.DataList[ value ]
        local path := Main.CodeFolder . SubStr( name , 1 , StrLen( name ) - 3 ) "ahk"
        A_Clipboard := FileRead( path )
        TimedTips( "Bitmap code added to the clipboard" )
    }
    __New( Main ){
        Main.MainWindow.opt( "+Disabled" )
        This.Main               := Main
        This.Window             := Gui( "+AlwaysOnTop +Owner" This.Main.MainWindow.Hwnd , "Load Bitmap Panel")
        Main.WindowsList.LoadWindowHwnd     := This.Window.Hwnd 
        This.Window.MarginX     := 2
        This.Window.MarginY     := 2
        This.Window.BackColor   := "22262a"
        This.ControlIndex       := 0
        This.Controls           := {}
        This.ControlHandles     := {}
        This.Window.OnEvent( "Close" , This.GuiClose.Bind( This ) )        
        This.AddControls()
        This.Window.Show( "x" LoadBitmapPanel.WinVector.X " y" LoadBitmapPanel.WinVector.Y )
        WinWaitClose( "ahk_id " This.Window.Hwnd )
    }    
    AddControls(){
        This.Window.SetFont( "s" 12 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm ym w300 r1 Center 0x200 Background94771e c000000" , "Load Bitmap" )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w100 r1 Center 0x200 Background94771e c000000" , "Filter" )
        This.AddControl( "Edit" , "x+0 w200 hp Center -E0x200 Background463914 cFFFFFF" )
        This.Window.SetFont( "s" 12 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w300 r1 Center 0x200 Background94771e cFFFF00" , "Names List" )
        This.Window.SetFont( "s" 9 " Bold" , "Segoe UI" )
        This.AddControl( "Listbox" , "xm w300 r25 Center -E0x200 Background463914 cFFFF00 choose1" , This.Main.DataList , "BitmapListbox" )
        This.Window.SetFont( "s" 9 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm+3 w97 r1 0x200 Center BackgroundF6D572 c000000" , "Delete" ,, "Click" , This.DeleteBitmapFiles.Bind( This ) ) 
        This.AddControl( "Text" , "x+m w98 r1 0x200 Center BackgroundF6D572 c000000" , "Cancel" ,, "Click" , This.GuiClose.Bind( This ) ) 
        This.AddControl( "Text" , "x+m w97 r1 0x200 Center BackgroundF6D572 c000000" , "Load" , "load" , "Click" , This.LoadBitmap.Bind( This ) ) 
        This.AddControl( "Text" , "xm+3 w296 r1 0x200 Center BackgroundF6D572 c000000" , "Clipboard Bitmap Code" ,, "Click" , This.ClipboardBitmapCode.Bind( This ) ) 
    }
    AddControl( type := "Text" , options := "" , value := "" , name := "" , eventType := "" , eventBind := "" ){
        local cc := "" , hwnd 
        This.ControlIndex++
        if( value != "" ) 
            cc := This.Window.Add( type , options , value )
        else 
            cc := This.Window.Add( type , options )
        if( name = "" )
            name := type "_" This.ControlIndex
        cc.Name := name 
        cc.Index := This.ControlIndex
        hwnd := cc.Hwnd 
        This.ControlHandles.%hwnd% := cc 
        This.Controls.%Name% := cc
        if( eventType != "" && eventBind != "" )
            cc.OnEvent( eventType , eventBind )
    }

}

class SaveBitmapPanel extends DataClass  {

    static WinVector := Vector( 900 , 150 ) 

    GuiClose(*){
        local x := "" , y := ""
        This.Window.GetPos( &x , &y )
        SaveBitmapPanel.winVector := Vector( x , y )
        Main.MainWindow.opt( "-Disabled" )
        This.Window.Destroy()
    }
    SaveBitmap(*){
        local name := This.Controls.Name.Value
        local bitmap := Main.GetBitmap()
        if( bitmap.HasProp( "pBitmap" ) ){
            TimedTips( "You can't save the data for screencaps (yet)`nSave this as a `".PNG`"" )
            SoundBeep( 1212 , 120 )
            SoundBeep( 999 , 200 )
            return
        }
        if( name = "" ){
            TimedTips( "The bitmap needs a name to proceed." )
            SoundBeep( 555 , 50 )
            SoundBeep( 555 , 50 )
            return
        }
        if( !This.Controls.Overwrite.Value ){
            fileList := DataClass.GetSavedBitmapList( Main.DataFolder )
            if( fileList.Length ){                
                Loop( fileList.Length ){
                    if( fileList[ A_Index ] = name ".ini" ){
                        TimedTips( "That file name already exists." )
                        SoundBeep( 555 , 50 )
                        SoundBeep( 555 , 50 )
                        return
                    }
                }
            }
        }
        This.GuiClose()
        TimedTips( "Saving Bitmap" )
        bitmap := This.Bitmap.Clone()
        bitmap.Name := name
        This.WriteBitmapData( Main.DataFolder . name . ".ini" , bitmap )
        This.WriteBitmapCode( Main.CodeFolder . name . ".ahk" , bitmap )
        TimedTips( "Done" )
    }
    SavePNG(*){
        local bitmap := Main.GetBitmap()
        local outputBitmap := Gdip_CreateBitmap( bitmap.Rect.W * bitmap.Scale , bitmap.Rect.H * bitmap.Scale )
        local layers := Main.GetLayers()
        local pGraphics := Gdip_GraphicsFromImage( outputBitmap )
        TimedTips( "Saving..." )
        loop( layers.Length ){
            layer := layers[ A_Index ]
            if( layer.Elements.Length ){
                elements := layer.Elements
                layerX := layer.Rect.X
                layerY := layer.Rect.Y
                Loop( elements.Length ){
                    DrawClass.DrawElement( pGraphics , elements[ A_Index ] , bitmap.Scale , layerX , layerY )
                }
            }
        }
        Gdip_DeleteGraphics( pGraphics )
        ( nName := This.Controls.Name.Value ) || nName := bitmap.Name
        if( !This.Controls.Overwrite.Value && FileExist( Main.ScreenShotsFolder . nName . ".png" ) ){
            TimedTips( "That name has already been taken" )
            SoundBeep( 1212 , 120 )
            SoundBeep( 999 , 200 )
            return
        }
        Gdip_SaveBitmapToFile( outputBitmap , Main.ScreenShotsFolder . nName . ".png" , 100 )
        Gdip_DisposeImage( outputBitmap )
        TimedTips( "Done Saving." )
        This.GuiClose()
        return Main.ScreenShotsFolder . nName . ".png"
    }
    SavePNGAndClipboardPath(*){
        A_Clipboard := This.SavePNG()
    }
    __New( Main , bitmap ){
        Main.MainWindow.opt( "+Disabled" )
        This.Main               := Main
        This.Bitmap             := bitmap
        This.Window             := Gui( "+AlwaysOnTop +Owner" This.Main.MainWindow.Hwnd , "Save Bitmap Panel")
        Main.WindowsList.SaveWindowHwnd     := This.Window.Hwnd
        This.Window.MarginX     := 2
        This.Window.MarginY     := 2
        This.Window.BackColor   := "22262a"
        This.ControlIndex       := 0
        This.Controls           := {}
        This.ControlHandles     := {}
        This.Window.OnEvent( "Close" , This.GuiClose.Bind( This ) )        
        This.AddControls()
        This.Window.Show( "x" SaveBitmapPanel.WinVector.X " y" SaveBitmapPanel.WinVector.Y )
    }    
    AddControls(){
        This.Window.SetFont( "s" 12 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm ym w300 r1 Center 0x200 Backgroundaa0000 c000000" , "Save Bitmap" )
        This.Window.SetFont( "s" 10 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm w70 r1 0x200 Backgroundaa0000 c000000" , "   Name" )
        This.AddControl( "Edit" , "x+0 w230 hp Center -E0x200 Background440000 cFFFFFF" , This.Bitmap.Name , "Name" )
        This.Window.SetFont( "s" 9 " Bold" , "Segoe UI" )
        This.AddControl( "CheckBox" , "xm w100 r1 Background440000 cFFFFFF Right" , "Overwrite    " , "Overwrite" )
        This.Window.SetFont( "s" 9 " Bold" , "Segoe UI" )
        This.AddControl( "Text" , "xm+20 w260 r1 0x200 Center BackgroundF6D572 c000000" , "Save PNG" ,, "Click" , This.SavePNG.Bind( This ) )
        This.AddControl( "Text" , "xm+20 w260 r1 0x200 Center BackgroundF6D572 c000000" , "Save PNG and Clipboard Path" ,, "Click" , This.SavePNGAndClipboardPath.Bind( This ) ) 
        This.AddControl( "Text" , "xm+20 w260 r1 0x200 Center BackgroundF6D572 c000000" , "Save Bitmap with Normal Format" ,, "Click" , This.SaveBitmap.Bind( This ) ) 
        This.AddControl( "Text" , "xm+20 w260 r1 0x200 Center BackgroundF6D572 c000000" , "Cancel" ,, "Click" , This.GuiClose.Bind( This ) ) 
    }
    AddControl( type := "Text" , options := "" , value := "" , name := "" , eventType := "" , eventBind := "" ){
        local cc := "" , hwnd 
        This.ControlIndex++
        if( value != "" ) 
            cc := This.Window.Add( type , options , value )
        else 
            cc := This.Window.Add( type , options )
        if( name = "" )
            name := type "_" This.ControlIndex
        cc.Name := name 
        cc.Index := This.ControlIndex
        hwnd := cc.Hwnd 
        This.ControlHandles.%hwnd% := cc 
        This.Controls.%Name% := cc
        if( eventType != "" && eventBind != "" )
            cc.OnEvent( eventType , eventBind )
    }
}

class DrawClass {

    static DrawElement( pGraphics , elementObject , scale := 1 , layerX := 0 , layerY := 0 ){
        local elementType := elementObject.ElementType
        if( !elementObject.IsHidden )
            This.%ElementType%( pGraphics , elementObject , scale , layerX , layerY )
    }
    static FillRectangle( pGraphics , elementObject , scale := 1 , layerX := 0 , layerY := 0 ){
        local BrushType := elementObject.BrushObject.BrushType
        local pBrush := This.%BrushType%( elementObject.BrushObject )
        local rect := elementObject.Rect
        if( elementObject.Roundness )
            Gdip_FillRoundedRectangle( pGraphics , pBrush , ( rect.X + layerX ) * scale , ( rect.Y + layerY ) * scale , rect.W * scale , rect.H * scale , elementObject.Roundness * scale )
        else
            Gdip_FillRectangle( pGraphics , pBrush , ( rect.X + layerX ) * scale , ( rect.Y + layerY ) * scale , rect.W * scale , rect.H * scale )
        Gdip_DeleteBrush( pBrush )
    }
    static DrawText( pGraphics , elementObject , scale := 1 , layerX := 0 , layerY := 0 ){
        local BrushType := elementObject.BrushObject.BrushType
        local pBrush := This.%BrushType%( elementObject.BrushObject )
        local rect := elementObject.Rect
        local options := "s" elementObject.FontSize " c" pBrush 
        ( elementObject.Center = 0 ) || options .= " Center"
        ( elementObject.vCenter = 0 ) || options .= " vCenter"
        ( elementObject.Bold = 0 ) || options .= " Bold"
        ( elementObject.Underline = 0 ) || options .= " Underline"
        ( elementObject.NoWrap = 0 ) || options .= " NoWrap"
        ( elementObject.Strike = 0 ) || options .= " Strikeout"
        ( elementObject.Right = 0 ) || options .= " Right"
        ( elementObject.Italic = 0 ) || options .= " Italic"
        options .= " x" ( rect.X + layerX + elementObject.Offset ) * scale   
        options .= " y" ( rect.Y + layerY + elementObject.Offset ) * scale 
        if( elementObject.DebugMode ){
            deBugBrush := Gdip_BrushCreateSolid( "0xFFFF0000" )
            Gdip_FillRectangle( pGraphics , deBugBrush , rect.X * scale , rect.Y * scale , rect.W * scale , rect.H * scale )
            Gdip_DeleteBrush( deBugBrush )
        }
        Gdip_TextToGraphics( pGraphics , elementObject.Text , options , elementObject.FontType , rect.w * scale , rect.H * scale )
        Gdip_DeleteBrush( pBrush )
    }
    static DrawImage( pGraphics , elementObject , scale := 1 , layerX := 0 , layerY := 0 ){
        local rect := elementObject.Rect
        local sRect := elementObject.SourceRect
        local path := elementObject.Path
        if( !FileExist( path ) ){
            TimedTips( "ERROR`n`nNO FILE`n`nERROR")
            return
        }        
        Gdip_DrawImage( pGraphics , elementObject.ImageBitmap   , ( rect.X + layerX ) * scale 
                                                                , ( rect.Y + layerY ) * scale 
                                                                , rect.W * scale 
                                                                , rect.H * scale 
                                                                , sRect.X
                                                                , sRect.Y 
                                                                , sRect.W 
                                                                , sRect.H )        
    }
    static DrawRectangle( pGraphics , elementObject , scale := 1 , layerX := 0 , layerY := 0 ){
        local PenType := elementObject.BrushObject.BrushType
        local pPen := This.%PenType%( elementObject.BrushObject , isPen := 1 , PenThickness := elementObject.Thickness )
        local rect := elementObject.Rect
        if( elementObject.Roundness )
            Gdip_DrawRoundedRectangle( pGraphics , pPen , ( rect.X + layerX ) * scale , ( rect.Y + layerY ) * scale , rect.W * scale , rect.H * scale , elementObject.Roundness * scale )
        else
            Gdip_DrawRectangle( pGraphics , pPen , ( rect.X + layerX ) * scale , ( rect.Y + layerY ) * scale , rect.W * scale , rect.H * scale )
        Gdip_DeletePen( pPen )
    }
    static FillEllipse( pGraphics , elementObject , scale := 1 , layerX := 0 , layerY := 0 ){
        local BrushType := elementObject.BrushObject.BrushType
        local pBrush := This.%BrushType%( elementObject.BrushObject )
        local rect := elementObject.Rect
        Gdip_FillEllipse( pGraphics , pBrush , ( rect.X + layerX ) * scale , ( rect.Y + layerY ) * scale , rect.W * scale , rect.H * scale )
        Gdip_DeleteBrush( pBrush )
    }
    static SolidBrush( brushObject , isPen := 0 , PenThickness := 3 ){
        if( isPen )
            return Gdip_CreatePen( brushObject.Color1 , PenThickness )
        return Gdip_BrushCreateSolid( brushObject.Color1 )
    }
    static HatchBrush( brushObject , isPen := 0 , PenThickness := 3 ){
        pBrush := Gdip_BrushCreateHatch( brushObject.Color1 , brushObject.Color2 , brushObject.HatchValue )
        local pPen := ""
        if( isPen ){            
            pPen := Gdip_CreatePenFromBrush( pBrush , PenThickness )
            Gdip_DeleteBrush( pBrush )
            return pPen
        }
        return pBrush
    }
    static GradientBrush( brushObject , isPen := 0 , PenThickness := 3 ){
        local pBrush := Gdip_CreateLineBrushFromRect( brushObject.Rect.x , brushObject.Rect.y, brushObject.Rect.w, brushObject.Rect.h, brushObject.Color1 , brushObject.Color2 , brushObject.LinearGradientMode , brushObject.GradientBrushWrapMode )
        local pPen := ""
        if( isPen ){
            pPen := Gdip_CreatePenFromBrush( pBrush , PenThickness )
            Gdip_DeleteBrush( pBrush )
            return pPen
        }
        return pBrush
    }
    static LineBrush( brushObject , isPen := 0 , PenThickness := 3 ){
        local pBrush := Gdip_CreateLineBrush( brushObject.Rect.x , brushObject.Rect.y , brushObject.Rect.w , brushObject.Rect.h , brushObject.Color1 , brushObject.Color2 , brushObject.LineBrushWrapMode )
        local pPen := ""
        if( isPen ){
            pPen := Gdip_CreatePenFromBrush( pBrush , PenThickness )
            Gdip_DeleteBrush( pBrush )
            return pPen
        }
        return pBrush 
    }
}

class DataClass {
    static BitmapKeyList := "Name|Rect|Smoothing|InterpolationMode|NumberOfLayers|IsHidden|Note|Scale"
    static LayerKeyList := "Name|Rect|Smoothing|InterpolationMode|NumberOfElements|IsHidden|Note"
    static FillRectangleKeyList := "ElementType|Rect|Roundness|Note|BrushObject"
    static DrawTextKeyList := "Rect|Text|FontSize|Italic|FontType|Right|NoWrap|Strike|Bold|Underline|DebugMode|Center|vCenter|Offset|Note|BrushObject|IsHidden"
    static DrawImageKeyList := "Rect|SourceRect|Path|Note|IsHidden"
    static FillEllipseKeyList := "Rect|Path|Note|IsHidden"
    
    static GetSavedBitmapList( path ){
        local bitmapList := []
        loop files path "*.ini" 
        {
            bitmapList.Push( A_LoopFileName )
        }
        return bitmapList
    }
    WriteBitmapCode( path , bitmap ){
        local output := ""        
        if( FileExist( path ) )
            FileDelete( path )
        semi := ";"
        output .= ";******************************************************************************************************`n"
        output .= "; #Include <GDIP_ALL V2> " semi "https://raw.githubusercontent.com/buliasz/AHKv2-Gdip/master/Gdip_All.ahk`n"
        output .= "; #Include <PopUpWindow v4_1> " semi "https://www.autohotkey.com/boards/viewtopic.php?f=83&t=132744&p=583099#p583097`n"
        output .= "; #Include <HB Vectors v3> " semi "https://www.autohotkey.com/boards/viewtopic.php?f=83&t=132770&p=583213#p583213`n"
        output .= "; pToken := Gdip_Startup()`n"        
        output .= ";**************************************( " bitmap.Name " )*********************************************`n"
        output .= StrReplace( bitmap.Name , " " ) "Function( Scale := " bitmap.Scale " , returnType := `"pBitmap`" ){`n`t"
        output .= "local pBitmap := Gdip_CreateBitmap( " bitmap.Rect.W " * Scale , " bitmap.Rect.H " * Scale )`n`t"
        output .= "local pGraphics := Gdip_GraphicsFromImage( pBitmap )`n`t"
        output .= "local Elements := []`n`t"
        layers := bitmap.Layers
        index := 0
        Loop( layers.Length ){
            layer := layers[ A_Index ]
            layerX := layer.Rect.X
            layerY := layer.Rect.Y
            layerIndex := A_Index 
            if( layer.Elements.Length ){
                Loop( layer.Elements.Length ){
                    element := layer.Elements[ A_Index ]
                    elementType := element.ElementType
                    output .= WriteElements.Write%elementType%Object( element , ++index , layerIndex , layer.smoothing , layer.interpolationMode , layerX , layerY ) "`n`t"
                }
            }
        }
        index := 0
        Loop( layers.Length ){
            layer := Layers[ A_Index ]
            output .= ";Layer: " A_Index "`n`t"
            output .= "Gdip_SetSmoothingMode( pGraphics , " layer.Smoothing " ) , "
            output .= "Gdip_SetInterpolationMode( pGraphics , " layer.InterpolationMode " )`n`t"
            output .= "LayerX := `"`"`n`t"
            if( layer.Elements.Length ){
                Loop( layer.Elements.Length ){
                    element := layer.Elements[ A_Index ]
                    index++
                    switch element.ElementType , "off" {
                        case "FillRectangle":                                
                            output .= "element := Elements[ " index " ] , Brush := element.BrushObject`n`t"
                            output .= WriteElements.WriteFillRectangleCode( element , index ) 
                        case "DrawText":                                
                            output .= "element := Elements[ " index " ] , Brush := element.BrushObject`n`t"
                            output .= WriteElements.WriteDrawTextCode( element , index ) 
                        case "DrawImage":                                
                            output .= "element := Elements[ " index " ] `n`t"
                            output .= WriteElements.WriteDrawImageCode( element , index )  
                        case "DrawRectangle":
                            output .= "element := Elements[ " index " ] , Brush := element.BrushObject`n`t"
                            output .= WriteElements.WriteDrawRectangleCode( element , index )    
                        default:                                
                    }
                }
            }
        }
        output .= "Gdip_DeleteGraphics( pGraphics )`n`t"
        output .= "if( returnType = `"hBitmap`" ){`n`t`t"
        output .= "hBitmap := Gdip_CreateHBITMAPFromBitmap( pBitmap )`n`t`t"
        output .= "Gdip_DisposeImage( pBitmap )`n`t`t"
        output .= "return hBitmap`n`t"
        output .= "}`n`t"
        output .= "return pBitmap`n"
        output .= "}`n"
        output .= ";******************************************************************************************************`n"
        FileAppend( output , path )
        TimedTips( "Added to clipboard" )
        A_Clipboard := output
    }
    WriteBitmapData( path , bitmap ){
        if( FileExist( path ) ){
            FileDelete( path )
        }
        for k , v in StrSplit( DataClass.BitmapKeyList , "|" )  {
            if( v = "Rect" ){
                IniWrite( Vector.RectToString( bitmap.Rect ) , path , "Bitmap Data" , v  )
            }else if( v = "NumberOfLayers" ){
                IniWrite( bitmap.Layers.Length , path , "Bitmap Data" , v  )
            }else If( v = "Note" ){
                output := StrReplace( bitmap.%v% , "`n" , "[*N*]" )
                IniWrite( output , path , "Bitmap Data" , v  )
            }else{
                IniWrite( bitmap.%v% , path , "Bitmap Data" , v  )
            }
        }
        Loop( bitmap.Layers.Length ){
            This.WriteLayerData( path , bitmap.Layers[ A_Index ] , A_Index )
        }        
    }
    ReadBitmapData( path ){
        local bitmap := {}
        for k , v in StrSplit( DataClass.BitmapKeyList , "|" )  {
            if( v = "Rect" ){
                rect := IniRead( path , "Bitmap Data" , v )
                bitmap.Rect := Vector.StringToRect( rect )
            }else if( v = "NumberOfLayers" ){
                NumberOfLayers := IniRead( path , "Bitmap Data" , v  )
            }else If( v = "Note" ){
                bitmap.%v% := StrReplace( IniRead( path , "Bitmap Data" , v , "" ) , "[*N*]" , "`n" )
            }else{
                bitmap.%v% := IniRead( path , "Bitmap Data" , v , "" )
            }
        }
        Bitmap.Layers := []
        Loop( NumberOfLayers ){
            Bitmap.Layers.Push( {} )
            layer := Bitmap.Layers[ A_Index ]
            This.ReadLayerData( path , bitmap , layer , A_Index )
        }
        return bitmap
    }
    WriteLayerData( path , layer , Index  ){
        for k , v in StrSplit( DataClass.LayerKeyList , "|" )  {
            if( v = "Rect" ){
                IniWrite( Vector.RectToString( layer.Rect ) , path , "Layer " Index " Data" , v  )
            }else if( v = "NumberOfElements" ){
                IniWrite( layer.Elements.Length , path , "Layer " Index " Data" , v  )
            }else If( v = "Note" ){
                IniWrite( StrReplace( layer.%v% , "`n" , "[*N*]" ) , path , "Layer " Index " Data" , v  )
            }else{
                IniWrite( layer.%v% , path , "Layer " Index " Data" , v  )
            }
        }
        Loop( layer.Elements.Length ){
            This.WriteElementData( path , layer , Index , layer.Elements[ A_Index ] , A_Index )
        }
    }
    ReadLayerData( path , bitmap , layer , layerIndex ){
        for k , v in StrSplit( DataClass.LayerKeyList , "|" )  {
            if( v = "Rect" ){
                rect := IniRead( path , "Layer " layerIndex " Data" , v )
                layer.Rect := Vector.StringToRect( rect )
            }else if( v = "NumberOfElements" ){
                NumberOfElements := IniRead( path , "Layer " layerIndex " Data" , v  )
            }else If( v = "Note" ){
                layer.%v% := StrReplace( IniRead( path , "Layer " layerIndex " Data" , v , "" ) , "[*N*]" , "`n" )
            }else{
                layer.%v% := IniRead( path , "Layer " layerIndex " Data" , v , "" )
            }
        }
        layer.Elements := []
        Loop( NumberOfElements ){
            layer.Elements.Push( {} )
            element := layer.Elements[ A_Index ]
            This.ReadElementData( path , layerIndex , element , A_Index )
        }
    }
    ;***************************************
    WriteElementData( path , layer , layerIndex , element , elementIndex ){
        local elementType := element.ElementType
        local brushType := "" 
        This.Write%elementType%Data( path , layer , layerIndex , element , elementIndex )
        if( element.HasProp( "BrushObject" ) ){
            brushType := element.BrushObject.BrushType
            This.Write%brushType%Data(  path , layer , layerIndex , element.BrushObject , elementIndex )
        }        
    }
    ;***************************************
    WriteFillRectangleData( path , layer , layerIndex , element , elementIndex ){
        local FillRectangleKeyList := "ElementType|Rect|IsHidden|Note|Roundness"
        local elementType := element.ElementType
        for k , v in StrSplit( FillRectangleKeyList , "|" ){
            if( v = "Rect" ){
                IniWrite( Vector.RectToString( element.Rect ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v )
            }else if( v = "Note" ){
                IniWrite( StrReplace( element.%v% , "`n" , "[*N*]" ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v  )
            }else{
                IniWrite( element.%v% , path , "Layer " layerIndex " Element " elementIndex " Data" , v  )
            }
        }
    }
    WriteDrawTextData( path , layer , layerIndex , element , elementIndex ){
        local DrawTextKeyList := "ElementType|Rect|Text|FontSize|Italic|FontType|Right|NoWrap|Strike|Bold|Underline|DebugMode|Center|vCenter|Offset|Note|IsHidden"    
        local elementType := element.ElementType
        for k , v in StrSplit( DrawTextKeyList , "|" ){
            if( v = "Rect" ){
                IniWrite( Vector.RectToString( element.Rect ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v )
            }else if( v = "Note" || v = "Text" ){
                IniWrite( StrReplace( element.%v% , "`n" , "[*N*]" ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v  )
            }else{
                IniWrite( element.%v% , path , "Layer " layerIndex " Element " elementIndex " Data" , v  )
            }
        }
    }
    WriteDrawImageData( path , layer , layerIndex , element , elementIndex ){
        local DrawImageKeyList := "ElementType|Rect|SourceRect|Path|Note|IsHidden"    
        local elementType := element.ElementType
        for k , v in StrSplit( DrawImageKeyList , "|" ){
            if( v = "Rect" ){
                IniWrite( Vector.RectToString( element.Rect ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v )
            }else if( v = "Note" ){
                IniWrite( StrReplace( element.%v% , "`n" , "[*N*]" ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v  )
            }else if( v = "SourceRect" ){
                IniWrite( Vector.RectToString( element.SourceRect ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v )
            }else{
                IniWrite( element.%v% , path , "Layer " layerIndex " Element " elementIndex " Data" , v  )
            }
        }
    }
    WriteDrawRectangleData( path , layer , layerIndex , element , elementIndex ){
        local DrawRectangleKeyList := "ElementType|Rect|Roundness|Thickness|IsHidden|Note"
        local elementType := element.ElementType
        for k , v in StrSplit( DrawRectangleKeyList , "|" ){
            if( v = "Rect" ){
                IniWrite( Vector.RectToString( element.Rect ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v )
            }else if( v = "Note" ){
                IniWrite( StrReplace( element.%v% , "`n" , "[*N*]" ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v  )
            }else{
                IniWrite( element.%v% , path , "Layer " layerIndex " Element " elementIndex " Data" , v  )
            }
        }
    }
    WriteFillEllipseData( path , layer , layerIndex , element , elementIndex ){
        local FillEllipseKeyList := "ElementType|Rect|IsHidden|Note"
        local elementType := element.ElementType
        for k , v in StrSplit( FillEllipseKeyList , "|" ){
            if( v = "Rect" ){
                IniWrite( Vector.RectToString( element.Rect ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v )
            }else if( v = "Note" ){
                IniWrite( StrReplace( element.%v% , "`n" , "[*N*]" ) , path , "Layer " layerIndex " Element " elementIndex " Data" , v  )
            }else{
                IniWrite( element.%v% , path , "Layer " layerIndex " Element " elementIndex " Data" , v  )
            }
        }
    }
    ;***************************************
    WriteSolidBrushData(  path , layer , layerIndex , BrushObject , elementIndex ){
        IniWrite( BrushObject.BrushType , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "BrushType" )
        IniWrite( BrushObject.Color1 , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "Color1" )
    }
    WriteHatchBrushData(  path , layer , layerIndex , BrushObject , elementIndex ){
        IniWrite( BrushObject.BrushType , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "BrushType" )
        IniWrite( BrushObject.Color1 , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "Color1" )
        IniWrite( BrushObject.Color2 , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "Color2" )
        IniWrite( BrushObject.HatchValue , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "HatchValue" )
    }
    WriteGradientBrushData(  path , layer , layerIndex , BrushObject , elementIndex ){
        IniWrite( BrushObject.BrushType , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "BrushType" )
        IniWrite( BrushObject.Color1 , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "Color1" )
        IniWrite( BrushObject.Color2 , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "Color2" )
        IniWrite( Vector.RectToString( BrushObject.Rect ) , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "Rect" )
        IniWrite( BrushObject.LinearGradientMode , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "LinearGradientMode" )
        IniWrite( BrushObject.GradientBrushWrapMode , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "GradientBrushWrapMode" )
    }
    WriteLineBrushData(  path , layer , layerIndex , BrushObject , elementIndex ){
        IniWrite( BrushObject.BrushType , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "BrushType" )
        IniWrite( BrushObject.Color1 , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "Color1" )
        IniWrite( BrushObject.Color2 , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "Color2" )
        IniWrite( Vector.RectToString( BrushObject.Rect ) , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "Rect" )
        IniWrite( BrushObject.LineBrushWrapMode , path , "Layer " layerIndex " Element " elementIndex " Brush Data" , "LineBrushWrapMode" )
    }
    ;***************************************
    ReadElementData( path , layerIndex , element , elementIndex ){
        local elementType := "" 
        element.ElementType := elementType := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , "ElementType" )
        This.Read%elementType%Data( path , layerIndex , element , elementIndex )
    }
    ;***************************************
    ReadFillRectangleData( path , layerIndex , element , elementIndex ){
        local FillRectangleKeyList := "ElementType|Rect|IsHidden|Note|Roundness"
        local rect := "" , k := "" , v := ""
        for k , v in StrSplit( FillRectangleKeyList , "|" ){
            if( v = "Rect" ){
                rect := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
                element.Rect := Vector.StringToRect( rect )
            }else if( v = "Note" ){
                element.%v% := StrReplace( IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v ) , "[*N*]" , "`n" )
            }else{
                element.%v% := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
            }
        }
        element.BrushObject := {}
        element.BrushObject.BrushType := BrushType := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "BrushType" )
        This.Read%BrushType%Data( path , layerIndex , element.BrushObject , elementIndex )
    }
    ReadDrawTextData( path , layerIndex , element , elementIndex ){
        local DrawTextKeyList := "ElementType|Rect|Text|FontSize|Italic|FontType|Right|NoWrap|Strike|Bold|Underline|DebugMode|Center|vCenter|Offset|Note|IsHidden"
        local rect := "" , k := "" , v := ""
        for k , v in StrSplit( DrawTextKeyList , "|" ){
            if( v = "Rect" ){
                rect := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
                element.Rect := Vector.StringToRect( rect )
            }else if( v = "Note" || v = "Text" ){
                element.%v% := StrReplace( IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v ) , "[*N*]" , "`n" )
            }else{
                element.%v% := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
            }
        }
        element.BrushObject := {}
        element.BrushObject.BrushType := BrushType := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "BrushType" )
        This.Read%BrushType%Data( path , layerIndex , element.BrushObject , elementIndex )
    }
    ReadDrawImageData( path , layerIndex , element , elementIndex ){
        local DrawImageKeyList := "ElementType|Rect|SourceRect|Path|Note|IsHidden"
        local rect := "" , k := "" , v := ""
        for k , v in StrSplit( DrawImageKeyList , "|" ){
            if( v = "Rect" ){
                rect := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
                element.Rect := Vector.StringToRect( rect )
            }else if( v = "Note" || v = "Text" ){
                element.%v% := StrReplace( IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v ) , "[*N*]" , "`n" )
            }else if( v = "SourceRect" ){
                rect := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
                element.SourceRect := Vector.StringToRect( rect )
            }else{
                element.%v% := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
            }
        }
    }
    ReadDrawRectangleData( path , layerIndex , element , elementIndex ){
        local DrawRectangleKeyList := "ElementType|Rect|Roundness|Thickness|IsHidden|Note"
        local rect := "" , k := "" , v := ""
        for k , v in StrSplit( DrawRectangleKeyList , "|" ){
            if( v = "Rect" ){
                rect := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
                element.Rect := Vector.StringToRect( rect )
            }else if( v = "Note" ){
                element.%v% := StrReplace( IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v ) , "[*N*]" , "`n" )
            }else{
                element.%v% := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
            }
        }
        element.BrushObject := {}
        element.BrushObject.BrushType := BrushType := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "BrushType" )
        This.Read%BrushType%Data( path , layerIndex , element.BrushObject , elementIndex )
    }
    ReadFillEllipseData( path , layerIndex , element , elementIndex ){
        local FillEllipseKeyList := "ElementType|Rect|IsHidden|Note"
        local rect := "" , k := "" , v := ""
        for k , v in StrSplit( FillEllipseKeyList , "|" ){
            if( v = "Rect" ){
                rect := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
                element.Rect := Vector.StringToRect( rect )
            }else if( v = "Note" ){
                element.%v% := StrReplace( IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v ) , "[*N*]" , "`n" )
            }else{
                element.%v% := IniRead( path , "Layer " layerIndex " Element " elementIndex " Data"  , v )
            }
        }
        element.BrushObject := {}
        element.BrushObject.BrushType := BrushType := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "BrushType" )
        This.Read%BrushType%Data( path , layerIndex , element.BrushObject , elementIndex )
    }
    ;***************************************
    ReadSolidBrushData( path , layerIndex , BrushObject , elementIndex ){
        BrushObject.Color1 := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "Color1" )
    }
    ReadHatchBrushData( path , layerIndex , BrushObject , elementIndex ){
        BrushObject.Color1 := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "Color1" )
        BrushObject.Color2 := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "Color2" )
        BrushObject.HatchValue := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "HatchValue" )
    }
    ReadGradientBrushData( path , layerIndex , BrushObject , elementIndex ){
        BrushObject.Color1 := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "Color1" )
        BrushObject.Color2 := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "Color2" )
        rect := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "Rect" )
        BrushObject.Rect := Vector.StringToRect( rect )
        BrushObject.LinearGradientMode := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "LinearGradientMode" )
        BrushObject.GradientBrushWrapMode := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "GradientBrushWrapMode" )
    }
    ReadLineBrushData( path , layerIndex , BrushObject , elementIndex ){
        BrushObject.Color1 := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "Color1" )
        BrushObject.Color2 := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "Color2" )
        rect := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "Rect" )
        BrushObject.Rect := Vector.StringToRect( rect )
        BrushObject.LineBrushWrapMode := IniRead( path , "Layer " layerIndex " Element " elementIndex " Brush Data"  , "LineBrushWrapMode" )
    }   
    ;*************************************** 
}

class WriteElements {

    static WriteFillRectangleObject( element , elementIndex , layerIndex , smoothing , interpolationMode , layerX := 0 , layerY := 0 ){
        local quote := "`""
        local brush := element.BrushObject
        local brushType := brush.BrushType
        local output := "Elements.Push( { "
        output .= "Index: " elementIndex " , Layer: " layerIndex " , "
        output .= "ElementType: `"FillRectangle`" , "
        output .= "Rect: { X: " element.Rect.X " + " layerX " , Y: " element.Rect.Y " + " layerY " , W: " element.Rect.W " , H: " element.Rect.H " } , " 
        output .= "Roundness: " element.Roundness " , "  
        output .= "Note: `""  element.Note "`" , " 
        output .= "BrushObject: { BrushType: `"" brushType "`" , " 
        output .= This.Write%brushType%Object( brush )                
        return output
    }
    static WriteDrawTextObject( element , elementIndex , layerIndex , smoothing , interpolationMode , layerX := 0 , layerY := 0 ){
        local quote := "`""
        local brush := element.BrushObject
        local brushType := brush.BrushType
        local output := "Elements.Push( { "
        output .= "Index: " elementIndex " , Layer: " layerIndex " , "
        output .= "ElementType: `"DrawText`" , "
        output .= "Rect: { X: " element.Rect.X " + " layerX " , Y: " element.Rect.Y " + " layerY " , W: " element.Rect.W " , H: " element.Rect.H " } , " 
        output .= "Text: `"" StrReplace( element.Text , "`n" , "``n" ) "`" , "  
        output .= "FontType: `"" element.FontType "`" , " 
        output .= "FontSize: " element.FontSize " , "  
        output .= "Center: " element.Center " , "  
        output .= "vCenter: " element.vCenter " , "  
        output .= "Offset: " element.Offset " , "  
        output .= "Bold: " element.Bold " , "  
        output .= "italic: " element.Italic " , "  
        output .= "underline: " element.Underline " , "  
        output .= "Right: " element.Right " , "  
        output .= "NoWrap: " element.NoWrap " , "  
        output .= "Strike: " element.Strike " , "  
        output .= "Note: `""  element.Note "`" , " 
        output .= "BrushObject: { BrushType: `"" brushType "`" , " 
        output .= This.Write%brushType%Object( brush )                
        return output
    }
    static WriteDrawImageObject( element , elementIndex , layerIndex , smoothing , interpolationMode , layerX := 0 , layerY := 0 ){
        local quote := "`""
        local output := "Elements.Push( { "
        output .= "Index: " elementIndex " , Layer: " layerIndex " , "
        output .= "ElementType: `"DrawImage`" , "
        output .= "Rect: { X: " element.Rect.X " + " layerX " , Y: " element.Rect.Y " + " layerY " , W: " element.Rect.W " , H: " element.Rect.H " } , " 
        output .= "SourceRect: { X: " element.SourceRect.X " + " layerX " , Y: " element.SourceRect.Y " + " layerY " , W: " element.SourceRect.W " , H: " element.SourceRect.H " } , " 
        output .= "Path: `"" element.Path "`" , " 
        output .= "Note: `""  element.Note "`" } )"  
        return output
    }
    static WriteDrawRectangleObject( element , elementIndex , layerIndex , smoothing , interpolationMode , layerX := 0 , layerY := 0 ){
        local quote := "`""
        local brush := element.BrushObject
        local brushType := brush.BrushType
        local output := "Elements.Push( { "
        output .= "Index: " elementIndex " , Layer: " layerIndex " , "
        output .= "ElementType: `"DrawRectangle`" , "
        output .= "Rect: { X: " element.Rect.X " + " layerX " , Y: " element.Rect.Y " + " layerY " , W: " element.Rect.W " , H: " element.Rect.H " } , " 
        output .= "Roundness: " element.Roundness " , "  
        output .= "Thickness: " element.Thickness " , "  
        output .= "Note: `""  element.Note "`" , " 
        output .= "BrushObject: { BrushType: `"" brushType "`" , " 
        output .= This.Write%brushType%Object( brush )                
        return output
    }
    static WriteFillEllipseObject( element , elementIndex , layerIndex , smoothing , interpolationMode , layerX := 0 , layerY := 0 ){
        local quote := "`""
        local brush := element.BrushObject
        local brushType := brush.BrushType
        local output := "Elements.Push( { "
        output .= "Index: " elementIndex " , Layer: " layerIndex " , "
        output .= "ElementType: `"FillEllipse`" , "
        output .= "Rect: { X: " element.Rect.X " + " layerX " , Y: " element.Rect.Y " + " layerY " , W: " element.Rect.W " , H: " element.Rect.H " } , " 
        output .= "Note: `""  element.Note "`" , " 
        output .= "BrushObject: { BrushType: `"" brushType "`" , " 
        output .= This.Write%brushType%Object( brush )                
        return output
    }
    static WriteSolidBrushObject( brush ){
        return " Color1: `"" brush.Color1 "`" } } )"
    }
    static WriteHatchBrushObject( brush ){
        local output := ""
        output .= " Color1: `"" brush.Color1 "`" "
        output .= ", Color2: `"" brush.Color2 "`" "
        output .= ", HatchValue: `"" brush.HatchValue "`" } } )"
        return output
    }
    static WriteGradientBrushObject( brush ){
        local output := "" , rect := brush.Rect
        output .= " Rect: { X: " rect.X " , Y: " rect.Y " , W: " rect.W " , H: " rect.H " } "
        output .= ", Color1: `"" brush.Color1 "`" "
        output .= ", Color2: `"" brush.Color2 "`" "
        output .= ", LinearGradientMode: `"" brush.LinearGradientMode "`" "
        output .= ", GradientBrushWrapMode: `"" brush.GradientBrushWrapMode "`" } } )"
        return output
    }
    static WriteLineBrushObject( brush ){
        local output := "" , rect := brush.Rect
        output .= " Rect: { X: " rect.X " , Y: " rect.Y " , W: " rect.W " , H: " rect.H " } "
        output .= ", Color1: `"" brush.Color1 "`" "
        output .= ", Color2: `"" brush.Color2 "`" "
        output .= ", LineBrushWrapMode: `"" brush.LineBrushWrapMode "`" } } )"
        return output
    }
    ;*************************************************************
    static WriteFillRectangleCode( element , index  ){
        local output := ""
        local brushType := element.BrushObject.BrushType        
        local rect := element.Rect
        if( element.Note != "" )
            output .= ";" element.Note "`n`t"
        output .= This.Write%brushType%Code( element ) "`n`t"
        if( element.RoundNess )
            output .= "Gdip_FillRoundedRectangle( pGraphics , pBrush , ( element.Rect.X ) * scale , ( element.Rect.Y ) * scale , ( element.Rect.W ) * scale , ( element.Rect.H ) * scale , element.Roundness * scale )`n`t"
        else 
            output .= "Gdip_FillRectangle( pGraphics , pBrush , ( element.Rect.X ) * scale , ( element.Rect.Y ) * scale , ( element.Rect.W ) * scale , ( element.Rect.H ) * scale )`n`t"
        output .= "Gdip_DeleteBrush( pBrush )`n`t"
        return output
    }
    static WriteDrawRectangleCode( element , index  ){
        local output := ""
        local brushType := element.BrushObject.BrushType        
        local rect := element.Rect
        if( element.Note != "" )
            output .= ";" element.Note "`n`t"
        output .= This.Write%brushType%Code( element , isPen := 1 ) "`n`t"
        if( element.RoundNess )
            output .= "Gdip_DrawRoundedRectangle( pGraphics , pPen , ( element.Rect.X ) * scale , ( element.Rect.Y ) * scale , ( element.Rect.W ) * scale , ( element.Rect.H ) * scale , element.Roundness * scale )`n`t"
        else 
            output .= "Gdip_DrawRectangle( pGraphics , pPen , ( element.Rect.X ) * scale , ( element.Rect.Y ) * scale , ( element.Rect.W ) * scale , ( element.Rect.H ) * scale )`n`t"
        
        output .= "Gdip_DeletePen( pPen )`n`t"
        return output
    }
    static WriteDrawTextCode( element , index  ){
        local output := ""
        local brushType := element.BrushObject.BrushType        
        local rect := element.Rect
        if( element.Note != "" )
            output .= ";" element.Note "`n`t"
        output .= This.Write%brushType%Code( element ) "`n`t"
        output .= "options := `"s`" element.FontSize `" c`" pBrush `" x`" ( element.Rect.X ) * scale `" y`" ( element.Rect.Y ) * scale `n`t" 
        output .= "options .= ( ( element.Center ) ? ( `" Center`" ) : ( `"`" ) ) ( ( element.vCenter ) ? ( `" vCenter`" ) : ( `"`" ) ) ( ( element.Bold ) ? ( `" Bold`" ) : ( `"`" ) ) `n`t"
        output .= "options .= ( ( element.Italic ) ? ( `" Italic`" ) : ( `"`" ) ) ( ( element.Right ) ? ( `" Right`" ) : ( `"`" ) ) ( ( element.Strike ) ? ( `" Strikeout`" ) : ( `"`" ) ) `n`t"
        output .= "options .= ( ( element.Underline ) ? ( `" underline`" ) : ( `"`" ) ) ( ( element.NoWrap ) ? ( `" NoWrap`" ) : ( `"`" ) ) `n`t"
        output .= "Gdip_TextToGraphics( pGraphics , element.Text  , options , element.FontType , ( element.Rect.W ) * scale , ( element.Rect.H ) * scale )`n`t"
        output .= "Gdip_DeleteBrush( pBrush )`n`t"
        return output
    }
    static WriteDrawImageCode( element , index  ){
        local output := ""       
        if( element.Note != "" )
            output .= ";" element.Note "`n`t"
        output .= "rect := element.Rect `n`t"
        output .= "sRect := element.SourceRect `n`t"
        output .= "ImageBitmap := Gdip_CreateBitmapFromFile( element.Path ) `n`t"
        output .= "Gdip_DrawImage( pGraphics , ImageBitmap , ( rect.X ) * Scale , ( rect.Y ) * Scale , ( rect.W ) * Scale , ( rect.H ) * Scale , ( sRect.X ) , ( sRect.Y ) , ( sRect.W ) , ( sRect.H ) )`n`t"
        output .= "Gdip_DisposeImage( ImageBitmap )`n`t"
        return output
    }
    static WriteFillEllipseCode( element , index  ){
        local output := ""
        local brushType := element.BrushObject.BrushType        
        local rect := element.Rect
        if( element.Note != "" )
            output .= ";" element.Note "`n`t"
        output .= This.Write%brushType%Code( element ) "`n`t"
        output .= "Gdip_FillEllipse( pGraphics , pBrush , ( element.Rect.X ) * scale , ( element.Rect.Y ) * scale , ( element.Rect.W ) * scale , ( element.Rect.H ) * scale )`n`t"
        output .= "Gdip_DeleteBrush( pBrush )`n`t"
        return output
    }
    static WriteSolidBrushCode( element , isPen := 0 ){
        if( isPen )            
            return "pPen := Gdip_CreatePen( Brush.Color1 , element.Thickness )"        
        return "pBrush := Gdip_BrushCreateSolid( Brush.Color1 )"
    }
    static WriteHatchBrushCode( element , isPen := 0 ){
        local output := ""
        if( isPen ){
            output .= "pBrush := Gdip_BrushCreateHatch( Brush.Color1 , Brush.Color2 , Brush.HatchValue )"
            output .= " , pPen := Gdip_CreatePenFromBrush( pBrush , element.Thickness )"
            output .= " , Gdip_DeleteBrush( pBrush )"
            return output
        }
        return "pBrush := Gdip_BrushCreateHatch( Brush.Color1 , Brush.Color2 , Brush.HatchValue )"
    }
    static WriteGradientBrushCode( element , isPen := 0 ){
        local output := ""
        if( isPen ){
            output .= "pBrush := Gdip_CreateLineBrushFromRect( Brush.Rect.X , Brush.Rect.Y , Brush.Rect.W , Brush.Rect.H , Brush.Color1 , Brush.Color2 , Brush.LinearGradientMode , Brush.GradientBrushWrapMode )"
            output .= " , pPen := Gdip_CreatePenFromBrush( pBrush , element.Thickness )"
            output .= " , Gdip_DeleteBrush( pBrush )"
            return output
        }
        return "pBrush := Gdip_CreateLineBrushFromRect( Brush.Rect.X , Brush.Rect.Y , Brush.Rect.W , Brush.Rect.H , Brush.Color1 , Brush.Color2 , Brush.LinearGradientMode , Brush.GradientBrushWrapMode )"
    }
    static WriteLineBrushCode( element , isPen := 0 ){
        local output := ""
        if( isPen ){
            output .= "pBrush := Gdip_CreateLineBrush( Brush.Rect.X , Brush.Rect.Y , Brush.Rect.W , Brush.Rect.H , Brush.Color1 , Brush.Color2 , Brush.LineBrushWrapMode )"
            output .= " , pPen := Gdip_CreatePenFromBrush( pBrush , element.Thickness )"
            output .= " , Gdip_DeleteBrush( pBrush )"
            return output
        }
        return "pBrush := Gdip_CreateLineBrush( Brush.Rect.X , Brush.Rect.Y , Brush.Rect.W , Brush.Rect.H , Brush.Color1 , Brush.Color2 , Brush.LineBrushWrapMode )"
    }

}

class ScreenCapClass {

    static TakeScreenCap( type := "Normal" ){
        local v := ""
        local v2 := ""
        This.Window := PopupWindow_v4( { W: 801 , H: 801 , Options: "+AlwaysOnTop -DPIScale +ToolWindow E0x20" } )
        Brush := Gdip_BrushCreateSolid( "0xFFFF0000" )
        Gdip_FillRectangle( This.Window.G , brush , 400 , 0 , 1 , 801 )
        Gdip_FillRectangle( This.Window.G , brush , 0 , 400 , 801 , 1 )
        Gdip_DeleteBrush( Brush )
        This.Window.Update()
        While( !GetKeyState( "Shift" ) ){
            if( GetKeyState( "Ctrl" ) ){
                TimedTips( "ScreenShot Canceled" )
                This.Window.Destroy()
                return 0
            }
            mv := Vector.MouseVector()
            mv.Sub( 400 )
            This.Window.Resize( 1 , mv )
            if( !Mod( A_Index , 10 ) )
                ToolTip( "`nPress Shift to Set`n`nPress Ctrl to Cancel" )
            Sleep 30
        }
        v1 := Vector.MouseVector()
        rect := This.Window.Rect()
        ToolTip
        While( GetKeyState( "Shift" ) )
            Sleep 30
        While( !GetKeyState( "Shift" ) ){
            if( GetKeyState( "Ctrl" ) ){
                This.Window.Destroy()
                TimedTips( "ScreenShot Canceled" )
                return 0
            }
            v2 := Vector.MouseVector()
            if( v1.X <= v2.X )
                rect.X := v1.X , rect.W := v2.X - v1.X 
            else 
                rect.X := v2.X , rect.W := v1.X - v2.X
            if( v1.Y <= v2.Y )
                rect.Y := v1.Y , rect.H := v2.Y - v1.Y 
            else 
                rect.Y := v2.Y , rect.H := v1.Y - v2.Y
            This.Window.Clear()
            nRect := This.Window.Rect( rect ,,,,, { X: -5 , Y: -5 , W: 10 , H: 10 } )
            This.Window.Resize( 1 , nRect )
            pen := Gdip_CreatePen( "0xFFFF0000" , 1 )
            Gdip_DrawRectangle( This.Window.G , pen , 5 , 5 , rect.W , rect.H )
            This.Window.Update()
            if( !Mod( A_Index , 10 ) )
                ToolTip( "`nPress Shift to Set`n`nPress Ctrl to Cancel" )
            Sleep 30
        }
        ToolTip
        While( GetKeyState( "Shift" ) )
            Sleep 30
        This.Window.Destroy()
        sRect := StrReplace( StrReplace( Vector.RectToString( rect ) , "|" ) , "," , "|" )
        pBitmap := Gdip_BitmapFromScreen( sRect )
        name := A_Now
        This.SaveTempScreenCap( pBitmap , name )
        return { pBitmap: pBitmap , Rect: rect , Name: name }
    }
    static WindowCapture(){
        while( !GetKeyState( "ctrl" ) ){
            ToolTip( "Activate the target window and then`nPRESS CTRL" )
            sleep 30
        }
        ToolTip
        winHwnd := WinActive( "A" )
        title := WinGetTitle( "ahk_id " winHwnd )
        pBitmap := Gdip_BitmapFromHWND( winHwnd )
        name := A_Now
        This.SaveTempScreenCap( pBitmap , name )
        width := Gdip_GetImageWidth( pBitmap )
        height := Gdip_GetImageHeight( pBitmap )
        rect := Vector.Rect( 0 , 0 , width , height )
        return { pBitmap: pBitmap , Rect: rect , Name: name }
    }
    static SaveTempScreenCap( pBitmap , name ){        
        path := Main.ScreenShotsFolder
        if( !DirExist( path ) )
            DirCreate( path )
        path := Main.ScreenShotsFolder "Temp ScreenShot Folder\" 
        if( !DirExist( path ) )
            DirCreate( path )
        screenshotPaths := This.GetTempScreenShotList()
        Gdip_SaveBitmapToFile( pBitmap , path . name . ".png" , 100 )
        TimedTips( "Temp bitmap saved" )
    }
    static GetTempScreenShotList(){
        path := Main.ScreenShotsFolder "Temp ScreenShot Folder\"
        screenshotPaths := []
        loop files path "*.png" 
        {
            screenshotPaths.Push( StrReplace( A_LoopFileName , ".png" ) )
        }
        if( screenshotPaths = 100 ){
            oldestScreenShot := This.FindOldestScreenShot( screenshotPaths )
            This.RemoveTempScreenShot( oldestScreenShot )
        }
        return screenshotPaths
    }
    static FindOldestScreenShot( screenshotPaths ){
        oldest := 10000000000000000
        loop screenshotPaths.Length {
            cc := screenshotPaths[ A_Index ]
            if( cc < oldest )
                oldest := cc
        }
        return oldest
    }
    static RemoveTempScreenShot( name ){
        path := Main.ScreenShotsFolder "Temp ScreenShot Folder\" name ".png"
        FileDelete( path )
        TimedTips( "Old Screen Cap deleted" )
    }
}



;|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|
;|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|
;|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|<<<()>>>|
Class PopupWindow_v4  {
    ;Class: PopupWindow_v4
    ;Version: 4.1
    ;Date Started: Aug 18th, 2024
    ;Last Edit: Aug 23rd, 2024
    ;Notes: 
    ;Requires GDIP for ahk v2: https://raw.githubusercontent.com/buliasz/AHKv2-Gdip/master/Gdip_All.ahk
    ;
    ;
    ;Prototype: Gui1 := PopupWindow_v4( { Options: "+AlwaysOnTop" , Title: "Gui1" , Rect: { X: 0 , Y: 0 , W: 100 , H: 100 } } )
    static Windows  := [] 
    static Handles  := [] 
    static Index    := 0 
    static Busy     := 0 
    static Colors{
        Get{
            if( !This.HasProp( "_Colors" ) ){
                This._Colors := [ "0xFF000000" , "0xFFC0C0C0" , "0xFF808080" , "0xFFFFFFFF" 
                , "0xFF800000" , "0xFFFF0000" , "0xFF800080" , "0xFFFF00FF" , "0xFF008000" 
                , "0xFF00FF00" , "0xFF808000" , "0xFFFFFF00" , "0xFF000080" , "0xFF0000FF" 
                , "0xFF008080" , "0xFF00FFFF" , "0xFF8000FF" ]
            }
            return This._Colors
        }Set{
            This._Colors := value
        }
    }
    static pToken{
        Get{
            if( !This.HasProp( "_pToken" ) ) 
                This._pToken := Gdip_Startup()
            return This._pToken
        }Set{
            if( !This.HasProp( "_pToken" ) )
                This._pToken := This.pToken
        }
    }
    static TipsTimer{
        Get{
            if( !This.HasProp( "_TipsTimer" ) )
                This._TipsTimer := This._TipsOff.Bind( This )
            return This._TipsTimer
        }
    }
    static Tips( msg , delay := 1500 ){
        ToolTip( msg )
        SetTimer( This.TipsTimer , Abs( delay ) * -1 )
    }
    static _TipsOff(){
        ToolTip
    }
    static _AddWindow( window ){
        local Index := ++This.Index , hwnd := window.Hwnd
        This.Windows.%Index% := window 
        This.Windows.%Index%.Index := This.Index
        This.Windows.%Index%.Name := window.Title
        This.Handles.%hwnd% := window
    }
    __New( DefaultsObject := "" , AutoShow := 1 , startGdip := 1 ){
        if( startGdip )
            PopupWindow_v4.pToken := ""
        This._SetDefaults( DefaultsObject )
        This._CreateWindow()
        This._CreateGraphics()
        if( AutoShow )
            This.Show( 1 )
        PopupWindow_v4._AddWindow( This )
        return This
    }
    Show( Activate := "" , FadeIn := 0 , FadeCycles := 10 , FadeDelay := 60 ){
        local fadeLevel := 0
        if( Activate )
            Activate := ""
        else 
            Activate := " NA "
        if( FadeIn ){
            This.Update( 0 )
            This.Window.Show( "x" This.X " y" This.Y " w" This.W " h" This.H " NA" )
            Loop FadeCycles || 10   {
                fadeLevel += 255 / FadeCycles
                This.Update( Floor( fadeLevel ) )
                Sleep( FadeDelay )
            }
            This.Update( 255 )
        }
        This.Window.Show( "x" This.X " y" This.Y " w" This.W " h" This.H " " Activate )
        This.IsVisable := 1
    }
    Hide( FadeOut := 0 , FadeCycles := 10 , FadeDelay := 60 , StartAlpha := "" ){
        local fadeLevel := 0
        This.IsVisable := 0
        if( !FadeOut ){
            This.Window.Hide()
            return 0
        }else{
            alpha := ( StartAlpha != "" ) ? ( StartAlpha ) : ( This.Alpha )
            fadeLevel := alpha
            This.Update( Floor( alpha ) )
            This.Show()
            Loop FadeCycles || 10   {
                fadeLevel -= alpha / FadeCycles
                if( fadeLevel < 0 )
                    fadeLevel := 0
                This.Update( Floor( fadeLevel ) )
                Sleep( FadeDelay )
            }
            This.Window.Hide()
            return 0
        }
        return 1
    }
    Update( alpha := "" ){
        if( alpha = "" )
            alpha := This.Alpha
        UpdateLayeredWindow( This.HWND , This.HDC , Floor( This.X ) , Floor( This.Y ) , Floor( This.W ) , Floor( This.H ) , Floor( Alpha ) )
        ; UpdateLayeredWindow( This.HWND , This.HDC , This.X , This.Y , This.W * This.Scale , This.H * This.Scale , Floor( Alpha ) )
    }
    Clear( AutoUpdate := 0 , Color := "" , Alpha := 255 ){
        if( Color ){
            if( StrLen( Color ) = 6 )
                Color := "0xFF" Color 
            else if( StrLen( Color ) <= 2 ){
                try
                    Color := PopupWindow_v4.Colors[ color ]
                catch 
                    Color := PopupWindow_v4.Colors[ 1 ]
            }
            Gdip_GraphicsClear( This.G , Color )
        }else{
            Gdip_GraphicsClear( This.G )
        }
        if( AutoUpdate ){
            if( Alpha )
                This.Update( Alpha )
            else 
                This.Update()
        }
    }
    Resize( autoShow := 1 , x := "" , y := "" , w := "" , h := "" , Scale := "" ){
    
        local oldWidth := This.W 
        local oldHeight := This.H
        if( IsObject( x ) ){
            for k , v in StrSplit( "X|Y|W|H" , "|" )  {
                if( x.HasProp( v ) )
                    This._%v% := x.%v% 
            }
        }else{
            for k , v in StrSplit( "X|Y|W|H" , "|" ) 
                if( %v% != "" )
                    This._%v% := %v%
        }
        if( oldWidth != This.W || oldHeight != This.H ){
            This._DestroyGraphics()
            This._CreateGraphics()
        }
        if( autoShow )
            This.Show()
    }
    Clip( rect := "" , alpha := "" , mode := 1 ){
        local clipRect := { X: 0 , Y: 0 , W: This.W , H: This.H }
        ( alpha != "" ) || alpha := This.Alpha
        if( IsObject( rect ) ){
            for k , v in StrSplit( "X|Y|W|H" , "|" )    {
                if( rect.HasProp( v ) )
                    clipRect.%v% := rect.%v%
            }
        }
        return Gdip_SetClipRect( This.G , clipRect.X , clipRect.Y , clipRect.W , clipRect.H , mode )
    }
    Close(){
        Try{
            PopupWindow_v4.Handles.DeleteProp( This.Hwnd )
            PopupWindow_v4.Windows.DeleteProp( This.Index )
            This._DestroyGraphics()
            This.Window.Destroy()
            This.Window := ""
            This := ""
        }catch{
            PopupWindow_v4.Tips( "Failed to use CLOSE method" )
        }
    }
    Destroy(){
        Try{
            This.Close()
        }catch{
            PopupWindow_v4.Tips( "Failed to use DESTROY method" )
        }
    }
    Delete(){
        Try{
            This.Close()
        }catch{
            PopupWindow_v4.Tips( "Failed to use DELETE method" )
        }
    }
    Rect( x_or_Rect := "" , y := "" , w := "" , h := "" , scale := "" , offsetRect := "" ){
        local rect := { X: 0 , Y: 0 , W: This.W , H: This.H }
        local x := x_or_Rect
        if( IsObject( x ) ){
            for k , v in StrSplit( "X|Y|W|H" , "|" )    {
                if( x.HasProp( v ) ){
                    if( x.%v% != "" )
                        rect.%v% := x.%v%
                }     
            }
        }else{
            for k , v in StrSplit( "X|Y|W|H" , "|" )    {
                if( %v% != "" )
                    rect.%v% := %v%
            }
        }
        if( IsObject( offsetRect ) ){
            for k , v in StrSplit( "X|Y|W|H" , "|" )    {
                if( offsetRect.HasProp( v ) ){
                    if( offsetRect.%v% != "" && offsetRect.%v% != 0 ){
                        rect.%v% += offsetRect.%v% 
                    }
                }
            }
        }
        return rect 
    }
    _SetDefaults( DefaultsObject := "" ){
        This._DefaultOptions := " -DPIScale -Caption +LastFound +E0x80000 "
        This.Options := ""
        This.Title := "PopupWindow_4"
        This.Alpha := 255
        This.Scale := 1
        if( IsObject( DefaultsObject ) ){
            for k , v in DefaultsObject.OwnProps() {
                if( IsObject( DefaultsObject.%k% ) ){
                    for i , j in DefaultsObject.%k%.OwnProps()  {
                        if( InStr( "XYWH" , i ) )
                            This._%i% := j 
                        else
                            This.%k%.%i% := DefaultsObject.%k%.%i%
                    }
                }else if( InStr( "XYWH" , k ) )
                    This._%k% := v 
                else 
                    This.%k% := DefaultsObject.%k%
            }
        }
    }
    _CreateWindow(){
        This.Window := Gui( This._DefaultOptions . This.Options , This.Title )
        This._Hwnd := This.Window.Hwnd
    }
    _DestroyGraphics(){
        Gdip_DeleteGraphics( This.G )
        SelectObject( This.HDC , This.OBM )
        DeleteObject( This.HBM )
        DeleteDC( This.HDC )
    }
    _CreateGraphics(){
        This.Window.Opt( "+LastFound" )
        This.HBM := CreateDIBSection( This.W , This.H )
        This.HDC := CreateCompatibleDC()
        This.OBM := SelectObject( This.HDC , This.HBM )
        This.G := Gdip_GraphicsFromHDC( This.HDC )
        Gdip_SetSmoothingMode( This.G , This.Smoothing )
        Gdip_SetInterpolationMode( This.G , This.InterpolationMode )
    }
    Hwnd{
        Get{
            if( !This.HasProp( "_Hwnd" ) || This._Hwnd = "" )
                return 0
            return This._Hwnd
        }
    }
    Smoothing{
        Get{
            if( !This.HasProp( "_Smoothing") )
                This._Smoothing := 2
            return This._Smoothing
        }Set{
            if( value >= 0 && value <= 4 ){
                if( !This.HasProp( "_Smoothing") ){
                    This._Smoothing := value
                    return
                }
                This._Smoothing := value
                Gdip_SetSmoothingMode( This.G , This.Smoothing )
            }
        }
    }
    InterpolationMode{
        Get{
            if( !This.HasProp( "_InterpolationMode") )
                This._InterpolationMode := 7
            return This._InterpolationMode
        }Set{
            if( value >= 0 && value <= 7 ){
                if( !This.HasProp( "_InterpolationMode") ){
                    This._InterpolationMode := value
                    return
                }
                This._InterpolationMode := value
                Gdip_SetInterpolationMode( This.G , This.InterpolationMode )
            }
            }
    }
    X{
        Get{
            if( !This.HasProp( "_X" ) )
                This._X := 0
            return This._X
        }Set{
            PopupWindow_v4.Tips( "Use the RESIZE method to set the Window X position" )
        }
    }
    Y{
        Get{
            if( !This.HasProp( "_Y" ) )
                This._Y := 0
            return This._Y
        }Set{
            PopupWindow_v4.Tips( "Use the RESIZE method to set the Window Y position" )
        }
    }
    W{
        Get{
            if( !This.HasProp( "_W" ) )
                This._W := A_ScreenWidth
            return This._W
        }Set{
            PopupWindow_v4.Tips( "Use the RESIZE method to set the Window Width" )
        }
    }
    H{
        Get{
            if( !This.HasProp( "_H" ) )
                This._H := A_ScreenHeight
            return This._H
        }Set{
            PopupWindow_v4.Tips( "Use the RESIZE method to set the Window Height" )
        }
    }
    G{
        Get{
            if( !This.HasProp( "_G" ) )
                This._G := ""
            return This._G
        }Set{
            This._G := value
        }
    }
}

;**************************************************************************************************************************************************************************
;00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 
;00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 
;00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 
;**************************************************************************************************************************************************************************
class Vector    {
    ;class: Vector v3.1 for ahk v2
    ;Purpose: Vector math class
    ;Author/Written By: HB
    ;Date Started: Aug 29th 2024
    ;Last Edit:
    ;Examples:
    ;
    ;
    ;Notes: 
    ;Forum post: https://www.autohotkey.com/boards/viewtopic.php?f=83&t=132770&p=583213#p583213
    ;
    static RadToDeg := 45 / ATan( 1 )
    static DegToRad := ATan( 1 ) / 45
    static TestLineInterceptPoint( interceptPoint , Line1 , Line2 ){ ; Line = { Start: { X: , Y: } , End: { X: , Y: } } , interceptPoint = { X: , Y: }
        local Mx_Min := 0 , Mx_Max := 0 , Lx_Min := 0 , Lx_Max := 0 , My_Min := 0 , My_Max := 0 , Ly_Min := 0 , Ly_Max := 0

        for k , v in [ "X" , "Y" ]  {
            M%v%_Min := min( Line1.Start.%v% , Line1.End.%v% )
            M%v%_Max := max( Line1.Start.%v% , Line1.End.%v% )
			L%v%_Min := min( Line1.Start.%v% , Line1.End.%v% )
			L%v%_Max := max( Line1.Start.%v% , Line1.End.%v% )
        }

        if( !( interceptPoint.X < Mx_Min || interceptPoint.X > Mx_Max || interceptPoint.X < Lx_Min || interceptPoint.X > Lx_Max ) && !( interceptPoint.Y < My_Min || interceptPoint.Y > My_Max || interceptPoint.Y < Ly_Min || interceptPoint.Y > Ly_Max ) )
			return 1
		return 0

    }
	static GetLineInterceptPoint( Line1 , Line2 ){ ; Line = { Start: { X: , Y: } , End: { X: , Y: } }
		local A1 := Line1.End.Y - Line1.Start.Y
		,B1 := Line1.Start.X - Line1.End.X
		,C1 := A1 * Line1.Start.X + B1 * Line1.Start.Y
		,A2 := Line2.End.Y - Line2.Start.Y
		,B2 := Line2.Start.X - Line2.End.X
		,C2 := A2 * Line2.Start.X + B2 * Line2.Start.Y
		,Denominator := A1 * B2 - A2 * B1 
		return Vector( { X: ( ( B2 * C1 - B1 * C2 ) / Denominator )  , Y: ( ( A1 * C2 - A2 * C1 ) / Denominator ) } )
	}
    __New( x_or_Vector := "" , y := "" , setAngle := "" , rotateAngle := "" , mag := "" ){
        if( IsObject( x_or_Vector ) ){
            This.X := x_or_Vector.X
            This.Y := x_or_Vector.Y
        }else{
            ( x_or_Vector != "" )   || x_or_Vector := 10 
            ( y != "" )             || y := 10 
            This.X := x_or_Vector
            This.Y := y
        }
        ( setAngle = "" )       || ( This.Angle := setAngle )
        ( rotateAngle = "" )    || ( This.RotateAngle( rotateAngle ) )
        ( mag = "" )            || ( This.Mag := mag )
    }
    Angle{
        Get{
            local angle := Vector.RadToDeg * DllCall( "msvcrt\atan2" , "Double" , This.Y , "Double" , This.X , "CDECL Double" )
            ( angle >= 0 ) || angle += 360
            return angle
        }Set{
            local changeAngle , Co , Si , X2 , Y2 
            changeAngle := value - This.Angle 
            Co := Cos( Vector.DegToRad * changeAngle )
            Si := Sin( Vector.DegToRad * ChangeAngle )
            X2 := This.X * Co - This.Y * Si 
            Y2 := This.X * Si + This.Y * Co 
            This.X := X2 
            This.Y := Y2 
        }
    }
    RotateAngle( rotationAmount := 90 , NewVector := 0  ){
        local Co , Si , X2 , Y2
        Co := Cos( Vector.DegToRad * rotationAmount )
		Si := Sin( Vector.DegToRad * rotationAmount )
		X2 := This.X * Co - This.Y * Si 
		Y2 := This.X * Si + This.Y * Co 
        if( NewVector ){
            return Vector( X2 , Y2 )
        }else{
            This.X := X2 
            This.Y := Y2
        }
    }
    Mag{
        Get{
            return Sqrt( This.X * This.X + This.Y * This.Y )
        }Set{
            local mag := This.Mag
            This.X := This.X * value / mag
            This.Y := This.Y * value / mag
        }

    }
    Dist( x , y := "" ){
        if( IsObject( x ) )
            return Sqrt( ( ( This.X - x.X ) **2 ) + ( ( This.Y - x.Y ) **2 ) )
        else 
            return Sqrt( ( ( This.X - X ) **2 ) + ( ( This.Y - Y ) **2 ) )
    }
    MagSq(){
        return This.Mag**2
    }
    Dot( x , y := "" ){
        if( IsObject( x ) )
			return ( This.X * x.X ) + ( This.Y * x.Y )
		else
			return ( This.X * X ) + ( This.Y * Y )
    }
    Cross( x , y := "" ){
		if( IsObject( x ) )
			return This.X * x.Y - This.Y * x.X
		else
			return This.X * Y - This.Y * X
	}
    Norm(){
        local mag := This.Mag
		This.X /= mag
		This.Y /= mag
	}
    Mult( x , y := "" ){
		if( IsObject( x ) ){
			This.X *= x.X
			This.Y *= x.Y
		}else if( x && y = "" ){
			This.X *= x 
			This.Y *= x 
		}else{
			This.X *= X
			This.Y *= Y
		}
	}
    Div( x , y := "" ){
		if( IsObject( x ) ){
			This.X /= x.X
			This.Y /= x.Y
		}else if( x && y = "" ){
			This.X /= x 
			This.Y /= x 
		}else{
			This.X /= X
			This.Y /= Y
		}
	}
    Sub( x , y := "" ){
		if( IsObject( x ) ){
			This.X -= x.X
			This.Y -= x.Y
		}else if( y = "" ){
			This.X -= X
			This.Y -= X
		}else{
			This.X -= X
			This.Y -= Y
		}
	}
    Add( x , y := "" ){
		if( IsObject( x ) ){
			This.X += x.X
			This.Y += x.Y
		}else if( y = "" ){
			This.X += x 
			This.Y += x
		}else{
			This.X += x 
			This.Y += y 
		}
	}
    InRect( rect ){
        if( This.X >= rect.X )
            if( This.X <= rect.X + rect.W )
                if( This.Y >= rect.Y )
                    if( This.Y <= rect.Y + rect.H )
                        return 1
        return 0
    }
    static Line( startVector , endVector ){
        local lineObject := {}
        lineObject.Start := Vector( startVector )
        lineObject.End := Vector( endVector )
        return lineObject
    }
    Line( endVector ){
        return Vector.Line( This , endVector )
    }
    static Arrow( start , end , headLength := 30 , neckLength := 5 , armLength := 10 , elbowLength := 4 , scale := 1 , returnString := 1 ){
        local master 
        local head 
        local neck 
        local rightArm 
        local leftArm 
        local rightElbow
        local leftElbow
        local outputString
        local outputArray

        if( start.HasProp( "start" ) ){
            start := Vector( start.Start )
            end := Vector( start.End )
        }
        master := Vector( start )
        master.Sub( end )

        head := Vector( master )
        head.Mag := headLength * scale
        head.Add( end )

        neck := Vector( master )
        neck.Mag := neckLength * scale 
        neck.Add( head )

        rightArm := Vector( master ,,, -90 ) 
        rightArm.Mag := armLength * scale 
        rightArm.Add( neck )
        
        rightElbow := Vector( master ,,, -90 )
        rightElbow.Mag := elbowLength * scale 
        rightElbow.Add( head )

        leftArm := Vector( master ,,, 90 )
        leftArm.Mag := armLength * scale 
        leftArm.Add( neck )

        leftElbow := Vector( master ,,, 90 )
        leftElbow.Mag := elbowLength * scale
        leftElbow.Add( head )

        if( returnString ){
            outputString := ""
		    for k , v in [ "Start" , "RightElbow" , "RightArm" , "End" , "LeftArm" , "LeftElbow" , "Start" ]    {
		        if( k < 7 ){
			        outputString .= %v%.X "," %v%.Y "|"
                }else{
                    outputString .= %v%.X "," %v%.Y  
                }
            }

		    return outputString 

        }else{
            outputArray := []
            for k , v in [ "Start" , "RightElbow" , "RightArm" , "End" , "LeftArm" , "LeftElbow" , "Start" ]	
                outputArray.Push( %v% )
            return outputArray
        }
    }
    static PolygonShape( Home , Radius := 100 , Sides := 4 , StartAngle := 270 , Scale := 1 , ReturnString := 1 ){
        local master , rotation , vectorArray := [] , arm , outputString
        if( Sides < 3 ){
            MsgBox( "The shape needs a min of 3 sides" )
            return
        }
        master := Vector( 10 , 10 , StartAngle )
        master.Mag := Radius * Scale
        rotation := 360 / Sides
        arm := Vector( master )
        arm.Add( home )
        vectorArray.Push( arm )
        Loop Sides  {
            arm := Vector( master ,,, rotation * A_Index )
            arm.Add( home )
            vectorArray.Push( arm )
        }
        if( ReturnString ){
            outputString := ""
            loop vectorArray.Length {
                if( A_Index != vectorArray.Length )
                    outputString .= vectorArray[ A_Index ].X "," vectorArray[ A_Index ].Y "|"
                else  
                    outputString .= vectorArray[ A_Index ].X "," vectorArray[ A_Index ].Y 
            }
            return outputString
        }else{
            return vectorArray
        }
    }
    static Rect( x_or_Rect := "" , y := "" , w := "" , h := "" , scale := 1 , offsetRect := "" , saveRect := 0 ){
        static SavedRect := { X: 0 , Y: 0 , W: 100 , H: 100 }
        local rect := SavedRect.Clone()
        local x := x_or_Rect
        if( IsObject( x ) ){
            for k , v in StrSplit( "X|Y|W|H" , "|" )    {
                if( x.HasProp( v ) ){
                    if( x.%v% != "" )
                        rect.%v% := x.%v%
                }
            }
        }else{
            for k , v in StrSplit( "X|Y|W|H" , "|" )    {
                if( %v% != "" )
                    rect.%v% := %v%
            }
        }
        if( IsObject( offsetRect ) ){
            for k , v in StrSplit( "X|Y|W|H" , "|" )    {
                if( offsetRect.HasProp( v ) ){
                    if( offsetRect.%v% != "" && offsetRect.%v% != 0 ){
                        rect.%v% += offsetRect.%v% 
                    }
                }
            }
        }
        if( scale != 1 && scale != 0 && scale != "" ){
            for k , v in StrSplit( "X|Y|W|H" , "|" )    
                rect.%v% *= scale
        }
        if( saveRect )
            SavedRect := rect.Clone()
        return rect 
    }
    static MouseVector( Mode := "Screen" ){
        local x := "", y := "", lastMode := ""
        lastMode := CoordMode( "Mouse" , Mode )
        MouseGetPos &x , &y 
        CoordMode( "Mouse" , lastMode )
        return Vector( x , y )
    }
    static ArrayToString( vectorArray , Scale := 1 ){
        local outputString := "" , v := ""
        Loop vectorArray.Length   {
            v := vectorArray[ A_Index ]
            if( A_Index != vectorArray.Length )
                outputString .= v.X * scale "," v.Y * scale "|"
            else
                outputString .= v.X * scale "," v.Y * scale
        }
        return outputString
    }
    static StringToArray( stringPath , Scale := 1 ){
        local outputArray := []
        local vArr := StrSplit( stringPath , "|" , " " )
        local v := ""
        Loop vArr.Length    {
            v := StrSplit( vArr[ A_Index ] , "," )
            outputArray.Push( Vector( v[ 1 ] , v[ 2 ] ) )
        }
        return outputArray
    }
    static VectorToRect( topLeftVector , bottomRightVector ){
        local rect := {}
        rect.X := topLeftVector.X
        rect.Y := topLeftVector.Y
        rect.W := bottomRightVector.X - topLeftVector.X
        rect.H := bottomRightVector.Y - topLeftVector.Y
        return rect
    }
    static VectorToString( inputVector , valueSeparator := "," ){
        return inputVector.X . valueSeparator . inputVector.Y 
    }
    VectorToString( valueSeparator := "," ){
        return Vector.VectorToString( This , valueSeparator )
    }
    static RectToString( rect , scale := 1 , vSep := "," , pSep := "|" ){
        return rect.X * scale . vSep . rect.Y * scale . vSep . rect.W * scale . vSep . rect.H * scale . pSep
    }
    static StringToRect( InString , scale := 1 , vSep := "," , pSep := "|" ){
        local arr := [] , rect := {}
        InString := StrReplace( InString , pSep )
        arr := StrSplit( InString , vSep , A_Space )
        for k , v in StrSplit( "X|Y|W|H" , "|" )
            rect.%v% := arr[ k ]
        return rect
    }
    static BestFit( OuterRect , InnerRect , UpSizeInnerRect := 0 , Margin := 0 ){
        local w1 := "" , w2 := "" , h1 := "" , h2 := "" , x1 := "" , x2 := "" , y1 := "" , y2 := "" 
        x1 := OuterRect.X + Margin 
        y1 := OuterRect.Y + Margin
        w1 := OuterRect.W - 2 * Margin
        h1 := OuterRect.H - 2 * Margin
        x2 := InnerRect.X
        y2 := InnerRect.Y
        w2 := InnerRect.W
        h2 := InnerRect.H
        w2Mult := w2 / h2 
        h2Mult := h2 / w2 
        if( !( w2 <= w1 && h2 <= h1 && !UpSizeInnerRect ) ){
            if( w1 * h2Mult <= h1 ){
                w2 := w1 
                h2 := w2 * h2Mult 
            }else{
                h2 := h1 
                w2 := h2 * w2Mult
            }
        }
        x2 := x1 + ( ( w1 - w2 ) / 2 )
        y2 := y1 + ( ( h1 - h2 ) / 2 )
        for k , v in StrSplit( "X|Y|W|H" , "|" )    {
            InnerRect.%v% := %v%2
        }
    }
}
;**************************************************************************************************************************************************************************
;00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 
;00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 
;00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 00000 <<<>>> 00000 
;**************************************************************************************************************************************************************************

; v1.62
;
;#####################################################################################
;#####################################################################################
; STATUS ENUMERATION
; Return values for functions specified to have status enumerated return type
;#####################################################################################
;
; Ok					= 0
; GenericError				= 1
; InvalidParameter			= 2
; OutOfMemory				= 3
; ObjectBusy				= 4
; InsufficientBuffer			= 5
; NotImplemented			= 6
; Win32Error				= 7
; WrongState				= 8
; Aborted				= 9
; FileNotFound				= 10
; ValueOverflow				= 11
; AccessDenied				= 12
; UnknownImageFormat			= 13
; FontFamilyNotFound			= 14
; FontStyleNotFound			= 15
; NotTrueTypeFont			= 16
; UnsupportedGdiplusVersion		= 17
; GdiplusNotInitialized			= 18
; PropertyNotFound			= 19
; PropertyNotSupported			= 20
; ProfileNotFound			= 21
;
;#####################################################################################
;#####################################################################################
; FUNCTIONS
;#####################################################################################
;
; UpdateLayeredWindow(hwnd, hdc, x:="", y:="", w:="", h:="", Alpha:=255)
; BitBlt(ddc, dx, dy, dw, dh, sdc, sx, sy, Raster:="")
; StretchBlt(dDC, dx, dy, dw, dh, sDC, sx, sy, sw, sh, Raster:="")
; SetImage(hwnd, hBitmap)
; Gdip_BitmapFromScreen(Screen:=0, Raster:="")
; CreateRectF(&RectF, x, y, w, h)
; CreateSizeF(&SizeF, w, h)
; CreateDIBSection
;
;#####################################################################################

; Function:				UpdateLayeredWindow
; Description:				Updates a layered window with the handle to the DC of a gdi bitmap
;
; hwnd					Handle of the layered window to update
; hdc					Handle to the DC of the GDI bitmap to update the window with
; Layeredx				x position to place the window
; Layeredy				y position to place the window
; Layeredw				Width of the window
; Layeredh				Height of the window
; Alpha					Default = 255 : The transparency (0-255) to set the window transparency
;
; return				if the function succeeds, the return value is nonzero
;
; notes					if x or y omitted, then layered window will use its current coordinates
;					if w or h omitted then current width and height will be used

UpdateLayeredWindow(hwnd, hdc, x:="", y:="", w:="", h:="", Alpha:=255)
{
	if ((x != "") && (y != "")) {
		pt := Buffer(8)
		NumPut("UInt", x, "UInt", y, pt)
	}

	if (w = "") || (h = "") {
		WinGetRect(hwnd,,, &w, &h)
	}

	return DllCall("UpdateLayeredWindow"
		, "UPtr", hwnd
		, "UPtr", 0
		, "UPtr", ((x = "") && (y = "")) ? 0 : pt.Ptr
		, "Int64*", w|h<<32
		, "UPtr", hdc
		, "Int64*", 0
		, "UInt", 0
		, "UInt*", Alpha<<16|1<<24
		, "UInt", 2)
}

;#####################################################################################

; Function				BitBlt
; Description			The BitBlt function performs a bit-block transfer of the color data corresponding to a rectangle
;						of pixels from the specified source device context into a destination device context.
;
; dDC					handle to destination DC
; dx					x-coord of destination upper-left corner
; dy					y-coord of destination upper-left corner
; dw					width of the area to copy
; dh					height of the area to copy
; sDC					handle to source DC
; sx					x-coordinate of source upper-left corner
; sy					y-coordinate of source upper-left corner
; Raster				raster operation code
;
; return				if the function succeeds, the return value is nonzero
;
; notes					if no raster operation is specified, then SRCCOPY is used, which copies the source directly to the destination rectangle
;
; BLACKNESS				= 0x00000042
; NOTSRCERASE			= 0x001100A6
; NOTSRCCOPY			= 0x00330008
; SRCERASE				= 0x00440328
; DSTINVERT				= 0x00550009
; PATINVERT				= 0x005A0049
; SRCINVERT				= 0x00660046
; SRCAND				= 0x008800C6
; MERGEPAINT			= 0x00BB0226
; MERGECOPY				= 0x00C000CA
; SRCCOPY				= 0x00CC0020
; SRCPAINT				= 0x00EE0086
; PATCOPY				= 0x00F00021
; PATPAINT				= 0x00FB0A09
; WHITENESS				= 0x00FF0062
; CAPTUREBLT			= 0x40000000
; NOMIRRORBITMAP		= 0x80000000

BitBlt(ddc, dx, dy, dw, dh, sdc, sx, sy, Raster:="")
{
	return DllCall("gdi32\BitBlt"
					, "UPtr", dDC
					, "Int", dx
					, "Int", dy
					, "Int", dw
					, "Int", dh
					, "UPtr", sDC
					, "Int", sx
					, "Int", sy
					, "UInt", Raster ? Raster : 0x00CC0020)
}

;#####################################################################################

; Function				StretchBlt
; Description			The StretchBlt function copies a bitmap from a source rectangle into a destination rectangle,
;						stretching or compressing the bitmap to fit the dimensions of the destination rectangle, if necessary.
;						The system stretches or compresses the bitmap according to the stretching mode currently set in the destination device context.
;
; ddc					handle to destination DC
; dx					x-coord of destination upper-left corner
; dy					y-coord of destination upper-left corner
; dw					width of destination rectangle
; dh					height of destination rectangle
; sdc					handle to source DC
; sx					x-coordinate of source upper-left corner
; sy					y-coordinate of source upper-left corner
; sw					width of source rectangle
; sh					height of source rectangle
; Raster				raster operation code
;
; return				if the function succeeds, the return value is nonzero
;
; notes					if no raster operation is specified, then SRCCOPY is used. It uses the same raster operations as BitBlt

StretchBlt(ddc, dx, dy, dw, dh, sdc, sx, sy, sw, sh, Raster:="")
{
	return DllCall("gdi32\StretchBlt"
					, "UPtr", ddc
					, "Int", dx
					, "Int", dy
					, "Int", dw
					, "Int", dh
					, "UPtr", sdc
					, "Int", sx
					, "Int", sy
					, "Int", sw
					, "Int", sh
					, "UInt", Raster ? Raster : 0x00CC0020)
}

;#####################################################################################

; Function				SetStretchBltMode
; Description			The SetStretchBltMode function sets the bitmap stretching mode in the specified device context
;
; hdc					handle to the DC
; iStretchMode			The stretching mode, describing how the target will be stretched
;
; return				if the function succeeds, the return value is the previous stretching mode. If it fails it will return 0
;
; STRETCH_ANDSCANS 		= 0x01
; STRETCH_ORSCANS 		= 0x02
; STRETCH_DELETESCANS 	= 0x03
; STRETCH_HALFTONE 		= 0x04

SetStretchBltMode(hdc, iStretchMode:=4)
{
	return DllCall("gdi32\SetStretchBltMode"
					, "UPtr", hdc
					, "Int", iStretchMode)
}

;#####################################################################################

; Function				SetImage
; Description			Associates a new image with a static control
;
; hwnd					handle of the control to update
; hBitmap				a gdi bitmap to associate the static control with
;
; return				if the function succeeds, the return value is nonzero

SetImage(hwnd, hBitmap)
{
	_E := DllCall( "SendMessage", "UPtr", hwnd, "UInt", 0x172, "UInt", 0x0, "UPtr", hBitmap )
	DeleteObject(_E)
	return _E
}

;#####################################################################################

; Function				SetSysColorToControl
; Description			Sets a solid colour to a control
;
; hwnd					handle of the control to update
; SysColor				A system colour to set to the control
;
; return				if the function succeeds, the return value is zero
;
; notes					A control must have the 0xE style set to it so it is recognised as a bitmap
;						By default SysColor=15 is used which is COLOR_3DFACE. This is the standard background for a control
;
; COLOR_3DDKSHADOW				= 21
; COLOR_3DFACE					= 15
; COLOR_3DHIGHLIGHT				= 20
; COLOR_3DHILIGHT				= 20
; COLOR_3DLIGHT					= 22
; COLOR_3DSHADOW				= 16
; COLOR_ACTIVEBORDER			= 10
; COLOR_ACTIVECAPTION			= 2
; COLOR_APPWORKSPACE			= 12
; COLOR_BACKGROUND				= 1
; COLOR_BTNFACE					= 15
; COLOR_BTNHIGHLIGHT			= 20
; COLOR_BTNHILIGHT				= 20
; COLOR_BTNSHADOW				= 16
; COLOR_BTNTEXT					= 18
; COLOR_CAPTIONTEXT				= 9
; COLOR_DESKTOP					= 1
; COLOR_GRADIENTACTIVECAPTION	= 27
; COLOR_GRADIENTINACTIVECAPTION	= 28
; COLOR_GRAYTEXT				= 17
; COLOR_HIGHLIGHT				= 13
; COLOR_HIGHLIGHTTEXT			= 14
; COLOR_HOTLIGHT				= 26
; COLOR_INACTIVEBORDER			= 11
; COLOR_INACTIVECAPTION			= 3
; COLOR_INACTIVECAPTIONTEXT		= 19
; COLOR_INFOBK					= 24
; COLOR_INFOTEXT				= 23
; COLOR_MENU					= 4
; COLOR_MENUHILIGHT				= 29
; COLOR_MENUBAR					= 30
; COLOR_MENUTEXT				= 7
; COLOR_SCROLLBAR				= 0
; COLOR_WINDOW					= 5
; COLOR_WINDOWFRAME				= 6
; COLOR_WINDOWTEXT				= 8

SetSysColorToControl(hwnd, SysColor:=15)
{
	WinGetRect(hwnd,,, &w, &h)
	bc := DllCall("GetSysColor", "Int", SysColor, "UInt")
	pBrushClear := Gdip_BrushCreateSolid(0xff000000 | (bc >> 16 | bc & 0xff00 | (bc & 0xff) << 16))
	pBitmap := Gdip_CreateBitmap(w, h), G := Gdip_GraphicsFromImage(pBitmap)
	Gdip_FillRectangle(G, pBrushClear, 0, 0, w, h)
	hBitmap := Gdip_CreateHBITMAPFromBitmap(pBitmap)
	SetImage(hwnd, hBitmap)
	Gdip_DeleteBrush(pBrushClear)
	Gdip_DeleteGraphics(G), Gdip_DisposeImage(pBitmap), DeleteObject(hBitmap)
	return 0
}

;#####################################################################################

; Function				Gdip_BitmapFromScreen
; Description			Gets a gdi+ bitmap from the screen
;
; Screen				0 = All screens
;						Any numerical value = Just that screen
;						x|y|w|h = Take specific coordinates with a width and height
; Raster				raster operation code
;
; return					if the function succeeds, the return value is a pointer to a gdi+ bitmap
;						-1:		one or more of x,y,w,h not passed properly
;
; notes					if no raster operation is specified, then SRCCOPY is used to the returned bitmap

Gdip_BitmapFromScreen(Screen:=0, Raster:="")
{
	hhdc := 0
	if (Screen = 0) {
		_x := DllCall( "GetSystemMetrics", "Int", 76 )
		_y := DllCall( "GetSystemMetrics", "Int", 77 )
		_w := DllCall( "GetSystemMetrics", "Int", 78 )
		_h := DllCall( "GetSystemMetrics", "Int", 79 )
	}
	else if (SubStr(Screen, 1, 5) = "hwnd:") {
		Screen := SubStr(Screen, 6)
		if !WinExist("ahk_id " Screen) {
			return -2
		}
		WinGetRect(Screen,,, &_w, &_h)
		_x := _y := 0
		hhdc := GetDCEx(Screen, 3)
	}
	else if IsInteger(Screen) {
		M := GetMonitorInfo(Screen)
		_x := M.Left, _y := M.Top, _w := M.Right-M.Left, _h := M.Bottom-M.Top
	}
	else {
		S := StrSplit(Screen, "|")
		_x := S[1], _y := S[2], _w := S[3], _h := S[4]
	}

	if (_x = "") || (_y = "") || (_w = "") || (_h = "") {
		return -1
	}

	chdc := CreateCompatibleDC()
	hbm := CreateDIBSection(_w, _h, chdc)
	obm := SelectObject(chdc, hbm)
	hhdc := hhdc ? hhdc : GetDC()
	BitBlt(chdc, 0, 0, _w, _h, hhdc, _x, _y, Raster)
	ReleaseDC(hhdc)

	pBitmap := Gdip_CreateBitmapFromHBITMAP(hbm)

	SelectObject(chdc, obm)
	DeleteObject(hbm)
	DeleteDC(hhdc)
	DeleteDC(chdc)
	return pBitmap
}

;#####################################################################################

; Function				Gdip_BitmapFromHWND
; Description			Uses PrintWindow to get a handle to the specified window and return a bitmap from it
;
; hwnd					handle to the window to get a bitmap from
;
; return				if the function succeeds, the return value is a pointer to a gdi+ bitmap
;
; notes					Window must not be not minimised in order to get a handle to it's client area

Gdip_BitmapFromHWND(hwnd)
{
	WinGetRect(hwnd,,, &Width, &Height)
	hbm := CreateDIBSection(Width, Height), hdc := CreateCompatibleDC(), obm := SelectObject(hdc, hbm)
	PrintWindow(hwnd, hdc)
	pBitmap := Gdip_CreateBitmapFromHBITMAP(hbm)
	SelectObject(hdc, obm), DeleteObject(hbm), DeleteDC(hdc)
	return pBitmap
}

;#####################################################################################

; Function				CreateRectF
; Description			Creates a RectF object, containing a the coordinates and dimensions of a rectangle
;
; RectF					Name to call the RectF object
; x						x-coordinate of the upper left corner of the rectangle
; y						y-coordinate of the upper left corner of the rectangle
; w						Width of the rectangle
; h						Height of the rectangle
;
; return				No return value

CreateRectF(&RectF, x, y, w, h)
{
	RectF := Buffer(16)
	NumPut(
		"Float", x, 
		"Float", y, 
		"Float", w, 
		"Float", h, 
		RectF)
}

;#####################################################################################

; Function				CreateRect
; Description			Creates a Rect object, containing a the coordinates and dimensions of a rectangle
;
; RectF		 			Name to call the RectF object
; x						x-coordinate of the upper left corner of the rectangle
; y						y-coordinate of the upper left corner of the rectangle
; w						Width of the rectangle
; h						Height of the rectangle
;
; return				No return value
CreateRect(&Rect, x, y, w, h)
{
	Rect := Buffer(16)
	NumPut("UInt", x, "UInt", y, "UInt", w, "UInt", h, Rect)
}
;#####################################################################################

; Function				CreateSizeF
; Description			Creates a SizeF object, containing an 2 values
;
; SizeF					Name to call the SizeF object
; w						w-value for the SizeF object
; h						h-value for the SizeF object
;
; return				No Return value

CreateSizeF(&SizeF, w, h)
{
	SizeF := Buffer(8)
	NumPut("Float", w, "Float", h, SizeF)
}
;#####################################################################################

; Function				CreatePointF
; Description			Creates a SizeF object, containing an 2 values
;
; SizeF					Name to call the SizeF object
; w						w-value for the SizeF object
; h						h-value for the SizeF object
;
; return				No Return value

CreatePointF(&PointF, x, y)
{
	PointF := Buffer(8)
	NumPut("Float", x, "Float", y, PointF)
}
;#####################################################################################

; Function				CreateDIBSection
; Description			The CreateDIBSection function creates a DIB (Device Independent Bitmap) that applications can write to directly
;
; w						width of the bitmap to create
; h						height of the bitmap to create
; hdc					a handle to the device context to use the palette from
; bpp					bits per pixel (32 = ARGB)
; ppvBits				A pointer to a variable that receives a pointer to the location of the DIB bit values
;
; return				returns a DIB. A gdi bitmap
;
; notes					ppvBits will receive the location of the pixels in the DIB

CreateDIBSection(w, h, hdc:="", bpp:=32, &ppvBits:=0)
{
	hdc2 := hdc ? hdc : GetDC()
	bi := Buffer(40, 0)

	NumPut("UInt", 40, "UInt", w, "UInt", h, "ushort", 1, "ushort", bpp, "UInt", 0, bi)

	hbm := DllCall("CreateDIBSection"
					, "UPtr", hdc2
					, "UPtr", bi.Ptr
					, "UInt", 0
					, "UPtr*", &ppvBits
					, "UPtr", 0
					, "UInt", 0, "UPtr")

	if (!hdc) {
		ReleaseDC(hdc2)
	}
	return hbm
}

;#####################################################################################

; Function				PrintWindow
; Description			The PrintWindow function copies a visual window into the specified device context (DC), typically a printer DC
;
; hwnd					A handle to the window that will be copied
; hdc					A handle to the device context
; Flags					Drawing options
;
; return				if the function succeeds, it returns a nonzero value
;
; PW_CLIENTONLY			= 1

PrintWindow(hwnd, hdc, Flags:=0)
{
	return DllCall("PrintWindow", "UPtr", hwnd, "UPtr", hdc, "UInt", Flags)
}

;#####################################################################################

; Function				DestroyIcon
; Description			Destroys an icon and frees any memory the icon occupied
;
; hIcon					Handle to the icon to be destroyed. The icon must not be in use
;
; return				if the function succeeds, the return value is nonzero

DestroyIcon(hIcon)
{
	return DllCall("DestroyIcon", "UPtr", hIcon)
}

;#####################################################################################

; Function:				GetIconDimensions
; Description:			Retrieves a given icon/cursor's width and height
;
; hIcon					Pointer to an icon or cursor
; Width					ByRef variable. This variable is set to the icon's width
; Height				ByRef variable. This variable is set to the icon's height
;
; return				if the function succeeds, the return value is zero, otherwise:
;						-1 = Could not retrieve the icon's info. Check A_LastError for extended information
;						-2 = Could not delete the icon's bitmask bitmap
;						-3 = Could not delete the icon's color bitmap

GetIconDimensions(hIcon, &Width:=0, &Height:=0) {
	ICONINFO := Buffer(size := 16 + 2 * A_PtrSize, 0)

	if !DllCall("user32\GetIconInfo", "UPtr", hIcon, "UPtr", ICONINFO.Ptr) {
		return -1
	}

	hbmMask := NumGet(ICONINFO.Ptr, 16, "UPtr")
	hbmColor := NumGet(ICONINFO.Ptr, 16 + A_PtrSize, "UPtr")
	BITMAP := Buffer(size, 0)

	if DllCall("gdi32\GetObject", "UPtr", hbmColor, "Int", size, "UPtr", BITMAP.Ptr) {
		Width := NumGet(BITMAP.Ptr, 4, "Int")
		Height := NumGet(BITMAP.Ptr, 8, "Int")
	}

	if !DllCall("gdi32\DeleteObject", "UPtr", hbmMask) {
		return -2
	}

	if !DllCall("gdi32\DeleteObject", "UPtr", hbmColor) {
		return -3
	}

	return 0
}

;#####################################################################################

PaintDesktop(hdc)
{
	return DllCall("PaintDesktop", "UPtr", hdc)
}

;#####################################################################################

CreateCompatibleBitmap(hdc, w, h)
{
	return DllCall("gdi32\CreateCompatibleBitmap", "UPtr", hdc, "Int", w, "Int", h)
}

;#####################################################################################

; Function				CreateCompatibleDC
; Description			This function creates a memory device context (DC) compatible with the specified device
;
; hdc					Handle to an existing device context
;
; return				returns the handle to a device context or 0 on failure
;
; notes					if this handle is 0 (by default), the function creates a memory device context compatible with the application's current screen

CreateCompatibleDC(hdc:=0)
{
	return DllCall("CreateCompatibleDC", "UPtr", hdc)
}

;#####################################################################################

; Function				SelectObject
; Description			The SelectObject function selects an object into the specified device context (DC). The new object replaces the previous object of the same type
;
; hdc					Handle to a DC
; hgdiobj				A handle to the object to be selected into the DC
;
; return				if the selected object is not a region and the function succeeds, the return value is a handle to the object being replaced
;
; notes					The specified object must have been created by using one of the following functions
;						Bitmap - CreateBitmap, CreateBitmapIndirect, CreateCompatibleBitmap, CreateDIBitmap, CreateDIBSection (A single bitmap cannot be selected into more than one DC at the same time)
;						Brush - CreateBrushIndirect, CreateDIBPatternBrush, CreateDIBPatternBrushPt, CreateHatchBrush, CreatePatternBrush, CreateSolidBrush
;						Font - CreateFont, CreateFontIndirect
;						Pen - CreatePen, CreatePenIndirect
;						Region - CombineRgn, CreateEllipticRgn, CreateEllipticRgnIndirect, CreatePolygonRgn, CreateRectRgn, CreateRectRgnIndirect
;
; notes					if the selected object is a region and the function succeeds, the return value is one of the following value
;
; SIMPLEREGION			= 2 Region consists of a single rectangle
; COMPLEXREGION			= 3 Region consists of more than one rectangle
; NULLREGION			= 1 Region is empty

SelectObject(hdc, hgdiobj)
{
	return DllCall("SelectObject", "UPtr", hdc, "UPtr", hgdiobj)
}

;#####################################################################################

; Function				DeleteObject
; Description			This function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object
;						After the object is deleted, the specified handle is no longer valid
;
; hObject				Handle to a logical pen, brush, font, bitmap, region, or palette to delete
;
; return				Nonzero indicates success. Zero indicates that the specified handle is not valid or that the handle is currently selected into a device context

DeleteObject(hObject)
{
	return DllCall("DeleteObject", "UPtr", hObject)
}

;#####################################################################################

; Function				GetDC
; Description			This function retrieves a handle to a display device context (DC) for the client area of the specified window.
;						The display device context can be used in subsequent graphics display interface (GDI) functions to draw in the client area of the window.
;
; hwnd					Handle to the window whose device context is to be retrieved. If this value is NULL, GetDC retrieves the device context for the entire screen
;
; return				The handle the device context for the specified window's client area indicates success. NULL indicates failure

GetDC(hwnd:=0)
{
	return DllCall("GetDC", "UPtr", hwnd)
}

;#####################################################################################

; DCX_CACHE = 0x2
; DCX_CLIPCHILDREN = 0x8
; DCX_CLIPSIBLINGS = 0x10
; DCX_EXCLUDERGN = 0x40
; DCX_EXCLUDEUPDATE = 0x100
; DCX_INTERSECTRGN = 0x80
; DCX_INTERSECTUPDATE = 0x200
; DCX_LOCKWINDOWUPDATE = 0x400
; DCX_NORECOMPUTE = 0x100000
; DCX_NORESETATTRS = 0x4
; DCX_PARENTCLIP = 0x20
; DCX_VALIDATE = 0x200000
; DCX_WINDOW = 0x1

GetDCEx(hwnd, flags:=0, hrgnClip:=0)
{
	return DllCall("GetDCEx", "UPtr", hwnd, "UPtr", hrgnClip, "Int", flags)
}

;#####################################################################################

; Function				ReleaseDC
; Description			This function releases a device context (DC), freeing it for use by other applications. The effect of ReleaseDC depends on the type of device context
;
; hdc					Handle to the device context to be released
; hwnd					Handle to the window whose device context is to be released
;
; return				1 = released
;						0 = not released
;
; notes					The application must call the ReleaseDC function for each call to the GetWindowDC function and for each call to the GetDC function that retrieves a common device context
;						An application cannot use the ReleaseDC function to release a device context that was created by calling the CreateDC function; instead, it must use the DeleteDC function.

ReleaseDC(hdc, hwnd:=0)
{
	return DllCall("ReleaseDC", "UPtr", hwnd, "UPtr", hdc)
}

;#####################################################################################

; Function				DeleteDC
; Description			The DeleteDC function deletes the specified device context (DC)
;
; hdc					A handle to the device context
;
; return				if the function succeeds, the return value is nonzero
;
; notes					An application must not delete a DC whose handle was obtained by calling the GetDC function. Instead, it must call the ReleaseDC function to free the DC

DeleteDC(hdc)
{
	return DllCall("DeleteDC", "UPtr", hdc)
}
;#####################################################################################

; Function				Gdip_LibraryVersion
; Description			Get the current library version
;
; return				the library version
;
; notes					This is useful for non compiled programs to ensure that a person doesn't run an old version when testing your scripts

Gdip_LibraryVersion()
{
	return 1.45
}

;#####################################################################################

; Function				Gdip_LibrarySubVersion
; Description			Get the current library sub version
;
; return				the library sub version
;
; notes					This is the sub-version currently maintained by Rseding91
; 					Updated by guest3456 preliminary AHK v2 support
Gdip_LibrarySubVersion()
{
	return 1.54
}

;#####################################################################################

; Function:				Gdip_BitmapFromBRA
; Description: 			Gets a pointer to a gdi+ bitmap from a BRA file
;
; BRAFromMemIn			The variable for a BRA file read to memory
; File					The name of the file, or its number that you would like (This depends on alternate parameter)
; Alternate				Changes whether the File parameter is the file name or its number
;
; return					if the function succeeds, the return value is a pointer to a gdi+ bitmap
;						-1 = The BRA variable is empty
;						-2 = The BRA has an incorrect header
;						-3 = The BRA has information missing
;						-4 = Could not find file inside the BRA

Gdip_BitmapFromBRA(BRAFromMemIn, File, Alternate := 0) {
	if (!BRAFromMemIn) {
		return -1
	}

	Headers := StrSplit(StrGet(BRAFromMemIn.Ptr, 256, "CP0"), "`n")
	Header := StrSplit(Headers[1], "|")
	HeaderLength := Header.Length

	if (HeaderLength != 4) || (Header[2] != "BRA!") {
		return -2
	}

	_Info := StrSplit(Headers[2], "|")
	_InfoLength := _Info.Length

	if (_InfoLength != 3) {
		return -3
	}

	OffsetTOC := StrPut(Headers[1], "CP0") + StrPut(Headers[2], "CP0") ;  + 2
	OffsetData := _Info[2]
	SearchIndex := Alternate ? 1 : 2
	TOC := StrGet(BRAFromMemIn.Ptr + OffsetTOC, OffsetData - OffsetTOC - 1, "CP0")
	RX1 := "mi`n)^"
	Offset := Size := 0

	if RegExMatch(TOC, RX1 . (Alternate ? File "\|.+?" : "\d+\|" . File) . "\|(\d+)\|(\d+)$", &FileInfo:="") {
		Offset := OffsetData + FileInfo[1]
		Size := FileInfo[2]
	}

	if (Size = 0) {
		return -4
	}

	hData := DllCall("GlobalAlloc", "UInt", 2, "UInt", Size, "UPtr")
	pData := DllCall("GlobalLock", "Ptr", hData, "UPtr")
	DllCall("RtlMoveMemory", "Ptr", pData, "Ptr", BRAFromMemIn.Ptr + Offset, "Ptr", Size)
	DllCall("GlobalUnlock", "Ptr", hData)
	DllCall("Ole32.dll\CreateStreamOnHGlobal", "Ptr", hData, "Int", 1, "Ptr*", &pStream:=0)
	DllCall("Gdiplus.dll\GdipCreateBitmapFromStream", "Ptr", pStream, "Ptr*", &pBitmap:=0)
	ObjRelease(pStream)

	return pBitmap
}

;#####################################################################################

; Function:				Gdip_BitmapFromBase64
; Description:			Creates a bitmap from a Base64 encoded string
;
; Base64				ByRef variable. Base64 encoded string. Immutable, ByRef to avoid performance overhead of passing long strings.
;
; return				if the function succeeds, the return value is a pointer to a bitmap, otherwise:
;						-1 = Could not calculate the length of the required buffer
;						-2 = Could not decode the Base64 encoded string
;						-3 = Could not create a memory stream

Gdip_BitmapFromBase64(&Base64)
{
	; calculate the length of the buffer needed
	if !(DllCall("crypt32\CryptStringToBinary", "UPtr", StrPtr(Base64), "UInt", 0, "UInt", 0x01, "UPtr", 0, "UInt*", &DecLen:=0, "UPtr", 0, "UPtr", 0)) {
		return -1
	}

	Dec := Buffer(DecLen, 0)

	; decode the Base64 encoded string
	if !(DllCall("crypt32\CryptStringToBinary", "UPtr", StrPtr(Base64), "UInt", 0, "UInt", 0x01, "UPtr", Dec.Ptr, "UInt*", &DecLen, "UPtr", 0, "UPtr", 0)) {
		return -2
	}

	; create a memory stream
	if !(pStream := DllCall("shlwapi\SHCreateMemStream", "UPtr", Dec.Ptr, "UInt", DecLen, "UPtr")) {
		return -3
	}

	DllCall("gdiplus\GdipCreateBitmapFromStreamICM", "UPtr", pStream, "Ptr*", &pBitmap:=0)
	ObjRelease(pStream)

	return pBitmap
}

;#####################################################################################

; Function:				Gdip_EncodeBitmapTo64string
; Description:			Encode a bitmap to a Base64 encoded string
;
; pBitmap				Pointer to a bitmap
; sOutput				The name of the file that the bitmap will be saved to. Supported extensions are: .BMP,.DIB,.RLE,.JPG,.JPEG,.JPE,.JFIF,.GIF,.TIF,.TIFF,.PNG
; Quality				if saving as jpg (.JPG,.JPEG,.JPE,.JFIF) then quality can be 1-100 with default at maximum quality
;
; return				if the function succeeds, the return value is a Base64 encoded string of the pBitmap

Gdip_EncodeBitmapTo64string(pBitmap, extension := "png", quality := "") {

    ; Fill a buffer with the available image codec info.
    DllCall("gdiplus\GdipGetImageEncodersSize", "uint*", &count:=0, "uint*", &size:=0)
    DllCall("gdiplus\GdipGetImageEncoders", "uint", count, "uint", size, "ptr", ci := Buffer(size))

    ; struct ImageCodecInfo - http://www.jose.it-berater.org/gdiplus/reference/structures/imagecodecinfo.htm
    loop {
        if (A_Index > count)
        throw Error("Could not find a matching encoder for the specified file format.")

        idx := (48+7*A_PtrSize)*(A_Index-1)
    } until InStr(StrGet(NumGet(ci, idx+32+3*A_PtrSize, "ptr"), "UTF-16"), extension) ; FilenameExtension

    ; Get the pointer to the clsid of the matching encoder.
    pCodec := ci.ptr + idx ; ClassID

    ; JPEG default quality is 75. Otherwise set a quality value from [0-100].
    if (quality ~= "^-?\d+$") and ("image/jpeg" = StrGet(NumGet(ci, idx+32+4*A_PtrSize, "ptr"), "UTF-16")) { ; MimeType
        ; Use a separate buffer to store the quality as ValueTypeLong (4).
        v := Buffer(4)
		NumPut("uint", quality, v)

        ; struct EncoderParameter - http://www.jose.it-berater.org/gdiplus/reference/structures/encoderparameter.htm
        ; enum ValueType - https://docs.microsoft.com/en-us/dotnet/api/system.drawing.imaging.encoderparametervaluetype
        ; clsid Image Encoder Constants - http://www.jose.it-berater.org/gdiplus/reference/constants/gdipimageencoderconstants.htm
        ep := Buffer(24+2*A_PtrSize)                  ; sizeof(EncoderParameter) = ptr + n*(28, 32)
        NumPut(  "uptr",     1, ep,            0)  ; Count
        DllCall("ole32\CLSIDFromString", "wstr", "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}", "ptr", ep.ptr+A_PtrSize, "HRESULT")
        NumPut(  "uint",     1, ep, 16+A_PtrSize)  ; Number of Values
        NumPut(  "uint",     4, ep, 20+A_PtrSize)  ; Type
        NumPut(   "ptr", v.ptr, ep, 24+A_PtrSize)  ; Value
    }

    ; Create a Stream.
    DllCall("ole32\CreateStreamOnHGlobal", "ptr", 0, "int", True, "ptr*", &pStream:=0, "HRESULT")
    DllCall("gdiplus\GdipSaveImageToStream", "ptr", pBitmap, "ptr", pStream, "ptr", pCodec, "ptr", IsSet(ep) ? ep : 0)

    ; Get a pointer to binary data.
    DllCall("ole32\GetHGlobalFromStream", "ptr", pStream, "ptr*", &hbin:=0, "HRESULT")
    bin := DllCall("GlobalLock", "ptr", hbin, "ptr")
    size := DllCall("GlobalSize", "uint", bin, "uptr")

    ; Calculate the length of the base64 string.
    flags := 0x40000001 ; CRYPT_STRING_NOCRLF | CRYPT_STRING_BASE64
    length := 4 * Ceil(size/3) + 1 ; An extra byte of padding is required.
    str := Buffer(length)

    ; Using CryptBinaryToStringA saves about 2MB in memory.
    DllCall("crypt32\CryptBinaryToStringA", "ptr", bin, "uint", size, "uint", flags, "ptr", str, "uint*", &length)

    ; Release binary data and stream.
    DllCall("GlobalUnlock", "ptr", hbin)
    ObjRelease(pStream)
    
    ; Return encoded string length minus 1.
    return StrGet(str, length, "CP0")
}

;#####################################################################################

; Function				Gdip_DrawRectangle
; Description			This function uses a pen to draw the outline of a rectangle into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x						x-coordinate of the top left of the rectangle
; y						y-coordinate of the top left of the rectangle
; w						width of the rectanlge
; h						height of the rectangle
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawRectangle(pGraphics, pPen, x, y, w, h)
{
	return DllCall("gdiplus\GdipDrawRectangle", "UPtr", pGraphics, "UPtr", pPen, "Float", x, "Float", y, "Float", w, "Float", h)
}

;#####################################################################################

; Function				Gdip_DrawRoundedRectangle
; Description			This function uses a pen to draw the outline of a rounded rectangle into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x						x-coordinate of the top left of the rounded rectangle
; y						y-coordinate of the top left of the rounded rectangle
; w						width of the rectanlge
; h						height of the rectangle
; r						radius of the rounded corners
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawRoundedRectangle(pGraphics, pPen, x, y, w, h, r)
{
	Gdip_SetClipRect(pGraphics, x-r, y-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x+w-r, y-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x-r, y+h-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x+w-r, y+h-r, 2*r, 2*r, 4)
	_E := Gdip_DrawRectangle(pGraphics, pPen, x, y, w, h)
	Gdip_ResetClip(pGraphics)
	Gdip_SetClipRect(pGraphics, x-(2*r), y+r, w+(4*r), h-(2*r), 4)
	Gdip_SetClipRect(pGraphics, x+r, y-(2*r), w-(2*r), h+(4*r), 4)
	Gdip_DrawEllipse(pGraphics, pPen, x, y, 2*r, 2*r)
	Gdip_DrawEllipse(pGraphics, pPen, x+w-(2*r), y, 2*r, 2*r)
	Gdip_DrawEllipse(pGraphics, pPen, x, y+h-(2*r), 2*r, 2*r)
	Gdip_DrawEllipse(pGraphics, pPen, x+w-(2*r), y+h-(2*r), 2*r, 2*r)
	Gdip_ResetClip(pGraphics)
	return _E
}

;#####################################################################################

; Function				Gdip_DrawEllipse
; Description			This function uses a pen to draw the outline of an ellipse into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x						x-coordinate of the top left of the rectangle the ellipse will be drawn into
; y						y-coordinate of the top left of the rectangle the ellipse will be drawn into
; w						width of the ellipse
; h						height of the ellipse
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawEllipse(pGraphics, pPen, x, y, w, h)
{
	return DllCall("gdiplus\GdipDrawEllipse", "UPtr", pGraphics, "UPtr", pPen, "Float", x, "Float", y, "Float", w, "Float", h)
}

;#####################################################################################

; Function				Gdip_DrawBezier
; Description			This function uses a pen to draw the outline of a bezier (a weighted curve) into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x1					x-coordinate of the start of the bezier
; y1					y-coordinate of the start of the bezier
; x2					x-coordinate of the first arc of the bezier
; y2					y-coordinate of the first arc of the bezier
; x3					x-coordinate of the second arc of the bezier
; y3					y-coordinate of the second arc of the bezier
; x4					x-coordinate of the end of the bezier
; y4					y-coordinate of the end of the bezier
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawBezier(pGraphics, pPen, x1, y1, x2, y2, x3, y3, x4, y4)
{
	return DllCall("gdiplus\GdipDrawBezier"
					, "UPtr", pgraphics
					, "UPtr", pPen
					, "Float", x1
					, "Float", y1
					, "Float", x2
					, "Float", y2
					, "Float", x3
					, "Float", y3
					, "Float", x4
					, "Float", y4)
}

;#####################################################################################

; Function				Gdip_DrawArc
; Description			This function uses a pen to draw the outline of an arc into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x						x-coordinate of the start of the arc
; y						y-coordinate of the start of the arc
; w						width of the arc
; h						height of the arc
; StartAngle			specifies the angle between the x-axis and the starting point of the arc
; SweepAngle			specifies the angle between the starting and ending points of the arc
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawArc(pGraphics, pPen, x, y, w, h, StartAngle, SweepAngle)
{
	return DllCall("gdiplus\GdipDrawArc"
					, "UPtr", pGraphics
					, "UPtr", pPen
					, "Float", x
					, "Float", y
					, "Float", w
					, "Float", h
					, "Float", StartAngle
					, "Float", SweepAngle)
}

;#####################################################################################

; Function				Gdip_DrawPie
; Description			This function uses a pen to draw the outline of a pie into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x						x-coordinate of the start of the pie
; y						y-coordinate of the start of the pie
; w						width of the pie
; h						height of the pie
; StartAngle			specifies the angle between the x-axis and the starting point of the pie
; SweepAngle			specifies the angle between the starting and ending points of the pie
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawPie(pGraphics, pPen, x, y, w, h, StartAngle, SweepAngle)
{
	return DllCall("gdiplus\GdipDrawPie", "UPtr", pGraphics, "UPtr", pPen, "Float", x, "Float", y, "Float", w, "Float", h, "Float", StartAngle, "Float", SweepAngle)
}

;#####################################################################################

; Function				Gdip_DrawLine
; Description			This function uses a pen to draw a line into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x1					x-coordinate of the start of the line
; y1					y-coordinate of the start of the line
; x2					x-coordinate of the end of the line
; y2					y-coordinate of the end of the line
;
; return				status enumeration. 0 = success

Gdip_DrawLine(pGraphics, pPen, x1, y1, x2, y2)
{
	return DllCall("gdiplus\GdipDrawLine"
					, "UPtr", pGraphics
					, "UPtr", pPen
					, "Float", x1
					, "Float", y1
					, "Float", x2
					, "Float", y2)
}

;#####################################################################################

; Function				Gdip_DrawLines
; Description			This function uses a pen to draw a series of joined lines into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; Points				the coordinates of all the points passed as x1,y1|x2,y2|x3,y3.....
;
; return				status enumeration. 0 = success

Gdip_DrawLines(pGraphics, pPen, points)
{
	points := StrSplit(points, "|")
	pointF := Buffer(8*points.Length)
	pointsLength := 0
	for point in points {
		coords := StrSplit(point, ",")
		if (coords.Length != 2) {
			if (coords.Length > 0) {
				MsgBox("Skipping wrong points of length " coords.Length)
			}
			continue
		}
		NumPut("Float", coords[1], pointF, 8*(A_Index-1))
		NumPut("Float", coords[2], pointF, (8*(A_Index-1))+4)
		pointsLength += 1
	}
	return DllCall("gdiplus\GdipDrawLines", "UPtr", pGraphics, "UPtr", pPen, "UPtr", pointF.Ptr, "Int", pointsLength)
}

;#####################################################################################

; Function				Gdip_FillRectangle
; Description			This function uses a brush to fill a rectangle in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; x						x-coordinate of the top left of the rectangle
; y						y-coordinate of the top left of the rectangle
; w						width of the rectanlge
; h						height of the rectangle
;
; return				status enumeration. 0 = success

Gdip_FillRectangle(pGraphics, pBrush, x, y, w, h)
{
	return DllCall("gdiplus\GdipFillRectangle"
					, "UPtr", pGraphics
					, "UPtr", pBrush
					, "Float", x
					, "Float", y
					, "Float", w
					, "Float", h)
}

;#####################################################################################

; Function				Gdip_FillRoundedRectangle
; Description			This function uses a brush to fill a rounded rectangle in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; x						x-coordinate of the top left of the rounded rectangle
; y						y-coordinate of the top left of the rounded rectangle
; w						width of the rectanlge
; h						height of the rectangle
; r						radius of the rounded corners
;
; return				status enumeration. 0 = success

Gdip_FillRoundedRectangle(pGraphics, pBrush, x, y, w, h, r)
{
	Region := Gdip_GetClipRegion(pGraphics)
	Gdip_SetClipRect(pGraphics, x-r, y-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x+w-r, y-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x-r, y+h-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x+w-r, y+h-r, 2*r, 2*r, 4)
	_E := Gdip_FillRectangle(pGraphics, pBrush, x, y, w, h)
	Gdip_SetClipRegion(pGraphics, Region, 0)
	Gdip_SetClipRect(pGraphics, x-(2*r), y+r, w+(4*r), h-(2*r), 4)
	Gdip_SetClipRect(pGraphics, x+r, y-(2*r), w-(2*r), h+(4*r), 4)
	Gdip_FillEllipse(pGraphics, pBrush, x, y, 2*r, 2*r)
	Gdip_FillEllipse(pGraphics, pBrush, x+w-(2*r), y, 2*r, 2*r)
	Gdip_FillEllipse(pGraphics, pBrush, x, y+h-(2*r), 2*r, 2*r)
	Gdip_FillEllipse(pGraphics, pBrush, x+w-(2*r), y+h-(2*r), 2*r, 2*r)
	Gdip_SetClipRegion(pGraphics, Region, 0)
	Gdip_DeleteRegion(Region)
	return _E
}

;#####################################################################################

; Function				Gdip_FillPolygon
; Description			This function uses a brush to fill a polygon in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; Points				the coordinates of all the points passed as x1,y1|x2,y2|x3,y3.....
;
; return				status enumeration. 0 = success
;
; notes					Alternate will fill the polygon as a whole, wheras winding will fill each new "segment"
; Alternate 			= 0
; Winding 				= 1

Gdip_FillPolygon(pGraphics, pBrush, Points, FillMode:=0)
{
	Points := StrSplit(Points, "|")
	PointsLength := Points.Length
	PointF := Buffer(8*PointsLength)
	For eachPoint, Point in Points
	{
		Coord := StrSplit(Point, ",")
		NumPut("Float", Coord[1], PointF, 8*(A_Index-1))
		NumPut("Float", Coord[2], PointF, (8*(A_Index-1))+4)
	}
	return DllCall("gdiplus\GdipFillPolygon", "UPtr", pGraphics, "UPtr", pBrush, "UPtr", PointF.Ptr, "Int", PointsLength, "Int", FillMode)
}

;#####################################################################################

; Function				Gdip_FillPie
; Description			This function uses a brush to fill a pie in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; x						x-coordinate of the top left of the pie
; y						y-coordinate of the top left of the pie
; w						width of the pie
; h						height of the pie
; StartAngle			specifies the angle between the x-axis and the starting point of the pie
; SweepAngle			specifies the angle between the starting and ending points of the pie
;
; return				status enumeration. 0 = success

Gdip_FillPie(pGraphics, pBrush, x, y, w, h, StartAngle, SweepAngle)
{
	return DllCall("gdiplus\GdipFillPie"
					, "UPtr", pGraphics
					, "UPtr", pBrush
					, "Float", x
					, "Float", y
					, "Float", w
					, "Float", h
					, "Float", StartAngle
					, "Float", SweepAngle)
}

;#####################################################################################

; Function				Gdip_FillEllipse
; Description			This function uses a brush to fill an ellipse in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; x						x-coordinate of the top left of the ellipse
; y						y-coordinate of the top left of the ellipse
; w						width of the ellipse
; h						height of the ellipse
;
; return				status enumeration. 0 = success

Gdip_FillEllipse(pGraphics, pBrush, x, y, w, h)
{
	return DllCall("gdiplus\GdipFillEllipse", "UPtr", pGraphics, "UPtr", pBrush, "Float", x, "Float", y, "Float", w, "Float", h)
}

;#####################################################################################

; Function				Gdip_FillRegion
; Description			This function uses a brush to fill a region in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; Region				Pointer to a Region
;
; return				status enumeration. 0 = success
;
; notes					You can create a region Gdip_CreateRegion() and then add to this

Gdip_FillRegion(pGraphics, pBrush, Region)
{
	return DllCall("gdiplus\GdipFillRegion", "UPtr", pGraphics, "UPtr", pBrush, "UPtr", Region)
}

;#####################################################################################

; Function				Gdip_FillPath
; Description			This function uses a brush to fill a path in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; Region				Pointer to a Path
;
; return				status enumeration. 0 = success

Gdip_FillPath(pGraphics, pBrush, pPath)
{
	return DllCall("gdiplus\GdipFillPath", "UPtr", pGraphics, "UPtr", pBrush, "UPtr", pPath)
}

;#####################################################################################

; Function				Gdip_DrawImagePointsRect
; Description			This function draws a bitmap into the Graphics of another bitmap and skews it
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBitmap				Pointer to a bitmap to be drawn
; Points				Points passed as x1,y1|x2,y2|x3,y3 (3 points: top left, top right, bottom left) describing the drawing of the bitmap
; sx					x-coordinate of source upper-left corner
; sy					y-coordinate of source upper-left corner
; sw					width of source rectangle
; sh					height of source rectangle
; Matrix				a matrix used to alter image attributes when drawing
;
; return				status enumeration. 0 = success
;
; notes					if sx,sy,sw,sh are missed then the entire source bitmap will be used
;						Matrix can be omitted to just draw with no alteration to ARGB
;						Matrix may be passed as a digit from 0 - 1 to change just transparency
;						Matrix can be passed as a matrix with any delimiter

Gdip_DrawImagePointsRect(pGraphics, pBitmap, Points, sx:="", sy:="", sw:="", sh:="", Matrix:=1)
{
	Points := StrSplit(Points, "|")
	PointsLength := Points.Length
	PointF := Buffer(8*PointsLength)
	For eachPoint, Point in Points
	{
		Coord := StrSplit(Point, ",")
		NumPut("Float", Coord[1], PointF, 8*(A_Index-1))
		NumPut("Float", Coord[2], PointF, (8*(A_Index-1))+4)
	}

	if !IsNumber(Matrix)
		ImageAttr := Gdip_SetImageAttributesColorMatrix(Matrix)
	else if (Matrix != 1)
		ImageAttr := Gdip_SetImageAttributesColorMatrix("1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|" Matrix "|0|0|0|0|0|1")
	else
		ImageAttr := 0

	if (sx = "" && sy = "" && sw = "" && sh = "")
	{
		sx := 0, sy := 0
		sw := Gdip_GetImageWidth(pBitmap)
		sh := Gdip_GetImageHeight(pBitmap)
	}

	_E := DllCall("gdiplus\GdipDrawImagePointsRect"
				, "UPtr", pGraphics
				, "UPtr", pBitmap
				, "UPtr", PointF.Ptr
				, "Int", PointsLength
				, "Float", sx
				, "Float", sy
				, "Float", sw
				, "Float", sh
				, "Int", 2
				, "UPtr", ImageAttr
				, "UPtr", 0
				, "UPtr", 0)
	if ImageAttr
		Gdip_DisposeImageAttributes(ImageAttr)
	return _E
}

;#####################################################################################

; Function				Gdip_DrawImage
; Description			This function draws a bitmap into the Graphics of another bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBitmap				Pointer to a bitmap to be drawn
; dx					x-coord of destination upper-left corner
; dy					y-coord of destination upper-left corner
; dw					width of destination image
; dh					height of destination image
; sx					x-coordinate of source upper-left corner
; sy					y-coordinate of source upper-left corner
; sw					width of source image
; sh					height of source image
; Matrix				a matrix used to alter image attributes when drawing
;
; return				status enumeration. 0 = success
;
; notes					if sx,sy,sw,sh are missed then the entire source bitmap will be used
;						Gdip_DrawImage performs faster
;						Matrix can be omitted to just draw with no alteration to ARGB
;						Matrix may be passed as a digit from 0 - 1 to change just transparency
;						Matrix can be passed as a matrix with any delimiter. For example:
;						MatrixBright=
;						(
;						1.5		|0		|0		|0		|0
;						0		|1.5	|0		|0		|0
;						0		|0		|1.5	|0		|0
;						0		|0		|0		|1		|0
;						0.05	|0.05	|0.05	|0		|1
;						)
;
; notes					MatrixBright = 1.5|0|0|0|0|0|1.5|0|0|0|0|0|1.5|0|0|0|0|0|1|0|0.05|0.05|0.05|0|1
;						MatrixGreyScale = 0.299|0.299|0.299|0|0|0.587|0.587|0.587|0|0|0.114|0.114|0.114|0|0|0|0|0|1|0|0|0|0|0|1
;						MatrixNegative = -1|0|0|0|0|0|-1|0|0|0|0|0|-1|0|0|0|0|0|1|0|1|1|1|0|1

Gdip_DrawImage(pGraphics, pBitmap, dx:="", dy:="", dw:="", dh:="", sx:="", sy:="", sw:="", sh:="", Matrix:=1)
{
	if !IsNumber(Matrix)
		ImageAttr := Gdip_SetImageAttributesColorMatrix(Matrix)
	else if (Matrix != 1)
		ImageAttr := Gdip_SetImageAttributesColorMatrix("1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|" Matrix "|0|0|0|0|0|1")
	else
		ImageAttr := 0

	if (sx = "" && sy = "" && sw = "" && sh = "")
	{
		if (dx = "" && dy = "" && dw = "" && dh = "")
		{
			sx := dx := 0, sy := dy := 0
			sw := dw := Gdip_GetImageWidth(pBitmap)
			sh := dh := Gdip_GetImageHeight(pBitmap)
		}
		else
		{
			sx := sy := 0
			sw := Gdip_GetImageWidth(pBitmap)
			sh := Gdip_GetImageHeight(pBitmap)
		}
	}

	_E := DllCall("gdiplus\GdipDrawImageRectRect"
				, "UPtr", pGraphics
				, "UPtr", pBitmap
				, "Float", dx
				, "Float", dy
				, "Float", dw
				, "Float", dh
				, "Float", sx
				, "Float", sy
				, "Float", sw
				, "Float", sh
				, "Int", 2
				, "UPtr", ImageAttr
				, "UPtr", 0
				, "UPtr", 0)
	if ImageAttr
		Gdip_DisposeImageAttributes(ImageAttr)
	return _E
}

;#####################################################################################

; Function				Gdip_SetImageAttributesColorMatrix
; Description			This function creates an image matrix ready for drawing
;
; Matrix				a matrix used to alter image attributes when drawing
;						passed with any delimeter
;
; return				returns an image matrix on sucess or 0 if it fails
;
; notes					MatrixBright = 1.5|0|0|0|0|0|1.5|0|0|0|0|0|1.5|0|0|0|0|0|1|0|0.05|0.05|0.05|0|1
;						MatrixGreyScale = 0.299|0.299|0.299|0|0|0.587|0.587|0.587|0|0|0.114|0.114|0.114|0|0|0|0|0|1|0|0|0|0|0|1
;						MatrixNegative = -1|0|0|0|0|0|-1|0|0|0|0|0|-1|0|0|0|0|0|1|0|1|1|1|0|1

Gdip_SetImageAttributesColorMatrix(Matrix)
{
	ColourMatrix := Buffer(100, 0)
	Matrix := RegExReplace(RegExReplace(Matrix, "^[^\d-\.]+([\d\.])", "$1", , 1), "[^\d-\.]+", "|")
	Matrix := StrSplit(Matrix, "|")

	loop 25 {
		M := (Matrix[A_Index] != "") ? Matrix[A_Index] : Mod(A_Index-1, 6) ? 0 : 1
		NumPut("Float", M, ColourMatrix, (A_Index-1)*4)
	}

	DllCall("gdiplus\GdipCreateImageAttributes", "UPtr*", &ImageAttr:=0)
	DllCall("gdiplus\GdipSetImageAttributesColorMatrix", "UPtr", ImageAttr, "Int", 1, "Int", 1, "UPtr", ColourMatrix.Ptr, "UPtr", 0, "Int", 0)

	return ImageAttr
}

;#####################################################################################

; Function				Gdip_GraphicsFromImage
; Description			This function gets the graphics for a bitmap used for drawing functions
;
; pBitmap				Pointer to a bitmap to get the pointer to its graphics
;
; return				returns a pointer to the graphics of a bitmap
;
; notes					a bitmap can be drawn into the graphics of another bitmap

Gdip_GraphicsFromImage(pBitmap)
{
	DllCall("gdiplus\GdipGetImageGraphicsContext", "UPtr", pBitmap, "UPtr*", &pGraphics:=0)
	return pGraphics
}

;#####################################################################################

; Function				Gdip_GraphicsFromHDC
; Description			This function gets the graphics from the handle to a device context
;
; hdc					This is the handle to the device context
;
; return				returns a pointer to the graphics of a bitmap
;
; notes					You can draw a bitmap into the graphics of another bitmap

Gdip_GraphicsFromHDC(hdc)
{
	DllCall("gdiplus\GdipCreateFromHDC", "UPtr", hdc, "UPtr*", &pGraphics:=0)
	return pGraphics
}

;#####################################################################################

; Function				Gdip_GetDC
; Description			This function gets the device context of the passed Graphics
;
; hdc					This is the handle to the device context
;
; return				returns the device context for the graphics of a bitmap

Gdip_GetDC(pGraphics)
{
	DllCall("gdiplus\GdipGetDC", "UPtr", pGraphics, "UPtr*", &hdc:=0)
	return hdc
}

;#####################################################################################

; Function				Gdip_ReleaseDC
; Description			This function releases a device context from use for further use
;
; pGraphics				Pointer to the graphics of a bitmap
; hdc					This is the handle to the device context
;
; return				status enumeration. 0 = success

Gdip_ReleaseDC(pGraphics, hdc)
{
	return DllCall("gdiplus\GdipReleaseDC", "UPtr", pGraphics, "UPtr", hdc)
}

;#####################################################################################

; Function				Gdip_GraphicsClear
; Description			Clears the graphics of a bitmap ready for further drawing
;
; pGraphics				Pointer to the graphics of a bitmap
; ARGB					The colour to clear the graphics to
;
; return				status enumeration. 0 = success
;
; notes					By default this will make the background invisible
;						Using clipping regions you can clear a particular area on the graphics rather than clearing the entire graphics

Gdip_GraphicsClear(pGraphics, ARGB:=0x00ffffff)
{
	return DllCall("gdiplus\GdipGraphicsClear", "UPtr", pGraphics, "Int", ARGB)
}

;#####################################################################################

; Function				Gdip_BlurBitmap
; Description			Gives a pointer to a blurred bitmap from a pointer to a bitmap
;
; pBitmap				Pointer to a bitmap to be blurred
; Blur					The Amount to blur a bitmap by from 1 (least blur) to 100 (most blur)
;
; return				if the function succeeds, the return value is a pointer to the new blurred bitmap
;						-1 = The blur parameter is outside the range 1-100
;
; notes					This function will not dispose of the original bitmap

Gdip_BlurBitmap(pBitmap, Blur)
{
	if (Blur > 100 || Blur < 1) {
		return -1
	}

	sWidth := Gdip_GetImageWidth(pBitmap), sHeight := Gdip_GetImageHeight(pBitmap)
	dWidth := sWidth//Blur, dHeight := sHeight//Blur

	pBitmap1 := Gdip_CreateBitmap(dWidth, dHeight)
	G1 := Gdip_GraphicsFromImage(pBitmap1)
	Gdip_SetInterpolationMode(G1, 7)
	Gdip_DrawImage(G1, pBitmap, 0, 0, dWidth, dHeight, 0, 0, sWidth, sHeight)

	Gdip_DeleteGraphics(G1)

	pBitmap2 := Gdip_CreateBitmap(sWidth, sHeight)
	G2 := Gdip_GraphicsFromImage(pBitmap2)
	Gdip_SetInterpolationMode(G2, 7)
	Gdip_DrawImage(G2, pBitmap1, 0, 0, sWidth, sHeight, 0, 0, dWidth, dHeight)

	Gdip_DeleteGraphics(G2)
	Gdip_DisposeImage(pBitmap1)

	return pBitmap2
}

;#####################################################################################

; Function:				Gdip_SaveBitmapToFile
; Description:			Saves a bitmap to a file in any supported format onto disk
;
; pBitmap				Pointer to a bitmap
; sOutput				The name of the file that the bitmap will be saved to. Supported extensions are: .BMP,.DIB,.RLE,.JPG,.JPEG,.JPE,.JFIF,.GIF,.TIF,.TIFF,.PNG
; Quality				if saving as jpg (.JPG,.JPEG,.JPE,.JFIF) then quality can be 1-100 with default at maximum quality
;
; return				if the function succeeds, the return value is zero, otherwise:
;						-1 = Extension supplied is not a supported file format
;						-2 = Could not get a list of encoders on system
;						-3 = Could not find matching encoder for specified file format
;						-4 = Could not get WideChar name of output file
;						-5 = Could not save file to disk
;
; notes					This function will use the extension supplied from the sOutput parameter to determine the output format

Gdip_SaveBitmapToFile(pBitmap, sOutput, Quality:=75)
{
	_p := 0

	SplitPath sOutput,,, &extension:=""
	if (!RegExMatch(extension, "^(?i:BMP|DIB|RLE|JPG|JPEG|JPE|JFIF|GIF|TIF|TIFF|PNG)$")) {
		return -1
	}
	extension := "." extension

	DllCall("gdiplus\GdipGetImageEncodersSize", "uint*", &nCount:=0, "uint*", &nSize:=0)
	ci := Buffer(nSize)
	DllCall("gdiplus\GdipGetImageEncoders", "UInt", nCount, "UInt", nSize, "UPtr", ci.Ptr)
	if !(nCount && nSize) {
		return -2
	}

	loop nCount {
		address := NumGet(ci, (idx := (48+7*A_PtrSize)*(A_Index-1))+32+3*A_PtrSize, "UPtr")
		sString := StrGet(address, "UTF-16")
		if !InStr(sString, "*" extension)
			continue

		pCodec := ci.Ptr+idx
		break
	}

	if !pCodec {
		return -3
	}

	if (Quality != 75) {
		Quality := (Quality < 0) ? 0 : (Quality > 100) ? 100 : Quality

		if RegExMatch(extension, "^\.(?i:JPG|JPEG|JPE|JFIF)$") {
			DllCall("gdiplus\GdipGetEncoderParameterListSize", "UPtr", pBitmap, "UPtr", pCodec, "uint*", &nSize)
			EncoderParameters := Buffer(nSize, 0)
			DllCall("gdiplus\GdipGetEncoderParameterList", "UPtr", pBitmap, "UPtr", pCodec, "UInt", nSize, "UPtr", EncoderParameters.Ptr)
			nCount := NumGet(EncoderParameters, "UInt")
			loop nCount
			{
				elem := (24+(A_PtrSize ? A_PtrSize : 4))*(A_Index-1) + 4 + (pad := A_PtrSize = 8 ? 4 : 0)
				if (NumGet(EncoderParameters, elem+16, "UInt") = 1) && (NumGet(EncoderParameters, elem+20, "UInt") = 6)
				{
					_p := elem + EncoderParameters.Ptr - pad - 4
					NumPut("UInt", Quality, NumGet(NumPut("UInt", 4, NumPut("UInt", 1, _p+0)+20), "UInt"))
					break
				}
			}
		}
	}

	_E := DllCall("gdiplus\GdipSaveImageToFile", "UPtr", pBitmap, "UPtr", StrPtr(sOutput), "UPtr", pCodec, "UInt", _p ? _p : 0)

	return _E ? -5 : 0
}

;#####################################################################################

; Function				Gdip_GetPixel
; Description			Gets the ARGB of a pixel in a bitmap
;
; pBitmap				Pointer to a bitmap
; x						x-coordinate of the pixel
; y						y-coordinate of the pixel
;
; return				Returns the ARGB value of the pixel

Gdip_GetPixel(pBitmap, x, y)
{
	DllCall("gdiplus\GdipBitmapGetPixel", "UPtr", pBitmap, "Int", x, "Int", y, "uint*", &ARGB:=0)
	return ARGB
}

;#####################################################################################

; Function				Gdip_SetPixel
; Description			Sets the ARGB of a pixel in a bitmap
;
; pBitmap				Pointer to a bitmap
; x						x-coordinate of the pixel
; y						y-coordinate of the pixel
;
; return				status enumeration. 0 = success

Gdip_SetPixel(pBitmap, x, y, ARGB)
{
	return DllCall("gdiplus\GdipBitmapSetPixel", "UPtr", pBitmap, "Int", x, "Int", y, "Int", ARGB)
}

;#####################################################################################

; Function				Gdip_GetImageWidth
; Description			Gives the width of a bitmap
;
; pBitmap				Pointer to a bitmap
;
; return				Returns the width in pixels of the supplied bitmap

Gdip_GetImageWidth(pBitmap)
{
	DllCall("gdiplus\GdipGetImageWidth", "UPtr", pBitmap, "uint*", &Width:=0)
	return Width
}

;#####################################################################################

; Function				Gdip_GetImageHeight
; Description			Gives the height of a bitmap
;
; pBitmap				Pointer to a bitmap
;
; return				Returns the height in pixels of the supplied bitmap

Gdip_GetImageHeight(pBitmap)
{
	DllCall("gdiplus\GdipGetImageHeight", "UPtr", pBitmap, "uint*", &Height:=0)
	return Height
}

;#####################################################################################

; Function				Gdip_GetDimensions
; Description			Gives the width and height of a bitmap
;
; pBitmap				Pointer to a bitmap
; Width					ByRef variable. This variable will be set to the width of the bitmap
; Height				ByRef variable. This variable will be set to the height of the bitmap
;
; return				No return value
;						Gdip_GetDimensions(pBitmap, ThisWidth, ThisHeight) will set ThisWidth to the width and ThisHeight to the height

Gdip_GetImageDimensions(pBitmap, &Width, &Height)
{
	DllCall("gdiplus\GdipGetImageWidth", "UPtr", pBitmap, "uint*", &Width:=0)
	DllCall("gdiplus\GdipGetImageHeight", "UPtr", pBitmap, "uint*", &Height:=0)
}

;#####################################################################################

Gdip_GetDimensions(pBitmap, &Width, &Height)
{
	Gdip_GetImageDimensions(pBitmap, &Width, &Height)
}

;#####################################################################################

Gdip_GetImagePixelFormat(pBitmap)
{
	DllCall("gdiplus\GdipGetImagePixelFormat", "UPtr", pBitmap, "UPtr*", &_Format:=0)
	return _Format
}

;#####################################################################################

; Function				Gdip_GetDpiX
; Description			Gives the horizontal dots per inch of the graphics of a bitmap
;
; pBitmap				Pointer to a bitmap
; Width					ByRef variable. This variable will be set to the width of the bitmap
; Height				ByRef variable. This variable will be set to the height of the bitmap
;
; return				No return value
;						Gdip_GetDimensions(pBitmap, ThisWidth, ThisHeight) will set ThisWidth to the width and ThisHeight to the height

Gdip_GetDpiX(pGraphics)
{
	DllCall("gdiplus\GdipGetDpiX", "UPtr", pGraphics, "float*", &dpix:=0)
	return Round(dpix)
}

;#####################################################################################

Gdip_GetDpiY(pGraphics)
{
	DllCall("gdiplus\GdipGetDpiY", "UPtr", pGraphics, "float*", &dpiy:=0)
	return Round(dpiy)
}

;#####################################################################################

Gdip_GetImageHorizontalResolution(pBitmap)
{
	DllCall("gdiplus\GdipGetImageHorizontalResolution", "UPtr", pBitmap, "float*", &dpix:=0)
	return Round(dpix)
}

;#####################################################################################

Gdip_GetImageVerticalResolution(pBitmap)
{
	DllCall("gdiplus\GdipGetImageVerticalResolution", "UPtr", pBitmap, "float*", &dpiy:=0)
	return Round(dpiy)
}

;#####################################################################################

Gdip_BitmapSetResolution(pBitmap, dpix, dpiy)
{
	return DllCall("gdiplus\GdipBitmapSetResolution", "UPtr", pBitmap, "Float", dpix, "Float", dpiy)
}

;#####################################################################################

Gdip_CreateBitmapFromFile(sFile, IconNumber:=1, IconSize:="")
{
	SplitPath sFile,,, &extension:=""
	if RegExMatch(extension, "^(?i:exe|dll)$") {
		Sizes := IconSize ? IconSize : 256 "|" 128 "|" 64 "|" 48 "|" 32 "|" 16
		BufSize := 16 + (2*(A_PtrSize ? A_PtrSize : 4))

		buf := Buffer(BufSize, 0)
		hIcon := 0

		for eachSize, Size in StrSplit( Sizes, "|" ) {
			DllCall("PrivateExtractIcons", "str", sFile, "Int", IconNumber-1, "Int", Size, "Int", Size, "UPtr*", &hIcon, "UPtr*", 0, "UInt", 1, "UInt", 0)

			if (!hIcon) {
				continue
			}

			if !DllCall("GetIconInfo", "UPtr", hIcon, "UPtr", buf.Ptr) {
				DestroyIcon(hIcon)
				continue
			}

			hbmMask  := NumGet(buf, 12 + ((A_PtrSize ? A_PtrSize : 4) - 4))
			hbmColor := NumGet(buf, 12 + ((A_PtrSize ? A_PtrSize : 4) - 4) + (A_PtrSize ? A_PtrSize : 4))
			if !(hbmColor && DllCall("GetObject", "UPtr", hbmColor, "Int", BufSize, "UPtr", buf.Ptr))
			{
				DestroyIcon(hIcon)
				continue
			}
			break
		}

		if (!hIcon) {
			return -1
		}

		Width := NumGet(buf, 4, "Int"), Height := NumGet(buf, 8, "Int")
		hbm := CreateDIBSection(Width, -Height), hdc := CreateCompatibleDC(), obm := SelectObject(hdc, hbm)
		if !DllCall("DrawIconEx", "UPtr", hdc, "Int", 0, "Int", 0, "UPtr", hIcon, "UInt", Width, "UInt", Height, "UInt", 0, "UPtr", 0, "UInt", 3) {
			DestroyIcon(hIcon)
			return -2
		}

		dib := Buffer(104)
		DllCall("GetObject", "UPtr", hbm, "Int", A_PtrSize = 8 ? 104 : 84, "UPtr", dib.Ptr) ; sizeof(DIBSECTION) = 76+2*(A_PtrSize=8?4:0)+2*A_PtrSize
		Stride := NumGet(dib, 12, "Int"), Bits := NumGet(dib, 20 + (A_PtrSize = 8 ? 4 : 0)) ; padding
		DllCall("gdiplus\GdipCreateBitmapFromScan0", "Int", Width, "Int", Height, "Int", Stride, "Int", 0x26200A, "UPtr", Bits, "UPtr*", &pBitmapOld:=0)
		pBitmap := Gdip_CreateBitmap(Width, Height)
		_G := Gdip_GraphicsFromImage(pBitmap)
		, Gdip_DrawImage(_G, pBitmapOld, 0, 0, Width, Height, 0, 0, Width, Height)
		SelectObject(hdc, obm), DeleteObject(hbm), DeleteDC(hdc)
		Gdip_DeleteGraphics(_G), Gdip_DisposeImage(pBitmapOld)
		DestroyIcon(hIcon)

	} else {
		DllCall("gdiplus\GdipCreateBitmapFromFile", "UPtr", StrPtr(sFile), "UPtr*", &pBitmap:=0)
	}

	return pBitmap
}

;#####################################################################################

Gdip_CreateBitmapFromHBITMAP(hBitmap, Palette:=0)
{
	DllCall("gdiplus\GdipCreateBitmapFromHBITMAP", "UPtr", hBitmap, "UPtr", Palette, "UPtr*", &pBitmap:=0)
	return pBitmap
}

;#####################################################################################

Gdip_CreateHBITMAPFromBitmap(pBitmap, Background:=0xffffffff)
{
	DllCall("gdiplus\GdipCreateHBITMAPFromBitmap", "UPtr", pBitmap, "UPtr*", &hbm:=0, "Int", Background)
	return hbm
}

;#####################################################################################

Gdip_CreateARGBBitmapFromHBITMAP(&hBitmap) {
	; struct BITMAP - https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmap
	dib := Buffer(76+2*(A_PtrSize=8?4:0)+2*A_PtrSize)
	DllCall("GetObject"
				,    "ptr", hBitmap
				,    "Int", dib.Size
				,    "ptr", dib.Ptr) ; sizeof(DIBSECTION) = 84, 104
		, width  := NumGet(dib, 4, "UInt")
		, height := NumGet(dib, 8, "UInt")
		, bpp    := NumGet(dib, 18, "ushort")

	; Fallback to built-in method if pixels are not 32-bit ARGB.
	if (bpp != 32) { ; This built-in version is 120% faster but ignores transparency.
		DllCall("gdiplus\GdipCreateBitmapFromHBITMAP", "ptr", hBitmap, "ptr", 0, "ptr*", &pBitmap:=0)
		return pBitmap
	}

	; Create a handle to a device context and associate the image.
	hdc := DllCall("CreateCompatibleDC", "ptr", 0, "ptr")             ; Creates a memory DC compatible with the current screen.
	obm := DllCall("SelectObject", "ptr", hdc, "ptr", hBitmap, "ptr") ; Put the (hBitmap) image onto the device context.

	; Create a device independent bitmap with negative height. All DIBs use the screen pixel format (pARGB).
	; Use hbm to buffer the image such that top-down and bottom-up images are mapped to this top-down buffer.
	cdc := DllCall("CreateCompatibleDC", "ptr", hdc, "ptr")
	bi := Buffer(40, 0)               ; sizeof(bi) = 40
	NumPut(
		"UInt", 	40, 	; Size
		"UInt", 	width,	; Width
		"Int", 		height, ; Height - Negative so (0, 0) is top-left.
		"ushort",	1, 		; Planes
		"ushort",	32, 	; BitCount / BitsPerPixel
		bi)
	hbm := DllCall("CreateDIBSection", "ptr", cdc, "ptr", bi.Ptr, "UInt", 0
				, "ptr*", &pBits:=0  ; pBits is the pointer to (top-down) pixel values.
				, "ptr", 0, "UInt", 0, "ptr")
	ob2 := DllCall("SelectObject", "ptr", cdc, "ptr", hbm, "ptr")

	; This is the 32-bit ARGB pBitmap (different from an hBitmap) that will receive the final converted pixels.
	DllCall("gdiplus\GdipCreateBitmapFromScan0"
				, "Int", width, "Int", height, "Int", 0, "Int", 0x26200A, "ptr", 0, "ptr*", &pBitmap:=0)

	; Create a Scan0 buffer pointing to pBits. The buffer has pixel format pARGB.
	Rect := Buffer(16, 0)              ; sizeof(Rect) = 16
	NumPut(
		"UInt",   width,	; Width
		"UInt",  height,	; Height
		Rect, 8)
	
	BitmapData := Buffer(16+2*A_PtrSize, 0)     ; sizeof(BitmapData) = 24, 32
	NumPut(
		"UInt", width, 		; Width
		"UInt", height, 	; Height
		"Int",  4 * width,	; Stride
		"Int",  0xE200B, 	; PixelFormat
		"ptr",  pBits, 	 	; Scan0
		BitmapData)

	; Use LockBits to create a writable buffer that converts pARGB to ARGB.
	DllCall("gdiplus\GdipBitmapLockBits"
				,    "ptr", pBitmap
				,    "ptr", Rect.Ptr
				,   "UInt", 6            ; ImageLockMode.UserInputBuffer | ImageLockMode.WriteOnly
				,    "Int", 0xE200B      ; Format32bppPArgb
				,    "ptr", BitmapData.Ptr) ; Contains the pointer (pBits) to the hbm.

	; Copies the image (hBitmap) to a top-down bitmap. Removes bottom-up-ness if present.
	DllCall("gdi32\BitBlt"
				, "ptr", cdc, "Int", 0, "Int", 0, "Int", width, "Int", height
				, "ptr", hdc, "Int", 0, "Int", 0, "UInt", 0x00CC0020) ; SRCCOPY

	; Convert the pARGB pixels copied into the device independent bitmap (hbm) to ARGB.
	DllCall("gdiplus\GdipBitmapUnlockBits", "ptr", pBitmap, "ptr", BitmapData.Ptr)

	; Cleanup the buffer and device contexts.
	DllCall("SelectObject", "ptr", cdc, "ptr", ob2)
	DllCall("DeleteObject", "ptr", hbm)
	DllCall("DeleteDC",     "ptr", cdc)
	DllCall("SelectObject", "ptr", hdc, "ptr", obm)
	DllCall("DeleteDC",     "ptr", hdc)

	return pBitmap
}

;#####################################################################################

Gdip_CreateARGBHBITMAPFromBitmap(&pBitmap) {
	; This version is about 25% faster than Gdip_CreateHBITMAPFromBitmap().
	; Get Bitmap width and height.
	DllCall("gdiplus\GdipGetImageWidth", "ptr", pBitmap, "uint*", &width:=0)
	DllCall("gdiplus\GdipGetImageHeight", "ptr", pBitmap, "uint*", &height:=0)

	; Convert the source pBitmap into a hBitmap manually.
	; struct BITMAPINFOHEADER - https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader
	hdc := DllCall("CreateCompatibleDC", "ptr", 0, "ptr")
	bi := Buffer(40, 0)               ; sizeof(bi) = 40
	NumPut(
		"UInt",     40,  		; Size
		"UInt",    	width,  	; Width
		"Int",  	-height,	; Height - Negative so (0, 0) is top-left.
		"ushort",   1, 			; Planes
		"ushort",   32,  		; BitCount / BitsPerPixel
		bi)
	hbm := DllCall("CreateDIBSection", "ptr", hdc, "ptr", bi.Ptr, "UInt", 0, "ptr*", &pBits:=0, "ptr", 0, "UInt", 0, "ptr")
	obm := DllCall("SelectObject", "ptr", hdc, "ptr", hbm, "ptr")

	; Transfer data from source pBitmap to an hBitmap manually.
	Rect := Buffer(16, 0)              ; sizeof(Rect) = 16
	NumPut(
		"UInt",   width,	; Width
		"UInt",  height, 	; Height
		Rect, 8)
	BitmapData := Buffer(16+2*A_PtrSize, 0)     ; sizeof(BitmapData) = 24, 32
	NumPut(
		"UInt",     width, 	; Width
		"UInt",    height, 	; Height
		"Int",  4 * width, 	; Stride
		"Int",    0xE200B, 	; PixelFormat
		"ptr",      pBits, 	; Scan0
		BitmapData)
	DllCall("gdiplus\GdipBitmapLockBits"
				,    "ptr", pBitmap
				,    "ptr", Rect.Ptr
				,   "UInt", 5            ; ImageLockMode.UserInputBuffer | ImageLockMode.ReadOnly
				,    "Int", 0xE200B      ; Format32bppPArgb
				,    "ptr", BitmapData.Ptr) ; Contains the pointer (pBits) to the hbm.
	DllCall("gdiplus\GdipBitmapUnlockBits", "ptr", pBitmap, "ptr", BitmapData.Ptr)

	; Cleanup the hBitmap and device contexts.
	DllCall("SelectObject", "ptr", hdc, "ptr", obm)
	DllCall("DeleteDC",     "ptr", hdc)

	return hbm
}

;#####################################################################################

Gdip_CreateBitmapFromHICON(hIcon)
{
	DllCall("gdiplus\GdipCreateBitmapFromHICON", "UPtr", hIcon, "UPtr*", &pBitmap:=0)
	return pBitmap
}

;#####################################################################################

Gdip_CreateHICONFromBitmap(pBitmap)
{
	DllCall("gdiplus\GdipCreateHICONFromBitmap", "UPtr", pBitmap, "UPtr*", &hIcon:=0)
	return hIcon
}

;#####################################################################################

Gdip_CreateBitmap(Width, Height, Format:=0x26200A)
{
	DllCall("gdiplus\GdipCreateBitmapFromScan0", "Int", Width, "Int", Height, "Int", 0, "Int", Format, "UPtr", 0, "UPtr*", &pBitmap:=0)
	return pBitmap
}

;#####################################################################################

Gdip_CreateBitmapFromClipboard()
{
	if !DllCall("IsClipboardFormatAvailable", "UInt", 8) {
		return -2
	}

	if !DllCall("OpenClipboard", "UPtr", 0) {
		return -1
	}

	hBitmap := DllCall("GetClipboardData", "UInt", 2, "UPtr")

	if !DllCall("CloseClipboard") {
		return -5
	}

	if !hBitmap {
		return -3
	}

	pBitmap := Gdip_CreateBitmapFromHBITMAP(hBitmap)
	if (!pBitmap) {
		return -4
	}

	DeleteObject(hBitmap)

	return pBitmap
}

;#####################################################################################

Gdip_SetBitmapToClipboard(pBitmap)
{
	off1 := A_PtrSize = 8 ? 52 : 44, off2 := A_PtrSize = 8 ? 32 : 24
	hBitmap := Gdip_CreateHBITMAPFromBitmap(pBitmap)
	oi := Buffer(A_PtrSize = 8 ? 104 : 84, 0)
	DllCall("GetObject", "UPtr", hBitmap, "Int", oi.Size, "UPtr", oi.Ptr)
	hdib := DllCall("GlobalAlloc", "UInt", 2, "UPtr", 40+NumGet(oi, off1, "UInt"), "UPtr")
	pdib := DllCall("GlobalLock", "UPtr", hdib, "UPtr")
	DllCall("RtlMoveMemory", "UPtr", pdib, "UPtr", oi.Ptr+off2, "UPtr", 40)
	DllCall("RtlMoveMemory", "UPtr", pdib+40, "UPtr", NumGet(oi, off2 - (A_PtrSize ? A_PtrSize : 4), "UPtr"), "UPtr", NumGet(oi, off1, "UInt"))
	DllCall("GlobalUnlock", "UPtr", hdib)
	DllCall("DeleteObject", "UPtr", hBitmap)
	DllCall("OpenClipboard", "UPtr", 0)
	DllCall("EmptyClipboard")
	DllCall("SetClipboardData", "UInt", 8, "UPtr", hdib)
	DllCall("CloseClipboard")
}

;#####################################################################################

Gdip_CloneBitmapArea(pBitmap, x, y, w, h, Format:=0x26200A)
{
	DllCall("gdiplus\GdipCloneBitmapArea"
					, "Float", x
					, "Float", y
					, "Float", w
					, "Float", h
					, "Int", Format
					, "UPtr", pBitmap
					, "UPtr*", &pBitmapDest:=0)
	return pBitmapDest
}

;#####################################################################################
; Create resources
;#####################################################################################

Gdip_CreatePen(ARGB, w)
{
	DllCall("gdiplus\GdipCreatePen1", "UInt", ARGB, "Float", w, "Int", 2, "UPtr*", &pPen:=0)
	return pPen
}

;#####################################################################################

Gdip_CreatePenFromBrush(pBrush, w)
{
	DllCall("gdiplus\GdipCreatePen2", "UPtr", pBrush, "Float", w, "Int", 2, "UPtr*", &pPen:=0)
	return pPen
}

;#####################################################################################

Gdip_BrushCreateSolid(ARGB:=0xff000000)
{
	DllCall("gdiplus\GdipCreateSolidFill", "UInt", ARGB, "UPtr*", &pBrush:=0)
	return pBrush
}

;#####################################################################################

; HatchStyleHorizontal = 0
; HatchStyleVertical = 1
; HatchStyleForwardDiagonal = 2
; HatchStyleBackwardDiagonal = 3
; HatchStyleCross = 4
; HatchStyleDiagonalCross = 5
; HatchStyle05Percent = 6
; HatchStyle10Percent = 7
; HatchStyle20Percent = 8
; HatchStyle25Percent = 9
; HatchStyle30Percent = 10
; HatchStyle40Percent = 11
; HatchStyle50Percent = 12
; HatchStyle60Percent = 13
; HatchStyle70Percent = 14
; HatchStyle75Percent = 15
; HatchStyle80Percent = 16
; HatchStyle90Percent = 17
; HatchStyleLightDownwardDiagonal = 18
; HatchStyleLightUpwardDiagonal = 19
; HatchStyleDarkDownwardDiagonal = 20
; HatchStyleDarkUpwardDiagonal = 21
; HatchStyleWideDownwardDiagonal = 22
; HatchStyleWideUpwardDiagonal = 23
; HatchStyleLightVertical = 24
; HatchStyleLightHorizontal = 25
; HatchStyleNarrowVertical = 26
; HatchStyleNarrowHorizontal = 27
; HatchStyleDarkVertical = 28
; HatchStyleDarkHorizontal = 29
; HatchStyleDashedDownwardDiagonal = 30
; HatchStyleDashedUpwardDiagonal = 31
; HatchStyleDashedHorizontal = 32
; HatchStyleDashedVertical = 33
; HatchStyleSmallConfetti = 34
; HatchStyleLargeConfetti = 35
; HatchStyleZigZag = 36
; HatchStyleWave = 37
; HatchStyleDiagonalBrick = 38
; HatchStyleHorizontalBrick = 39
; HatchStyleWeave = 40
; HatchStylePlaid = 41
; HatchStyleDivot = 42
; HatchStyleDottedGrid = 43
; HatchStyleDottedDiamond = 44
; HatchStyleShingle = 45
; HatchStyleTrellis = 46
; HatchStyleSphere = 47
; HatchStyleSmallGrid = 48
; HatchStyleSmallCheckerBoard = 49
; HatchStyleLargeCheckerBoard = 50
; HatchStyleOutlinedDiamond = 51
; HatchStyleSolidDiamond = 52
; HatchStyleTotal = 53
Gdip_BrushCreateHatch(ARGBfront, ARGBback, HatchStyle:=0)
{
	DllCall("gdiplus\GdipCreateHatchBrush", "Int", HatchStyle, "UInt", ARGBfront, "UInt", ARGBback, "UPtr*", &pBrush:=0)
	return pBrush
}

;#####################################################################################

Gdip_CreateTextureBrush(pBitmap, WrapMode:=1, x:=0, y:=0, w:="", h:="")
{
	if !(w && h) {
		DllCall("gdiplus\GdipCreateTexture", "UPtr", pBitmap, "Int", WrapMode, "UPtr*", &pBrush:=0)
	} else {
		DllCall("gdiplus\GdipCreateTexture2", "UPtr", pBitmap, "Int", WrapMode, "Float", x, "Float", y, "Float", w, "Float", h, "UPtr*", &pBrush:=0)
	}

	return pBrush
}

;#####################################################################################

; WrapModeTile = 0
; WrapModeTileFlipX = 1
; WrapModeTileFlipY = 2
; WrapModeTileFlipXY = 3
; WrapModeClamp = 4
Gdip_CreateLineBrush(x1, y1, x2, y2, ARGB1, ARGB2, WrapMode:=1)
{
	CreatePointF(&PointF1:="", x1, y1), CreatePointF(&PointF2:="", x2, y2)
	DllCall("gdiplus\GdipCreateLineBrush", "UPtr", PointF1.Ptr, "UPtr", PointF2.Ptr, "UInt", ARGB1, "UInt", ARGB2, "Int", WrapMode, "UPtr*", &LGpBrush:=0)
	return LGpBrush
}

;#####################################################################################

; LinearGradientModeHorizontal = 0
; LinearGradientModeVertical = 1
; LinearGradientModeForwardDiagonal = 2
; LinearGradientModeBackwardDiagonal = 3
Gdip_CreateLineBrushFromRect(x, y, w, h, ARGB1, ARGB2, LinearGradientMode:=1, WrapMode:=1)
{
	CreateRectF(&RectF:="", x, y, w, h)
	DllCall("gdiplus\GdipCreateLineBrushFromRect", "UPtr", RectF.Ptr, "Int", ARGB1, "Int", ARGB2, "Int", LinearGradientMode, "Int", WrapMode, "UPtr*", &LGpBrush:=0)
	return LGpBrush
}

;#####################################################################################

Gdip_CloneBrush(pBrush)
{
	DllCall("gdiplus\GdipCloneBrush", "UPtr", pBrush, "UPtr*", &pBrushClone:=0)
	return pBrushClone
}

;#####################################################################################
; Delete resources
;#####################################################################################

Gdip_DeletePen(pPen)
{
	return DllCall("gdiplus\GdipDeletePen", "UPtr", pPen)
}

;#####################################################################################

Gdip_DeleteBrush(pBrush)
{
	return DllCall("gdiplus\GdipDeleteBrush", "UPtr", pBrush)
}

;#####################################################################################

Gdip_DisposeImage(pBitmap)
{
	return DllCall("gdiplus\GdipDisposeImage", "UPtr", pBitmap)
}

;#####################################################################################

Gdip_DeleteGraphics(pGraphics)
{
	return DllCall("gdiplus\GdipDeleteGraphics", "UPtr", pGraphics)
}

;#####################################################################################

Gdip_DisposeImageAttributes(ImageAttr)
{
	return DllCall("gdiplus\GdipDisposeImageAttributes", "UPtr", ImageAttr)
}

;#####################################################################################

Gdip_DeleteFont(hFont)
{
	return DllCall("gdiplus\GdipDeleteFont", "UPtr", hFont)
}

;#####################################################################################

Gdip_DeleteStringFormat(hFormat)
{
	return DllCall("gdiplus\GdipDeleteStringFormat", "UPtr", hFormat)
}

;#####################################################################################

Gdip_DeleteFontFamily(hFamily)
{
	return DllCall("gdiplus\GdipDeleteFontFamily", "UPtr", hFamily)
}

;#####################################################################################

Gdip_DeleteMatrix(Matrix)
{
	return DllCall("gdiplus\GdipDeleteMatrix", "UPtr", Matrix)
}

;#####################################################################################
; Text functions
;#####################################################################################

Gdip_TextToGraphics(pGraphics, Text, Options, Font:="Arial", Width:="", Height:="", Measure:=0){
	IWidth := Width
	IHeight := Height
	PassBrush := 0


	pattern_opts := "i)"
	RegExMatch(Options, pattern_opts "X([\-\d\.]+)(p*)", &xpos:="")
	RegExMatch(Options, pattern_opts "Y([\-\d\.]+)(p*)", &ypos:="")
	RegExMatch(Options, pattern_opts "W([\-\d\.]+)(p*)", &Width:="")
	RegExMatch(Options, pattern_opts "H([\-\d\.]+)(p*)", &Height:="")
	RegExMatch(Options, pattern_opts "C(?!(entre|enter))([a-f\d]+)", &Colour:="")
	RegExMatch(Options, pattern_opts "Top|Up|Bottom|Down|vCentre|vCenter", &vPos:="")
	RegExMatch(Options, pattern_opts "NoWrap", &NoWrap:="")
	RegExMatch(Options, pattern_opts "R(\d)", &Rendering:="")
	RegExMatch(Options, pattern_opts "S(\d+)(p*)", &Size:="")

	if Colour && IsInteger(Colour[2]) && !Gdip_DeleteBrush(Gdip_CloneBrush(Colour[2])) {
		PassBrush := 1, pBrush := Colour[2]
	}

	if !(IWidth && IHeight) && ((xpos && xpos[2]) || (ypos && ypos[2]) || (Width && Width[2]) || (Height && Height[2]) || (Size && Size[2])) {
		return -1
	}

	Style := 0
	Styles := "Regular|Bold|Italic|BoldItalic|Underline|Strikeout"
	for eachStyle, valStyle in StrSplit( Styles, "|" ) {
		if RegExMatch(Options, "\b" valStyle)
			Style |= (valStyle != "StrikeOut") ? (A_Index-1) : 8
	}

	Align := 0
	Alignments := "Near|Left|Centre|Center|Far|Right"
	for eachAlignment, valAlignment in StrSplit( Alignments, "|" ) {
		if RegExMatch(Options, "\b" valAlignment) {
			Align |= A_Index*10//21	; 0|0|1|1|2|2
		}
	}

	xpos := (xpos && (xpos[1] != "")) ? xpos[2] ? IWidth*(xpos[1]/100) : xpos[1] : 0
	ypos := (ypos && (ypos[1] != "")) ? ypos[2] ? IHeight*(ypos[1]/100) : ypos[1] : 0
	Width := (Width && Width[1]) ? Width[2] ? IWidth*(Width[1]/100) : Width[1] : IWidth
	Height := (Height && Height[1]) ? Height[2] ? IHeight*(Height[1]/100) : Height[1] : IHeight

	if !PassBrush {
		Colour := "0x" (Colour && Colour[2] ? Colour[2] : "ff000000")
	}

	Rendering := (Rendering && (Rendering[1] >= 0) && (Rendering[1] <= 5)) ? Rendering[1] : 4
	Size := (Size && (Size[1] > 0)) ? Size[2] ? IHeight*(Size[1]/100) : Size[1] : 12

	hFamily := Gdip_FontFamilyCreate(Font)
	hFont := Gdip_FontCreate(hFamily, Size, Style)
	FormatStyle := NoWrap ? 0x4000 | 0x1000 : 0x4000
	hFormat := Gdip_StringFormatCreate(FormatStyle)
	pBrush := PassBrush ? pBrush : Gdip_BrushCreateSolid(Colour)

	if !(hFamily && hFont && hFormat && pBrush && pGraphics) {
		return !pGraphics ? -2 : !hFamily ? -3 : !hFont ? -4 : !hFormat ? -5 : !pBrush ? -6 : 0
	}

	CreateRectF(&RC:="", xpos, ypos, Width, Height)
	Gdip_SetStringFormatAlign(hFormat, Align)
	Gdip_SetTextRenderingHint(pGraphics, Rendering)
	ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hFormat, &RC)

	if vPos {
		ReturnRC := StrSplit(ReturnRC, "|")

		if (vPos[0] = "vCentre") || (vPos[0] = "vCenter")
            yPos += Floor( ( Height - ReturnRC[ 4 ] ) / 2 )
		else if (vPos[0] = "Top") || (vPos[0] = "Up")
			ypos := 0
		else if (vPos[0] = "Bottom") || (vPos[0] = "Down")
			ypos := Height-ReturnRC[4]

		CreateRectF(&RC, xpos, ypos, Width, ReturnRC[4])
		ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hFormat, &RC)
	}

	if !Measure {
		ReturnRC := Gdip_DrawString(pGraphics, Text, hFont, hFormat, pBrush, &RC)
	}

	if !PassBrush {
		Gdip_DeleteBrush(pBrush)
	}

	Gdip_DeleteStringFormat(hFormat)
	Gdip_DeleteFont(hFont)
	Gdip_DeleteFontFamily(hFamily)

	return ReturnRC
}

;#####################################################################################

Gdip_DrawString(pGraphics, sString, hFont, hFormat, pBrush, &RectF)
{
	return DllCall("gdiplus\GdipDrawString"
					, "UPtr", pGraphics
					, "UPtr", StrPtr(sString)
					, "Int", -1
					, "UPtr", hFont
					, "UPtr", RectF.Ptr
					, "UPtr", hFormat
					, "UPtr", pBrush)
}

;#####################################################################################

Gdip_MeasureString(pGraphics, sString, hFont, hFormat, &RectF)
{
	RC := Buffer(16)
	DllCall("gdiplus\GdipMeasureString"
					, "UPtr", pGraphics
					, "UPtr", StrPtr(sString)
					, "Int", -1
					, "UPtr", hFont
					, "UPtr", RectF.Ptr
					, "UPtr", hFormat
					, "UPtr", RC.Ptr
					, "uint*", &Chars:=0
					, "uint*", &Lines:=0)

	return RC.Ptr ? NumGet(RC, 0, "Float") "|" NumGet(RC, 4, "Float") "|" NumGet(RC, 8, "Float") "|" NumGet(RC, 12, "Float") "|" Chars "|" Lines : 0
}

; Near = 0
; Center = 1
; Far = 2
Gdip_SetStringFormatAlign(hFormat, Align)
{
	return DllCall("gdiplus\GdipSetStringFormatAlign", "UPtr", hFormat, "Int", Align)
}

; StringFormatFlagsDirectionRightToLeft    = 0x00000001
; StringFormatFlagsDirectionVertical       = 0x00000002
; StringFormatFlagsNoFitBlackBox           = 0x00000004
; StringFormatFlagsDisplayFormatControl    = 0x00000020
; StringFormatFlagsNoFontFallback          = 0x00000400
; StringFormatFlagsMeasureTrailingSpaces   = 0x00000800
; StringFormatFlagsNoWrap                  = 0x00001000
; StringFormatFlagsLineLimit               = 0x00002000
; StringFormatFlagsNoClip                  = 0x00004000
Gdip_StringFormatCreate(Format:=0, Lang:=0)
{
	DllCall("gdiplus\GdipCreateStringFormat", "Int", Format, "Int", Lang, "UPtr*", &hFormat:=0)
	return hFormat
}

; Regular = 0
; Bold = 1
; Italic = 2
; BoldItalic = 3
; Underline = 4
; Strikeout = 8
Gdip_FontCreate(hFamily, Size, Style:=0)
{
	DllCall("gdiplus\GdipCreateFont", "UPtr", hFamily, "Float", Size, "Int", Style, "Int", 0, "UPtr*", &hFont:=0)
	return hFont
}

Gdip_FontFamilyCreate(Font)
{
	DllCall("gdiplus\GdipCreateFontFamilyFromName"
					, "UPtr", StrPtr(Font)
					, "UInt", 0
					, "UPtr*", &hFamily:=0)

	return hFamily
}

;#####################################################################################
; Matrix functions
;#####################################################################################

Gdip_CreateAffineMatrix(m11, m12, m21, m22, x, y)
{
	DllCall("gdiplus\GdipCreateMatrix2", "Float", m11, "Float", m12, "Float", m21, "Float", m22, "Float", x, "Float", y, "UPtr*", &Matrix:=0)
	return Matrix
}

Gdip_CreateMatrix()
{
	DllCall("gdiplus\GdipCreateMatrix", "UPtr*", &Matrix:=0)
	return Matrix
}

;#####################################################################################
; GraphicsPath functions
;#####################################################################################

; Alternate = 0
; Winding = 1
Gdip_CreatePath(BrushMode:=0)
{
	DllCall("gdiplus\GdipCreatePath", "Int", BrushMode, "UPtr*", &pPath:=0)
	return pPath
}

Gdip_AddPathEllipse(pPath, x, y, w, h)
{
	return DllCall("gdiplus\GdipAddPathEllipse", "UPtr", pPath, "Float", x, "Float", y, "Float", w, "Float", h)
}

Gdip_AddPathPolygon(pPath, Points)
{
	Points := StrSplit(Points, "|")
	PointsLength := Points.Length
	PointF := Buffer(8*PointsLength)
	for eachPoint, Point in Points
	{
		Coord := StrSplit(Point, ",")
		NumPut("Float", Coord[1], PointF, 8*(A_Index-1))
		NumPut("Float", Coord[2], PointF, (8*(A_Index-1))+4)
	}

	return DllCall("gdiplus\GdipAddPathPolygon", "UPtr", pPath, "UPtr", PointF.Ptr, "Int", PointsLength)
}

Gdip_DeletePath(pPath)
{
	return DllCall("gdiplus\GdipDeletePath", "UPtr", pPath)
}

;#####################################################################################
; Quality functions
;#####################################################################################

; SystemDefault = 0
; SingleBitPerPixelGridFit = 1
; SingleBitPerPixel = 2
; AntiAliasGridFit = 3
; AntiAlias = 4
Gdip_SetTextRenderingHint(pGraphics, RenderingHint)
{
	return DllCall("gdiplus\GdipSetTextRenderingHint", "UPtr", pGraphics, "Int", RenderingHint)
}

; Default = 0
; LowQuality = 1
; HighQuality = 2
; Bilinear = 3
; Bicubic = 4
; NearestNeighbor = 5
; HighQualityBilinear = 6
; HighQualityBicubic = 7
Gdip_SetInterpolationMode(pGraphics, InterpolationMode)
{
	return DllCall("gdiplus\GdipSetInterpolationMode", "UPtr", pGraphics, "Int", InterpolationMode)
}

; Default = 0
; HighSpeed = 1
; HighQuality = 2
; None = 3
; AntiAlias = 4
Gdip_SetSmoothingMode(pGraphics, SmoothingMode)
{
	return DllCall("gdiplus\GdipSetSmoothingMode", "UPtr", pGraphics, "Int", SmoothingMode)
}

; CompositingModeSourceOver = 0 (blended)
; CompositingModeSourceCopy = 1 (overwrite)
Gdip_SetCompositingMode(pGraphics, CompositingMode:=0)
{
	return DllCall("gdiplus\GdipSetCompositingMode", "UPtr", pGraphics, "Int", CompositingMode)
}

;#####################################################################################
; Extra functions
;#####################################################################################

Gdip_Startup()
{
	if (!DllCall("LoadLibrary", "str", "gdiplus", "UPtr")) {
		throw Error("Could not load GDI+ library")
	}

	si := Buffer(A_PtrSize = 4 ? 20:32, 0) ; sizeof(GdiplusStartupInputEx) = 20, 32
	NumPut("uint", 0x2, si)
	NumPut("uint", 0x4, si, A_PtrSize = 4 ? 16:24)
	DllCall("gdiplus\GdiplusStartup", "UPtr*", &pToken:=0, "Ptr", si, "UPtr", 0)
	if (!pToken) {
		throw Error("Gdiplus failed to start. Please ensure you have gdiplus on your system")
	}

	return pToken
}

Gdip_Shutdown(pToken)
{
	DllCall("gdiplus\GdiplusShutdown", "UPtr", pToken)
	hModule := DllCall("GetModuleHandle", "str", "gdiplus", "UPtr")
	if (!hModule) {
		throw Error("GDI+ library was unloaded before shutdown")
	}
	if (!DllCall("FreeLibrary", "UPtr", hModule)) {
		throw Error("Could not free GDI+ library")
	}

	return 0
}

; Prepend = 0; The new operation is applied before the old operation.
; Append = 1; The new operation is applied after the old operation.
Gdip_RotateWorldTransform(pGraphics, Angle, MatrixOrder:=0)
{
	return DllCall("gdiplus\GdipRotateWorldTransform", "UPtr", pGraphics, "Float", Angle, "Int", MatrixOrder)
}

Gdip_ScaleWorldTransform(pGraphics, x, y, MatrixOrder:=0)
{
	return DllCall("gdiplus\GdipScaleWorldTransform", "UPtr", pGraphics, "Float", x, "Float", y, "Int", MatrixOrder)
}

Gdip_TranslateWorldTransform(pGraphics, x, y, MatrixOrder:=0)
{
	return DllCall("gdiplus\GdipTranslateWorldTransform", "UPtr", pGraphics, "Float", x, "Float", y, "Int", MatrixOrder)
}

Gdip_ResetWorldTransform(pGraphics)
{
	return DllCall("gdiplus\GdipResetWorldTransform", "UPtr", pGraphics)
}

Gdip_GetRotatedTranslation(Width, Height, Angle, &xTranslation, &yTranslation)
{
	pi := 3.14159, TAngle := Angle*(pi/180)

	Bound := (Angle >= 0) ? Mod(Angle, 360) : 360-Mod(-Angle, -360)
	if ((Bound >= 0) && (Bound <= 90)) {
		xTranslation := Height*Sin(TAngle), yTranslation := 0
	} else if ((Bound > 90) && (Bound <= 180)) {
		xTranslation := (Height*Sin(TAngle))-(Width*Cos(TAngle)), yTranslation := -Height*Cos(TAngle)
	} else if ((Bound > 180) && (Bound <= 270)) {
		xTranslation := -(Width*Cos(TAngle)), yTranslation := -(Height*Cos(TAngle))-(Width*Sin(TAngle))
	} else if ((Bound > 270) && (Bound <= 360)) {
		xTranslation := 0, yTranslation := -Width*Sin(TAngle)
	}
}

Gdip_GetRotatedDimensions(Width, Height, Angle, &RWidth, &RHeight)
{
	pi := 3.14159, TAngle := Angle*(pi/180)

	if !(Width && Height) {
		return -1
	}

	RWidth := Ceil(Abs(Width*Cos(TAngle))+Abs(Height*Sin(TAngle)))
	RHeight := Ceil(Abs(Width*Sin(TAngle))+Abs(Height*Cos(Tangle)))
}

; RotateNoneFlipNone   = 0
; Rotate90FlipNone     = 1
; Rotate180FlipNone    = 2
; Rotate270FlipNone    = 3
; RotateNoneFlipX      = 4
; Rotate90FlipX        = 5
; Rotate180FlipX       = 6
; Rotate270FlipX       = 7
; RotateNoneFlipY      = Rotate180FlipX
; Rotate90FlipY        = Rotate270FlipX
; Rotate180FlipY       = RotateNoneFlipX
; Rotate270FlipY       = Rotate90FlipX
; RotateNoneFlipXY     = Rotate180FlipNone
; Rotate90FlipXY       = Rotate270FlipNone
; Rotate180FlipXY      = RotateNoneFlipNone
; Rotate270FlipXY      = Rotate90FlipNone

Gdip_ImageRotateFlip(pBitmap, RotateFlipType:=1)
{
	return DllCall("gdiplus\GdipImageRotateFlip", "UPtr", pBitmap, "Int", RotateFlipType)
}

; Replace = 0
; Intersect = 1
; Union = 2
; Xor = 3
; Exclude = 4
; Complement = 5
Gdip_SetClipRect(pGraphics, x, y, w, h, CombineMode:=0)
{
	return DllCall("gdiplus\GdipSetClipRect",  "UPtr", pGraphics, "Float", x, "Float", y, "Float", w, "Float", h, "Int", CombineMode)
}

Gdip_SetClipPath(pGraphics, pPath, CombineMode:=0)
{
	return DllCall("gdiplus\GdipSetClipPath", "UPtr", pGraphics, "UPtr", pPath, "Int", CombineMode)
}

Gdip_ResetClip(pGraphics)
{
	return DllCall("gdiplus\GdipResetClip", "UPtr", pGraphics)
}

Gdip_GetClipRegion(pGraphics)
{
	Region := Gdip_CreateRegion()
	DllCall("gdiplus\GdipGetClip", "UPtr", pGraphics, "UInt", Region)
	return Region
}

Gdip_SetClipRegion(pGraphics, Region, CombineMode:=0)
{
	return DllCall("gdiplus\GdipSetClipRegion", "UPtr", pGraphics, "UPtr", Region, "Int", CombineMode)
}

Gdip_CreateRegion()
{
	DllCall("gdiplus\GdipCreateRegion", "UInt*", &Region:=0)
	return Region
}

Gdip_DeleteRegion(Region)
{
	return DllCall("gdiplus\GdipDeleteRegion", "UPtr", Region)
}

;#####################################################################################
; BitmapLockBits
;#####################################################################################

Gdip_LockBits(pBitmap, x, y, w, h, &Stride, &Scan0, &BitmapData, LockMode := 3, PixelFormat := 0x26200a)
{
	CreateRect(&_Rect:="", x, y, w, h)
	BitmapData := Buffer(16+2*(A_PtrSize ? A_PtrSize : 4), 0)
	_E := DllCall("Gdiplus\GdipBitmapLockBits", "UPtr", pBitmap, "UPtr", _Rect.Ptr, "UInt", LockMode, "Int", PixelFormat, "UPtr", BitmapData.Ptr)
	Stride := NumGet(BitmapData, 8, "Int")
	Scan0 := NumGet(BitmapData, 16, "UPtr")
	return _E
}

;#####################################################################################

Gdip_UnlockBits(pBitmap, &BitmapData)
{
	return DllCall("Gdiplus\GdipBitmapUnlockBits", "UPtr", pBitmap, "UPtr", BitmapData.Ptr)
}

;#####################################################################################

Gdip_SetLockBitPixel(ARGB, Scan0, x, y, Stride)
{
	Numput("UInt", ARGB, Scan0+0, (x*4)+(y*Stride))
}

;#####################################################################################

Gdip_GetLockBitPixel(Scan0, x, y, Stride)
{
	return NumGet(Scan0+0, (x*4)+(y*Stride), "UInt")
}

;#####################################################################################

Gdip_PixelateBitmap(pBitmap, &pBitmapOut, BlockSize)
{
	static PixelateBitmap := ""

	if (!PixelateBitmap)
	{
		if A_PtrSize != 8 ; x86 machine code
		MCode_PixelateBitmap := "
		(LTrim Join
		558BEC83EC3C8B4514538B5D1C99F7FB56578BC88955EC894DD885C90F8E830200008B451099F7FB8365DC008365E000894DC88955F08945E833FF897DD4
		397DE80F8E160100008BCB0FAFCB894DCC33C08945F88945FC89451C8945143BD87E608B45088D50028BC82BCA8BF02BF2418945F48B45E02955F4894DC4
		8D0CB80FAFCB03CA895DD08BD1895DE40FB64416030145140FB60201451C8B45C40FB604100145FC8B45F40FB604020145F883C204FF4DE475D6034D18FF
		4DD075C98B4DCC8B451499F7F98945148B451C99F7F989451C8B45FC99F7F98945FC8B45F899F7F98945F885DB7E648B450C8D50028BC82BCA83C103894D
		C48BC82BCA41894DF48B4DD48945E48B45E02955E48D0C880FAFCB03CA895DD08BD18BF38A45148B7DC48804178A451C8B7DF488028A45FC8804178A45F8
		8B7DE488043A83C2044E75DA034D18FF4DD075CE8B4DCC8B7DD447897DD43B7DE80F8CF2FEFFFF837DF0000F842C01000033C08945F88945FC89451C8945
		148945E43BD87E65837DF0007E578B4DDC034DE48B75E80FAF4D180FAFF38B45088D500203CA8D0CB18BF08BF88945F48B45F02BF22BFA2955F48945CC0F
		B6440E030145140FB60101451C0FB6440F010145FC8B45F40FB604010145F883C104FF4DCC75D8FF45E4395DE47C9B8B4DF00FAFCB85C9740B8B451499F7
		F9894514EB048365140033F63BCE740B8B451C99F7F989451CEB0389751C3BCE740B8B45FC99F7F98945FCEB038975FC3BCE740B8B45F899F7F98945F8EB
		038975F88975E43BDE7E5A837DF0007E4C8B4DDC034DE48B75E80FAF4D180FAFF38B450C8D500203CA8D0CB18BF08BF82BF22BFA2BC28B55F08955CC8A55
		1488540E038A551C88118A55FC88540F018A55F888140183C104FF4DCC75DFFF45E4395DE47CA68B45180145E0015DDCFF4DC80F8594FDFFFF8B451099F7
		FB8955F08945E885C00F8E450100008B45EC0FAFC38365DC008945D48B45E88945CC33C08945F88945FC89451C8945148945103945EC7E6085DB7E518B4D
		D88B45080FAFCB034D108D50020FAF4D18034DDC8BF08BF88945F403CA2BF22BFA2955F4895DC80FB6440E030145140FB60101451C0FB6440F010145FC8B
		45F40FB604080145F883C104FF4DC875D8FF45108B45103B45EC7CA08B4DD485C9740B8B451499F7F9894514EB048365140033F63BCE740B8B451C99F7F9
		89451CEB0389751C3BCE740B8B45FC99F7F98945FCEB038975FC3BCE740B8B45F899F7F98945F8EB038975F88975103975EC7E5585DB7E468B4DD88B450C
		0FAFCB034D108D50020FAF4D18034DDC8BF08BF803CA2BF22BFA2BC2895DC88A551488540E038A551C88118A55FC88540F018A55F888140183C104FF4DC8
		75DFFF45108B45103B45EC7CAB8BC3C1E0020145DCFF4DCC0F85CEFEFFFF8B4DEC33C08945F88945FC89451C8945148945103BC87E6C3945F07E5C8B4DD8
		8B75E80FAFCB034D100FAFF30FAF4D188B45088D500203CA8D0CB18BF08BF88945F48B45F02BF22BFA2955F48945C80FB6440E030145140FB60101451C0F
		B6440F010145FC8B45F40FB604010145F883C104FF4DC875D833C0FF45108B4DEC394D107C940FAF4DF03BC874068B451499F7F933F68945143BCE740B8B
		451C99F7F989451CEB0389751C3BCE740B8B45FC99F7F98945FCEB038975FC3BCE740B8B45F899F7F98945F8EB038975F88975083975EC7E63EB0233F639
		75F07E4F8B4DD88B75E80FAFCB034D080FAFF30FAF4D188B450C8D500203CA8D0CB18BF08BF82BF22BFA2BC28B55F08955108A551488540E038A551C8811
		8A55FC88540F018A55F888140883C104FF4D1075DFFF45088B45083B45EC7C9F5F5E33C05BC9C21800
		)"
		else ; x64 machine code
		MCode_PixelateBitmap := "
		(LTrim Join
		4489442418488954241048894C24085355565741544155415641574883EC28418BC1448B8C24980000004C8BDA99488BD941F7F9448BD0448BFA8954240C
		448994248800000085C00F8E9D020000418BC04533E4458BF299448924244C8954241041F7F933C9898C24980000008BEA89542404448BE889442408EB05
		4C8B5C24784585ED0F8E1A010000458BF1418BFD48897C2418450FAFF14533D233F633ED4533E44533ED4585C97E5B4C63BC2490000000418D040A410FAF
		C148984C8D441802498BD9498BD04D8BD90FB642010FB64AFF4403E80FB60203E90FB64AFE4883C2044403E003F149FFCB75DE4D03C748FFCB75D0488B7C
		24188B8C24980000004C8B5C2478418BC59941F7FE448BE8418BC49941F7FE448BE08BC59941F7FE8BE88BC69941F7FE8BF04585C97E4048639C24900000
		004103CA4D8BC1410FAFC94863C94A8D541902488BCA498BC144886901448821408869FF408871FE4883C10448FFC875E84803D349FFC875DA8B8C249800
		0000488B5C24704C8B5C24784183C20448FFCF48897C24180F850AFFFFFF8B6C2404448B2424448B6C24084C8B74241085ED0F840A01000033FF33DB4533
		DB4533D24533C04585C97E53488B74247085ED7E42438D0C04418BC50FAF8C2490000000410FAFC18D04814863C8488D5431028BCD0FB642014403D00FB6
		024883C2044403D80FB642FB03D80FB642FA03F848FFC975DE41FFC0453BC17CB28BCD410FAFC985C9740A418BC299F7F98BF0EB0233F685C9740B418BC3
		99F7F9448BD8EB034533DB85C9740A8BC399F7F9448BD0EB034533D285C9740A8BC799F7F9448BC0EB034533C033D24585C97E4D4C8B74247885ED7E3841
		8D0C14418BC50FAF8C2490000000410FAFC18D04814863C84A8D4431028BCD40887001448818448850FF448840FE4883C00448FFC975E8FFC2413BD17CBD
		4C8B7424108B8C2498000000038C2490000000488B5C24704503E149FFCE44892424898C24980000004C897424100F859EFDFFFF448B7C240C448B842480
		000000418BC09941F7F98BE8448BEA89942498000000896C240C85C00F8E3B010000448BAC2488000000418BCF448BF5410FAFC9898C248000000033FF33
		ED33F64533DB4533D24533C04585FF7E524585C97E40418BC5410FAFC14103C00FAF84249000000003C74898488D541802498BD90FB642014403D00FB602
		4883C2044403D80FB642FB03F00FB642FA03E848FFCB75DE488B5C247041FFC0453BC77CAE85C9740B418BC299F7F9448BE0EB034533E485C9740A418BC3
		99F7F98BD8EB0233DB85C9740A8BC699F7F9448BD8EB034533DB85C9740A8BC599F7F9448BD0EB034533D24533C04585FF7E4E488B4C24784585C97E3541
		8BC5410FAFC14103C00FAF84249000000003C74898488D540802498BC144886201881A44885AFF448852FE4883C20448FFC875E941FFC0453BC77CBE8B8C
		2480000000488B5C2470418BC1C1E00203F849FFCE0F85ECFEFFFF448BAC24980000008B6C240C448BA4248800000033FF33DB4533DB4533D24533C04585
		FF7E5A488B7424704585ED7E48418BCC8BC5410FAFC94103C80FAF8C2490000000410FAFC18D04814863C8488D543102418BCD0FB642014403D00FB60248
		83C2044403D80FB642FB03D80FB642FA03F848FFC975DE41FFC0453BC77CAB418BCF410FAFCD85C9740A418BC299F7F98BF0EB0233F685C9740B418BC399
		F7F9448BD8EB034533DB85C9740A8BC399F7F9448BD0EB034533D285C9740A8BC799F7F9448BC0EB034533C033D24585FF7E4E4585ED7E42418BCC8BC541
		0FAFC903CA0FAF8C2490000000410FAFC18D04814863C8488B442478488D440102418BCD40887001448818448850FF448840FE4883C00448FFC975E8FFC2
		413BD77CB233C04883C428415F415E415D415C5F5E5D5BC3
		)"

		PixelateBitmap := Buffer(StrLen(MCode_PixelateBitmap)//2)
		nCount := StrLen(MCode_PixelateBitmap)//2
		loop nCount {
			NumPut("UChar", "0x" SubStr(MCode_PixelateBitmap, (2*A_Index)-1, 2), PixelateBitmap, A_Index-1)
		}
		DllCall("VirtualProtect", "UPtr", PixelateBitmap.Ptr, "UPtr", PixelateBitmap.Size, "UInt", 0x40, "UPtr*", 0)
	}

	Gdip_GetImageDimensions(pBitmap, &Width:="", &Height:="")

	if (Width != Gdip_GetImageWidth(pBitmapOut) || Height != Gdip_GetImageHeight(pBitmapOut))
		return -1
	if (BlockSize > Width || BlockSize > Height)
		return -2

	E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, &Stride1:="", &Scan01:="", &BitmapData1:="")
	E2 := Gdip_LockBits(pBitmapOut, 0, 0, Width, Height, &Stride2:="", &Scan02:="", &BitmapData2:="")
	if (E1 || E2)
		return -3

	; E := - unused exit code
	DllCall(PixelateBitmap.Ptr, "UPtr", Scan01, "UPtr", Scan02, "Int", Width, "Int", Height, "Int", Stride1, "Int", BlockSize)

	Gdip_UnlockBits(pBitmap, &BitmapData1), Gdip_UnlockBits(pBitmapOut, &BitmapData2)

	return 0
}

;#####################################################################################

Gdip_ToARGB(A, R, G, B)
{
	return (A << 24) | (R << 16) | (G << 8) | B
}

;#####################################################################################

Gdip_FromARGB(ARGB, &A, &R, &G, &B)
{
	A := (0xff000000 & ARGB) >> 24
	R := (0x00ff0000 & ARGB) >> 16
	G := (0x0000ff00 & ARGB) >> 8
	B := 0x000000ff & ARGB
}

;#####################################################################################

Gdip_AFromARGB(ARGB)
{
	return (0xff000000 & ARGB) >> 24
}

;#####################################################################################

Gdip_RFromARGB(ARGB)
{
	return (0x00ff0000 & ARGB) >> 16
}

;#####################################################################################

Gdip_GFromARGB(ARGB)
{
	return (0x0000ff00 & ARGB) >> 8
}

;#####################################################################################

Gdip_BFromARGB(ARGB)
{
	return 0x000000ff & ARGB
}

;#####################################################################################

StrGetB(Address, Length:=-1, Encoding:=0)
{
	; Flexible parameter handling:
	if !IsInteger(Length) {
		Encoding := Length,  Length := -1
	}

	; Check for obvious errors.
	if (Address+0 < 1024) {
		return
	}

	; Ensure 'Encoding' contains a numeric identifier.
	if (Encoding = "UTF-16") {
		Encoding := 1200
	} else if (Encoding = "UTF-8") {
		Encoding := 65001
	} else if SubStr(Encoding,1,2)="CP" {
		Encoding := SubStr(Encoding,3)
	}

	if !Encoding { 	; "" or 0
		; No conversion necessary, but we might not want the whole string.
		if (Length == -1)
			Length := DllCall("lstrlen", "UInt", Address)
		VarSetStrCapacity(&myString, Length)
		DllCall("lstrcpyn", "str", myString, "UInt", Address, "Int", Length + 1)

	} else if (Encoding = 1200) { 	; UTF-16
		char_count := DllCall("WideCharToMultiByte", "UInt", 0, "UInt", 0x400, "UInt", Address, "Int", Length, "UInt", 0, "UInt", 0, "UInt", 0, "UInt", 0)
		VarSetStrCapacity(&myString, char_count)
		DllCall("WideCharToMultiByte", "UInt", 0, "UInt", 0x400, "UInt", Address, "Int", Length, "str", myString, "Int", char_count, "UInt", 0, "UInt", 0)

	} else if IsInteger(Encoding) {
		; Convert from target encoding to UTF-16 then to the active code page.
		char_count := DllCall("MultiByteToWideChar", "UInt", Encoding, "UInt", 0, "UInt", Address, "Int", Length, "UInt", 0, "Int", 0)
		VarSetStrCapacity(&myString, char_count * 2)
		char_count := DllCall("MultiByteToWideChar", "UInt", Encoding, "UInt", 0, "UInt", Address, "Int", Length, "UInt", myString.Ptr, "Int", char_count * 2)
		myString := StrGetB(myString.Ptr, char_count, 1200)
	}

	return myString
}


; ======================================================================================================================
; Multiple Display Monitors Functions -> msdn.microsoft.com/en-us/library/dd145072(v=vs.85).aspx
; by 'just me'
; https://autohotkey.com/boards/viewtopic.php?f=6&t=4606
; ======================================================================================================================
GetMonitorCount()
{
	Monitors := MDMF_Enum()
	for k,v in Monitors {
		count := A_Index
	}
	return count
}

GetMonitorInfo(MonitorNum)
{
	Monitors := MDMF_Enum()
	for k,v in Monitors {
		if (v.Num = MonitorNum) {
			return v
		}
	}
}

GetPrimaryMonitor()
{
	Monitors := MDMF_Enum()
	for k,v in Monitors {
		if (v.Primary) {
			return v.Num
		}
	}
}
; ----------------------------------------------------------------------------------------------------------------------
; Name ..........: MDMF - Multiple Display Monitor Functions
; Description ...: Various functions for multiple display monitor environments
; Tested with ...: AHK 1.1.32.00 (A32/U32/U64) and 2.0-a108-a2fa0498 (U32/U64)
; Original Author: just me (https://www.autohotkey.com/boards/viewtopic.php?f=6&t=4606)
; Mod Authors ...: iPhilip, guest3456
; Changes .......: Modified to work with v2.0-a108 and changed 'Count' key to 'TotalCount' to avoid conflicts
; ................ Modified MDMF_Enum() so that it works under both AHK v1 and v2.
; ................ Modified MDMF_EnumProc() to provide Count and Primary keys to the Monitors array.
; ................ Modified MDMF_FromHWND() to allow flag values that determine the function's return value if the
; ................    window does not intersect any display monitor.
; ................ Modified MDMF_FromPoint() to allow the cursor position to be returned ByRef if not specified and
; ................    allow flag values that determine the function's return value if the point is not contained within
; ................    any display monitor.
; ................ Modified MDMF_FromRect() to allow flag values that determine the function's return value if the
; ................    rectangle does not intersect any display monitor.
;................. Modified MDMF_GetInfo() with minor changes.
; ----------------------------------------------------------------------------------------------------------------------
;
; ======================================================================================================================
; Multiple Display Monitors Functions -> msdn.microsoft.com/en-us/library/dd145072(v=vs.85).aspx =======================
; ======================================================================================================================
; Enumerates display monitors and returns an object containing the properties of all monitors or the specified monitor.
; ======================================================================================================================
MDMF_Enum(HMON := "") {
	static EnumProc := CallbackCreate(MDMF_EnumProc)
	static Monitors := Map()

	if (HMON = "") { 	; new enumeration
		Monitors := Map("TotalCount", 0)
		if !DllCall("User32.dll\EnumDisplayMonitors", "Ptr", 0, "Ptr", 0, "Ptr", EnumProc, "Ptr", ObjPtr(Monitors), "Int")
			return False
	}

	return (HMON = "") ? Monitors : Monitors.HasKey(HMON) ? Monitors[HMON] : False
}
; ======================================================================================================================
;  Callback function that is called by the MDMF_Enum function.
; ======================================================================================================================
MDMF_EnumProc(HMON, HDC, PRECT, ObjectAddr) {
	Monitors := ObjFromPtrAddRef(ObjectAddr)

	Monitors[HMON] := MDMF_GetInfo(HMON)
	Monitors["TotalCount"]++
	if (Monitors[HMON].Primary) {
		Monitors["Primary"] := HMON
	}

	return true
}
; ======================================================================================================================
; Retrieves the display monitor that has the largest area of intersection with a specified window.
; The following flag values determine the function's return value if the window does not intersect any display monitor:
;    MONITOR_DEFAULTTONULL    = 0 - Returns NULL.
;    MONITOR_DEFAULTTOPRIMARY = 1 - Returns a handle to the primary display monitor.
;    MONITOR_DEFAULTTONEAREST = 2 - Returns a handle to the display monitor that is nearest to the window.
; ======================================================================================================================
MDMF_FromHWND(HWND, Flag := 0) {
	return DllCall("User32.dll\MonitorFromWindow", "Ptr", HWND, "UInt", Flag, "Ptr")
}
; ======================================================================================================================
; Retrieves the display monitor that contains a specified point.
; If either X or Y is empty, the function will use the current cursor position for this value and return it ByRef.
; The following flag values determine the function's return value if the point is not contained within any
; display monitor:
;    MONITOR_DEFAULTTONULL    = 0 - Returns NULL.
;    MONITOR_DEFAULTTOPRIMARY = 1 - Returns a handle to the primary display monitor.
;    MONITOR_DEFAULTTONEAREST = 2 - Returns a handle to the display monitor that is nearest to the point.
; ======================================================================================================================
MDMF_FromPoint(&X:="", &Y:="", Flag:=0) {
	if (X = "") || (Y = "") {
		PT := Buffer(8, 0)
		DllCall("User32.dll\GetCursorPos", "Ptr", PT.Ptr, "Int")

		if (X = "") {
			X := NumGet(PT, 0, "Int")
		}

		if (Y = "") {
			Y := NumGet(PT, 4, "Int")
		}
	}
	return DllCall("User32.dll\MonitorFromPoint", "Int64", (X & 0xFFFFFFFF) | (Y << 32), "UInt", Flag, "Ptr")
}
; ======================================================================================================================
; Retrieves the display monitor that has the largest area of intersection with a specified rectangle.
; Parameters are consistent with the common AHK definition of a rectangle, which is X, Y, W, H instead of
; Left, Top, Right, Bottom.
; The following flag values determine the function's return value if the rectangle does not intersect any
; display monitor:
;    MONITOR_DEFAULTTONULL    = 0 - Returns NULL.
;    MONITOR_DEFAULTTOPRIMARY = 1 - Returns a handle to the primary display monitor.
;    MONITOR_DEFAULTTONEAREST = 2 - Returns a handle to the display monitor that is nearest to the rectangle.
; ======================================================================================================================
MDMF_FromRect(X, Y, W, H, Flag := 0) {
	RC := Buffer(16, 0)
	NumPut("Int", X, "Int", Y, "Int", X + W, "Int", Y + H, RC)
	return DllCall("User32.dll\MonitorFromRect", "Ptr", RC.Ptr, "UInt", Flag, "Ptr")
}
; ======================================================================================================================
; Retrieves information about a display monitor.
; ======================================================================================================================
MDMF_GetInfo(HMON) {
	MIEX := Buffer(40 + (32 << !!1))
	NumPut("UInt", MIEX.Size, MIEX)
	if DllCall("User32.dll\GetMonitorInfo", "Ptr", HMON, "Ptr", MIEX.Ptr, "Int") {
		return {Name:      (Name := StrGet(MIEX.Ptr + 40, 32))  ; CCHDEVICENAME = 32
		      , Num:       RegExReplace(Name, ".*(\d+)$", "$1")
		      , Left:      NumGet(MIEX, 4, "Int")    ; display rectangle
		      , Top:       NumGet(MIEX, 8, "Int")    ; "
		      , Right:     NumGet(MIEX, 12, "Int")   ; "
		      , Bottom:    NumGet(MIEX, 16, "Int")   ; "
		      , WALeft:    NumGet(MIEX, 20, "Int")   ; work area
		      , WATop:     NumGet(MIEX, 24, "Int")   ; "
		      , WARight:   NumGet(MIEX, 28, "Int")   ; "
		      , WABottom:  NumGet(MIEX, 32, "Int")   ; "
		      , Primary:   NumGet(MIEX, 36, "UInt")} ; contains a non-zero value for the primary monitor.
	}
	return False
}


; Based on WinGetClientPos by dd900 and Frosti - https://www.autohotkey.com/boards/viewtopic.php?t=484
WinGetRect( hwnd, &x:="", &y:="", &w:="", &h:="" ) {
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	CreateRect(&winRect, 0, 0, 0, 0) ;is 16 on both 32 and 64
	;VarSetCapacity( winRect, 16, 0 )	; Alternative of above two lines
	DllCall( "GetWindowRect", "Ptr", hwnd, "Ptr", winRect )
	x := NumGet(winRect,  0, "UInt")
	y := NumGet(winRect,  4, "UInt")
	w := NumGet(winRect,  8, "UInt") - x
	h := NumGet(winRect, 12, "UInt") - y
}
